{"version":3,"sources":["../../src/server/pubsub.js"],"names":["getIpfs","opts","subs","api","publish","pre","pubsub","subscribe","args","sub","topic","stubFn","Object","assign","data","seqno","name","rpc","fnName","push","catch","err","splice","indexOf","unsubscribe","find","s","peers","ls","close","Promise","all","map","then"],"mappings":"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","file":"pubsub.js","sourcesContent":["import { expose, caller } from 'postmsg-rpc'\nimport { pre } from 'prepost'\nimport { isFunctionJson } from '../serialization/function'\nimport { isBuffer, bufferToJson, preBufferFromJson } from '../serialization/buffer'\n\nexport default function (getIpfs, opts) {\n  const subs = [\n  /*\n    {\n      topic,    // name of the topic subscribed to\n      rpc: {    // details of the RPC stub created to send updates\n        fnName, // the RPC function name the stub calls\n        stubFn  // the RPC stub function created by postmsg-rpc\n      }\n    }\n  */\n  ]\n\n  const api = {\n    publish: expose('ipfs.pubsub.publish', pre(\n      preBufferFromJson(1),\n      opts.pre('pubsub.publish'),\n      (...args) => getIpfs().pubsub.publish(...args)\n    ), opts),\n    subscribe: expose('ipfs.pubsub.subscribe', function (...args) {\n      let sub\n\n      return pre(\n        (...args) => {\n          const topic = args[0]\n\n          if (isFunctionJson(args[1])) {\n            const stubFn = pre(\n              (...args) => {\n                if (args[0]) {\n                  args[0] = Object.assign({}, args[0])\n\n                  if (isBuffer(args[0].data)) {\n                    args[0].data = bufferToJson(args[0].data)\n                  }\n\n                  if (isBuffer(args[0].seqno)) {\n                    args[0].seqno = bufferToJson(args[0].seqno)\n                  }\n                }\n\n                return args\n              },\n              caller(args[1].name, opts)\n            )\n\n            sub = {\n              topic,\n              rpc: {\n                fnName: args[1].name,\n                stubFn\n              }\n            }\n\n            subs.push(sub)\n\n            args[1] = stubFn\n          }\n\n          return args\n        },\n        opts.pre('pubsub.subscribe'),\n        (...args) => {\n          return getIpfs().pubsub.subscribe(...args)\n            .catch((err) => {\n              subs.splice(subs.indexOf(sub), 1)\n              throw err\n            })\n        }\n      )(...args)\n    }, opts),\n    unsubscribe: expose('ipfs.pubsub.unsubscribe', pre(\n      (...args) => {\n        const topic = args[0]\n\n        if (isFunctionJson(args[1])) {\n          const sub = subs.find((s) => s.topic === topic && s.rpc.fnName === args[1].name)\n\n          if (sub) {\n            args[1] = sub.rpc.stubFn\n            subs.splice(subs.indexOf(sub), 1)\n          } else {\n            // Well, we don't have a reference to it, so the ipfs node won't\n            // either. We shouldn't error either because ipfs won't.\n            args[1] = () => {}\n          }\n        }\n\n        return args\n      },\n      opts.pre('pubsub.unsubscribe'),\n      (...args) => getIpfs().pubsub.unsubscribe(...args)\n    ), opts),\n    peers: expose('ipfs.pubsub.peers', pre(\n      opts.pre('pubsub.peers'),\n      (...args) => getIpfs().pubsub.peers(...args)\n    ), opts),\n    ls: expose('ipfs.pubsub.ls', pre(\n      opts.pre('pubsub.ls'),\n      (...args) => getIpfs().pubsub.ls(...args)\n    ), opts)\n  }\n\n  // Clean up any subscriptions on close\n  api.subscribe.close = pre(\n    (...args) => {\n      return Promise.all(\n        subs.map((sub) => getIpfs().pubsub.unsubscribe(sub.topic, sub.rpc.stubFn))\n      ).then(() => args)\n    },\n    api.subscribe.close\n  )\n\n  return api\n}\n"]}