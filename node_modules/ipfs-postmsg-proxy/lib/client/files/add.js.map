{"version":3,"sources":["../../../src/client/files/add.js"],"names":["opts","api","add","callbackify","variadic","args","fileToJsonOpts","pms","progress","onProgressIncrement","createOnProgressIncrement","Array","isArray","map","file","fileToJson","length","concat","addReadableStream","content","Transform","objectMode","transform","enc","cb","push","flush","apply","err","res","forEach","addPullStream","deferred","defer","source","abortable","readFnName","through","read","PMS","sink","then","resolve","name","catch","abort","pull","onProgress","bytes","incrementBytes","isStream","readable","pullStreamToJson","toPull","Object","assign","post","data"],"mappings":"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","file":"add.js","sourcesContent":["import { caller } from 'postmsg-rpc'\nimport callbackify from 'callbackify'\nimport { Transform } from 'stream'\nimport pull from 'pull-stream'\nimport PMS from 'pull-postmsg-stream'\nimport toPull from 'stream-to-pull-stream'\nimport isStream from 'is-stream'\nimport { isSource } from 'is-pull-stream'\nimport shortid from 'shortid'\nimport { pre } from 'prepost'\nimport defer from 'pull-defer'\nimport Abortable from 'pull-abortable'\nimport { isBuffer, bufferToJson } from '../../serialization/buffer'\nimport { functionToJson } from '../../serialization/function'\n\nexport default function (opts) {\n  const api = {\n    add: (() => {\n      const add = callbackify.variadic(\n        pre(\n          (...args) => {\n            const fileToJsonOpts = { pms: opts }\n\n            // FIXME: implement progress properly\n            if (args[1] && args[1].progress) {\n              fileToJsonOpts.onProgressIncrement = createOnProgressIncrement(args[1].progress)\n              delete args[1].progress\n            }\n\n            args[0] = Array.isArray(args[0])\n              ? args[0].map((file) => fileToJson(file, fileToJsonOpts))\n              : fileToJson(args[0], fileToJsonOpts)\n\n            return args\n          },\n          caller('ipfs.files.add', opts)\n        )\n      )\n\n      return (...args) => {\n        // Pull streams are just functions and so callbackify.variadic thinks\n        // the stream is a callback function! Instead explicitly pass null for\n        // the options arg.\n        if (args.length === 1 && isSource(args[0])) {\n          args = args.concat(null)\n        }\n\n        return add(...args)\n      }\n    })(),\n    // FIXME: implement add readable stream properly\n    addReadableStream (...args) {\n      const content = []\n      return new Transform({\n        objectMode: true,\n        transform (file, enc, cb) {\n          content.push(file)\n          cb()\n        },\n        flush (cb) {\n          api.add.apply(api, [content].concat(args, (err, res) => {\n            if (err) return cb(err)\n            res.forEach((file) => this.push(file))\n            cb()\n          }))\n        }\n      })\n    },\n    addPullStream: (() => {\n      const addPullStream = caller('ipfs.files.addPullStream', opts)\n\n      return (...args) => {\n        const deferred = defer.source()\n        const abortable = Abortable()\n        const fileToJsonOpts = { pms: opts }\n\n        // FIXME: implement progress properly\n        if (args[0] && args[0].progress) {\n          fileToJsonOpts.onProgressIncrement = createOnProgressIncrement(args[0].progress)\n          delete args[0].progress\n        }\n\n        const readFnName = shortid()\n\n        // Create the through stream what will connect the client to the\n        // server, our source is deferred, until the server responds to tell\n        // us the name of the read function we can use to pull added file\n        // info from.\n        const through = function (read) {\n          PMS.sink(readFnName, opts)(read)\n          return deferred\n        }\n\n        // Call addPullStream on the server, sending the name of the read\n        // function it can use to pull files to add from.\n        addPullStream(functionToJson(readFnName), ...args)\n          .then((res) => deferred.resolve(PMS.source(res.name, opts)))\n          .catch((err) => abortable.abort(err))\n\n        return pull(\n          pull.map((file) => fileToJson(file, fileToJsonOpts)),\n          through,\n          abortable\n        )\n      }\n    })()\n  }\n\n  return api\n}\n\nfunction createOnProgressIncrement (onProgress) {\n  let bytes = 0\n  return (incrementBytes) => {\n    bytes += incrementBytes\n    onProgress(bytes)\n    return bytes\n  }\n}\n\nfunction fileToJson (file, opts) {\n  opts = opts || {}\n\n  if (isBuffer(file)) { // Buffer\n    if (opts.onProgressIncrement) opts.onProgressIncrement(file.length)\n    return bufferToJson(file)\n  } else if (isStream.readable(file)) { // Node stream\n    return pullStreamToJson(toPull.source(file), opts)\n  } else if (isSource(file)) { // Pull stream\n    return pullStreamToJson(file, opts)\n  } else if (file && file.content) { // Object { path?, content }\n    return Object.assign({}, file, { content: fileToJson(file.content, opts) })\n  }\n\n  return file // Object { path } maybe, but could be anything\n}\n\nconst pullStreamToJson = (source, opts) => {\n  opts = opts || {}\n  const readFnName = shortid()\n\n  pull(\n    source,\n    PMS.sink(readFnName, Object.assign({}, opts.pms, {\n      post (res) {\n        if (isBuffer(res.data)) {\n          if (opts.onProgressIncrement) opts.onProgressIncrement(res.data.length)\n          res.data = bufferToJson(res.data)\n        }\n\n        return res\n      }\n    }))\n  )\n\n  return functionToJson(readFnName)\n}\n"]}