{"version":3,"sources":["../../src/client/pubsub.js"],"names":["opts","subs","api","publish","callbackify","variadic","subscribe","topic","handler","options","cb","sub","stub","args","fnName","rpc","exposedFn","data","seqno","process","nextTick","Promise","resolve","push","catch","err","close","splice","indexOf","then","res","unsubscribe","find","s","peers","ls","setMaxListeners"],"mappings":"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","file":"pubsub.js","sourcesContent":["import { caller, expose } from 'postmsg-rpc'\nimport callbackify from 'callbackify'\nimport shortid from 'shortid'\nimport { pre } from 'prepost'\nimport { functionToJson } from '../serialization/function'\nimport { isBufferJson, bufferFromJson, preBufferToJson } from '../serialization/buffer'\n\nexport default function (opts) {\n  const subs = [\n  /*\n    {\n      topic,      // name of the topic subscribed to\n      handler,    // the handler provided by the subscriber - rpc.exposedFn calls this function\n      rpc: {      // details of the exposed RPC function created to receive updates\n        fnName,   // the RPC function name\n        exposedFn // the exposed RPC function created by postmsg-rpc\n      }\n    }\n  */\n  ]\n\n  const api = {\n    publish: callbackify.variadic(\n      pre(\n        preBufferToJson(1),\n        caller('ipfs.pubsub.publish', opts)\n      )\n    ),\n    subscribe: function (topic, handler, options, cb) {\n      let sub\n\n      if (typeof options === 'function') {\n        cb = options\n        options = {}\n      }\n\n      const stub = pre(\n        (...args) => {\n          const fnName = `ipfs.pubsub.subscribe.handler.${shortid()}`\n\n          sub = {\n            topic,\n            handler,\n            rpc: {\n              fnName,\n              exposedFn: expose(fnName, pre(\n                (...args) => {\n                  if (args[0]) {\n                    if (isBufferJson(args[0].data)) {\n                      args[0].data = bufferFromJson(args[0].data)\n                    }\n\n                    if (isBufferJson(args[0].seqno)) {\n                      args[0].seqno = bufferFromJson(args[0].seqno)\n                    }\n                  }\n\n                  return args\n                },\n                (...args) => {\n                  process.nextTick(() => handler(...args))\n                  return Promise.resolve()\n                }\n              ), opts)\n            }\n          }\n\n          subs.push(sub)\n\n          args[1] = functionToJson(fnName)\n\n          return args\n        },\n        // If error, then remove subscription handler\n        (...args) => {\n          return caller('ipfs.pubsub.subscribe', opts)(...args)\n            .catch((err) => {\n              sub.rpc.exposedFn.close()\n              subs.splice(subs.indexOf(sub), 1)\n              throw err\n            })\n        }\n      )\n\n      if (cb) {\n        stub(topic, handler, options)\n          .then((res) => process.nextTick(() => cb(null, res)))\n          .catch((err) => process.nextTick(() => cb(err)))\n      } else {\n        return stub(topic, handler, options)\n      }\n    },\n    unsubscribe: callbackify.variadic(\n      pre(\n        (...args) => {\n          const topic = args[0]\n          const sub = subs.find((s) => s.topic === topic && s.handler === args[1])\n\n          if (sub) {\n            args[1] = functionToJson(sub.rpc.fnName)\n            sub.rpc.exposedFn.close()\n            subs.splice(subs.indexOf(sub), 1)\n          }\n\n          return args\n        },\n        caller('ipfs.pubsub.unsubscribe', opts)\n      )\n    ),\n    peers: callbackify.variadic(caller('ipfs.pubsub.peers', opts)),\n    ls: callbackify.variadic(caller('ipfs.pubsub.ls', opts)),\n    // interface-ipfs-core tests use this function\n    // noop since we're not an EventEmitter\n    setMaxListeners: () => api\n  }\n\n  return api\n}\n"]}