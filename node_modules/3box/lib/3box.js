"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var MuPort = require('muport-core');

var HDNode = require('ethers').utils.HDNode;

var localstorage = require('store');

var IPFS = require('ipfs');

var OrbitDB = require('orbit-db');

var Pubsub = require('orbit-db-pubsub'); // const OrbitDBCacheProxy = require('orbit-db-cache-postmsg-proxy').Client
// const { createProxyClient } = require('ipfs-postmsg-proxy')


var graphQLRequest = require('graphql-request').request;

var PublicStore = require('./publicStore');

var PrivateStore = require('./privateStore');

var Verified = require('./verified');

var OrbitdbKeyAdapter = require('./orbitdbKeyAdapter');

var utils = require('./utils/index');

var verifier = require('./utils/verifier');

var ADDRESS_SERVER_URL = 'https://beta.3box.io/address-server';
var PINNING_NODE = '/dnsaddr/ipfs.3box.io/tcp/443/wss/ipfs/QmZvxEpiVNjmNbEKyQGvFzAY1BwmGuuvdUTmcTstQPhyVC';
var PINNING_ROOM = '3box-pinning'; // const IFRAME_STORE_VERSION = '0.0.3'
// const IFRAME_STORE_URL = `https://iframe.3box.io/${IFRAME_STORE_VERSION}/iframe.html`

var IPFS_OPTIONS = {
  EXPERIMENTAL: {
    pubsub: true
  },
  preload: {
    enabled: false
  },
  config: {
    Bootstrap: []
  }
};
var GRAPHQL_SERVER_URL = 'https://aic67onptg.execute-api.us-west-2.amazonaws.com/develop/graphql';
var PROFILE_SERVER_URL = 'https://ipfs.3box.io';
var globalIPFS, globalOrbitDB; // , ipfsProxy, cacheProxy, iframeLoadedPromise

/*
if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  const iframe = document.createElement('iframe')
  iframe.src = IFRAME_STORE_URL
  iframe.style = 'width:0; height:0; border:0; border:none !important'

  iframeLoadedPromise = new Promise((resolve, reject) => {
    iframe.onload = () => { resolve() }
  })

  document.body.appendChild(iframe)
  // Create proxy clients that talks to the iframe
  const postMessage = iframe.contentWindow.postMessage.bind(iframe.contentWindow)
  ipfsProxy = createProxyClient({ postMessage })
  cacheProxy = OrbitDBCacheProxy({ postMessage })
} */

var Box =
/*#__PURE__*/
function () {
  /**
   * Please use the **openBox** method to instantiate a 3Box
   */
  function Box(muportDID, ethereumProvider) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck2.default)(this, Box);
    this._muportDID = muportDID;
    this._web3provider = ethereumProvider;
    this._serverUrl = opts.addressServer || ADDRESS_SERVER_URL;

    this._onSyncDoneCB = function () {};
    /**
     * @property {KeyValueStore} public         access the profile store of the users 3Box
     */


    this.public = null;
    /**
     * @property {KeyValueStore} private        access the private store of the users 3Box
     */

    this.private = null;
    /**
     * @property {Verified} verified       check and create verifications
     */

    this.verified = new Verified(this);
  }

  (0, _createClass2.default)(Box, [{
    key: "_load",
    value: function () {
      var _load2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2() {
        var _this = this;

        var opts,
            did,
            didFingerprint,
            rootStoreName,
            keystore,
            cache,
            rootStoreAddress,
            onNewPeer,
            _ref,
            _ref2,
            pubStoreAddress,
            privStoreAddress,
            syncPromises,
            hasResponse,
            onMessageRes,
            _args2 = arguments;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                opts = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                did = this._muportDID.getDid();
                didFingerprint = utils.sha256Multihash(did);
                rootStoreName = didFingerprint + '.root';
                this.pinningNode = opts.pinningNode || PINNING_NODE;
                _context2.next = 7;
                return initIPFS(opts.ipfs, opts.iframeStore, opts.ipfsOptions);

              case 7:
                this._ipfs = _context2.sent;

                this._ipfs.swarm.connect(this.pinningNode, function () {});

                keystore = new OrbitdbKeyAdapter(this._muportDID);
                cache = null; // (opts.iframeStore && !!cacheProxy) ? cacheProxy : null

                this._orbitdb = new OrbitDB(this._ipfs, opts.orbitPath, {
                  keystore: keystore,
                  cache: cache
                });
                globalIPFS = this._ipfs;
                globalOrbitDB = this._orbitdb;
                _context2.next = 16;
                return this._orbitdb.feed(rootStoreName);

              case 16:
                this._rootStore = _context2.sent;
                rootStoreAddress = this._rootStore.address.toString();
                _context2.t0 = Pubsub;
                _context2.t1 = this._ipfs;
                _context2.next = 22;
                return this._ipfs.id();

              case 22:
                _context2.t2 = _context2.sent.id;
                this._pubsub = new _context2.t0(_context2.t1, _context2.t2);

                onNewPeer = function onNewPeer(topic, peer) {
                  if (peer === _this.pinningNode.split('/').pop()) {
                    _this._pubsub.publish(PINNING_ROOM, {
                      type: 'PIN_DB',
                      odbAddress: rootStoreAddress
                    });
                  }
                };

                this.public = new PublicStore(this._orbitdb, didFingerprint + '.public', this._linkProfile.bind(this), this._ensurePinningNodeConnected.bind(this));
                this.private = new PrivateStore(this._muportDID, this._orbitdb, didFingerprint + '.private', this._ensurePinningNodeConnected.bind(this));
                _context2.next = 29;
                return Promise.all([this.public._load(), this.private._load()]);

              case 29:
                _ref = _context2.sent;
                _ref2 = (0, _slicedToArray2.default)(_ref, 2);
                pubStoreAddress = _ref2[0];
                privStoreAddress = _ref2[1];
                syncPromises = [];
                hasResponse = {};

                onMessageRes =
                /*#__PURE__*/
                function () {
                  var _ref3 = (0, _asyncToGenerator2.default)(
                  /*#__PURE__*/
                  _regenerator.default.mark(function _callee(topic, data) {
                    var promises;
                    return _regenerator.default.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            if (!(data.type === 'HAS_ENTRIES')) {
                              _context.next = 11;
                              break;
                            }

                            if (data.odbAddress === privStoreAddress && !hasResponse[privStoreAddress]) {
                              syncPromises.push(_this.private._sync(data.numEntries));
                              hasResponse[privStoreAddress] = true;
                            }

                            if (data.odbAddress === pubStoreAddress && !hasResponse[pubStoreAddress]) {
                              syncPromises.push(_this.public._sync(data.numEntries));
                              hasResponse[pubStoreAddress] = true;
                            }

                            if (!(syncPromises.length === 2)) {
                              _context.next = 11;
                              break;
                            }

                            promises = syncPromises;
                            syncPromises = [];
                            _context.next = 8;
                            return Promise.all(promises);

                          case 8:
                            _context.next = 10;
                            return _this._ensureDIDPublished();

                          case 10:
                            _this._onSyncDoneCB(); // this._pubsub.unsubscribe(PINNING_ROOM)


                          case 11:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee, this);
                  }));

                  return function onMessageRes(_x2, _x3) {
                    return _ref3.apply(this, arguments);
                  };
                }();

                this._pubsub.subscribe(PINNING_ROOM, onMessageRes, onNewPeer);

                this._createRootStore(rootStoreAddress, privStoreAddress, pubStoreAddress, this.pinningNode);

              case 38:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function _load() {
        return _load2.apply(this, arguments);
      };
    }()
  }, {
    key: "_createRootStore",
    value: function () {
      var _createRootStore2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3(rootStoreAddress, privOdbAddress, pubOdbAddress) {
        var entries;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._rootStore.load();

              case 2:
                _context3.next = 4;
                return this._rootStore.iterator({
                  limit: -1
                }).collect();

              case 4:
                entries = _context3.sent;

                if (entries.find(function (e) {
                  return e.payload.value.odbAddress === pubOdbAddress;
                })) {
                  _context3.next = 8;
                  break;
                }

                _context3.next = 8;
                return this._rootStore.add({
                  odbAddress: pubOdbAddress
                });

              case 8:
                if (entries.find(function (e) {
                  return e.payload.value.odbAddress === privOdbAddress;
                })) {
                  _context3.next = 11;
                  break;
                }

                _context3.next = 11;
                return this._rootStore.add({
                  odbAddress: privOdbAddress
                });

              case 11:
                this._publishRootStore(rootStoreAddress);

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function _createRootStore(_x4, _x5, _x6) {
        return _createRootStore2.apply(this, arguments);
      };
    }()
    /**
     * Get the public profile of a given address
     *
     * @param     {String}    address                 An ethereum address
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.addressServer      URL of the Address Server
     * @param     {Object}    opts.ipfs               A js-ipfs ipfs object
     * @param     {String}    opts.orbitPath          A custom path for orbitdb storage
     * @param     {Boolean}   opts.iframeStore        Use iframe for storage, allows shared store across domains. Default true when run in browser.
     * @param     {Boolean}   opts.useCacheService    Use 3Box API and Cache Service to fetch profile instead of OrbitDB. Default true.
     * @return    {Object}                            a json object with the profile for the given address
     */

  }, {
    key: "onSyncDone",

    /**
     * Sets the callback function that will be called once when the db is fully synced.
     *
     * @param     {Function}      syncDone        The function that will be called
     */
    value: function onSyncDone(syncDone) {
      this._onSyncDoneCB = syncDone;
    }
  }, {
    key: "_publishRootStore",
    value: function () {
      var _publishRootStore2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee4(rootStoreAddress) {
        var addressToken;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._muportDID.signJWT({
                  rootStoreAddress: rootStoreAddress
                });

              case 2:
                addressToken = _context4.sent;
                _context4.prev = 3;
                _context4.next = 6;
                return utils.fetchJson(this._serverUrl + '/odbAddress', {
                  address_token: addressToken
                });

              case 6:
                _context4.next = 11;
                break;

              case 8:
                _context4.prev = 8;
                _context4.t0 = _context4["catch"](3);
                throw new Error(_context4.t0);

              case 11:
                return _context4.abrupt("return", true);

              case 12:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[3, 8]]);
      }));

      return function _publishRootStore(_x7) {
        return _publishRootStore2.apply(this, arguments);
      };
    }()
  }, {
    key: "_linkProfile",
    value: function () {
      var _linkProfile2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee5() {
        var address, did, linkData, consent;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                address = this._muportDID.getDidDocument().managementKey;

                if (localstorage.get('linkConsent_' + address)) {
                  _context5.next = 22;
                  break;
                }

                did = this._muportDID.getDid();
                _context5.next = 5;
                return this.public.get('ethereum_proof');

              case 5:
                linkData = _context5.sent;

                if (linkData) {
                  _context5.next = 13;
                  break;
                }

                _context5.next = 9;
                return utils.getLinkConsent(address, did, this._web3provider);

              case 9:
                consent = _context5.sent;
                linkData = {
                  consent_msg: consent.msg,
                  consent_signature: consent.sig,
                  linked_did: did
                };
                _context5.next = 13;
                return this.public.set('ethereum_proof', linkData);

              case 13:
                _context5.prev = 13;
                _context5.next = 16;
                return utils.fetchJson(this._serverUrl + '/link', linkData);

              case 16:
                localstorage.set('linkConsent_' + address, true);
                _context5.next = 22;
                break;

              case 19:
                _context5.prev = 19;
                _context5.t0 = _context5["catch"](13);
                console.error(_context5.t0);

              case 22:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[13, 19]]);
      }));

      return function _linkProfile() {
        return _linkProfile2.apply(this, arguments);
      };
    }()
  }, {
    key: "_ensureDIDPublished",
    value: function () {
      var _ensureDIDPublished2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee6() {
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.public.get('proof_did');

              case 2:
                if (_context6.sent) {
                  _context6.next = 9;
                  break;
                }

                _context6.t0 = this.public;
                _context6.next = 6;
                return this._muportDID.signJWT();

              case 6:
                _context6.t1 = _context6.sent;
                _context6.next = 9;
                return _context6.t0.set.call(_context6.t0, 'proof_did', _context6.t1);

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      return function _ensureDIDPublished() {
        return _ensureDIDPublished2.apply(this, arguments);
      };
    }()
  }, {
    key: "_ensurePinningNodeConnected",
    value: function () {
      var _ensurePinningNodeConnected2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee7(odbAddress) {
        var _this2 = this;

        var roomPeers, rootStoreAddress;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._ipfs.pubsub.peers(odbAddress);

              case 2:
                roomPeers = _context7.sent;

                if (!roomPeers.find(function (p) {
                  return p === _this2.pinningNode.split('/').pop();
                })) {
                  this._ipfs.swarm.connect(this.pinningNode, function () {});

                  rootStoreAddress = this._rootStore.address.toString();

                  this._pubsub.publish(PINNING_ROOM, {
                    type: 'PIN_DB',
                    odbAddress: rootStoreAddress
                  });
                }

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      return function _ensurePinningNodeConnected(_x8) {
        return _ensurePinningNodeConnected2.apply(this, arguments);
      };
    }()
    /**
     * Closes the 3box instance without clearing the local cache.
     * Should be called after you are done using the 3Box instance,
     * but without logging the user out.
     */

  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee8() {
        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this._orbitdb.stop();

              case 2:
                _context8.next = 4;
                return this._pubsub.disconnect();

              case 4:
                // await this._ipfs.stop()
                globalOrbitDB = null;
                globalIPFS = null;

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      return function close() {
        return _close.apply(this, arguments);
      };
    }()
    /**
     * Closes the 3box instance and clears local cache. If you call this,
     * users will need to sign a consent message to log in the next time
     * you call openBox.
     */

  }, {
    key: "logout",
    value: function () {
      var _logout = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee9() {
        var address;
        return _regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.close();

              case 2:
                address = this._muportDID.getDidDocument().managementKey;
                localstorage.remove('serializedMuDID_' + address);
                localstorage.remove('linkConsent_' + address);

              case 5:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      return function logout() {
        return _logout.apply(this, arguments);
      };
    }()
    /**
     * Check if the given address is logged in
     *
     * @param     {String}    address                 An ethereum address
     * @return    {Boolean}                           true if the user is logged in
     */

  }], [{
    key: "getProfile",
    value: function () {
      var _getProfile = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee10(address) {
        var opts,
            normalizedAddress,
            profile,
            profileServerUrl,
            _args10 = arguments;
        return _regenerator.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                opts = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};
                normalizedAddress = address.toLowerCase();
                opts = Object.assign({
                  useCacheService: true
                }, opts);

                if (!opts.useCacheService) {
                  _context10.next = 10;
                  break;
                }

                profileServerUrl = opts.profileServer || PROFILE_SERVER_URL;
                _context10.next = 7;
                return getProfileAPI(normalizedAddress, profileServerUrl);

              case 7:
                profile = _context10.sent;
                _context10.next = 13;
                break;

              case 10:
                _context10.next = 12;
                return this._getProfileOrbit(normalizedAddress, opts);

              case 12:
                profile = _context10.sent;

              case 13:
                return _context10.abrupt("return", profile);

              case 14:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      return function getProfile(_x9) {
        return _getProfile.apply(this, arguments);
      };
    }()
    /**
     * Get a list of public profiles for given addresses. This relies on 3Box profile API.
     *
     * @param     {Array}     address                 An array of ethereum addresses
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with each key an address and value the profile
     */

  }, {
    key: "getProfiles",
    value: function () {
      var _getProfiles = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee11(addressArray) {
        var opts,
            profileServerUrl,
            req,
            _args11 = arguments;
        return _regenerator.default.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                opts = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : {};
                profileServerUrl = opts.profileServer || PROFILE_SERVER_URL;
                req = {
                  addressList: addressArray
                };
                return _context11.abrupt("return", utils.fetchJson(profileServerUrl + '/profileList', req));

              case 4:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      return function getProfiles(_x10) {
        return _getProfiles.apply(this, arguments);
      };
    }()
  }, {
    key: "_getProfileOrbit",
    value: function () {
      var _getProfileOrbit2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee13(address) {
        var opts,
            serverUrl,
            rootStoreAddress,
            usingGlobalIPFS,
            usingGlobalOrbitDB,
            ipfs,
            orbitdb,
            cache,
            pinningNode,
            publicStore,
            rootStore,
            readyPromise,
            profileEntry,
            profile,
            closeAll,
            _args13 = arguments;
        return _regenerator.default.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                opts = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : {};
                // opts = Object.assign({ iframeStore: true }, opts)
                serverUrl = opts.addressServer || ADDRESS_SERVER_URL;
                _context13.next = 4;
                return getRootStoreAddress(serverUrl, address.toLowerCase());

              case 4:
                rootStoreAddress = _context13.sent;
                usingGlobalIPFS = false;
                usingGlobalOrbitDB = false;

                if (!globalIPFS) {
                  _context13.next = 12;
                  break;
                }

                ipfs = globalIPFS;
                usingGlobalIPFS = true;
                _context13.next = 15;
                break;

              case 12:
                _context13.next = 14;
                return initIPFS(opts.ipfs, opts.iframeStore, opts.ipfsOptions);

              case 14:
                ipfs = _context13.sent;

              case 15:
                if (globalOrbitDB) {
                  orbitdb = globalOrbitDB;
                  usingGlobalIPFS = true;
                } else {
                  cache = null; // (opts.iframeStore && !!cacheProxy) ? cacheProxy : null

                  orbitdb = new OrbitDB(ipfs, opts.orbitPath, {
                    cache: cache
                  });
                }

                pinningNode = opts.pinningNode || PINNING_NODE;
                ipfs.swarm.connect(pinningNode, function () {});
                publicStore = new PublicStore(orbitdb);

                if (!rootStoreAddress) {
                  _context13.next = 41;
                  break;
                }

                _context13.next = 22;
                return orbitdb.open(rootStoreAddress);

              case 22:
                rootStore = _context13.sent;
                readyPromise = new Promise(function (resolve, reject) {
                  rootStore.events.on('ready', resolve);
                });
                rootStore.load();
                _context13.next = 27;
                return readyPromise;

              case 27:
                if (rootStore.iterator({
                  limit: -1
                }).collect().length) {
                  _context13.next = 30;
                  break;
                }

                _context13.next = 30;
                return new Promise(function (resolve, reject) {
                  rootStore.events.on('replicate.progress', function (_x, _y, _z, num, max) {
                    if (num === max) {
                      rootStore.events.on('replicated', resolve);
                    }
                  });
                });

              case 30:
                profileEntry = rootStore.iterator({
                  limit: -1
                }).collect().find(function (entry) {
                  return entry.payload.value.odbAddress.split('.')[1] === 'public';
                });
                _context13.next = 33;
                return publicStore._load(profileEntry.payload.value.odbAddress);

              case 33:
                _context13.next = 35;
                return publicStore._sync();

              case 35:
                profile = publicStore.all();

                closeAll =
                /*#__PURE__*/
                function () {
                  var _ref4 = (0, _asyncToGenerator2.default)(
                  /*#__PURE__*/
                  _regenerator.default.mark(function _callee12() {
                    return _regenerator.default.wrap(function _callee12$(_context12) {
                      while (1) {
                        switch (_context12.prev = _context12.next) {
                          case 0:
                            _context12.next = 2;
                            return rootStore.close();

                          case 2:
                            _context12.next = 4;
                            return publicStore.close();

                          case 4:
                            if (usingGlobalOrbitDB) {
                              _context12.next = 7;
                              break;
                            }

                            _context12.next = 7;
                            return orbitdb.stop();

                          case 7:
                            if (!usingGlobalIPFS) {} // await ipfs.stop()


                          case 8:
                          case "end":
                            return _context12.stop();
                        }
                      }
                    }, _callee12, this);
                  }));

                  return function closeAll() {
                    return _ref4.apply(this, arguments);
                  };
                }(); // close but don't wait for it


                closeAll();
                return _context13.abrupt("return", profile);

              case 41:
                return _context13.abrupt("return", null);

              case 42:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      return function _getProfileOrbit(_x11) {
        return _getProfileOrbit2.apply(this, arguments);
      };
    }()
    /**
     * GraphQL for 3Box profile API
     *
     * @param     {Object}    query               A graphQL query object.
     * @param     {Object}    opts                Optional parameters
     * @param     {String}    opts.graphqlServer  URL of graphQL 3Box profile service
     * @return    {Object}                        a json object with each key an address and value the profile
     */

  }, {
    key: "profileGraphQL",
    value: function () {
      var _profileGraphQL = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee14(query) {
        var opts,
            _args14 = arguments;
        return _regenerator.default.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                opts = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : {};
                return _context14.abrupt("return", graphQLRequest(opts.graphqlServer || GRAPHQL_SERVER_URL, query));

              case 2:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      return function profileGraphQL(_x12) {
        return _profileGraphQL.apply(this, arguments);
      };
    }()
    /**
     * Verifies the proofs of social accounts that is present in the profile.
     *
     * @param     {Object}            profile                 A user profile object
     * @return    {Object}                                    An object containing the accounts that have been verified
     */

  }, {
    key: "getVerifiedAccounts",
    value: function () {
      var _getVerifiedAccounts = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee15(profile) {
        var verifs, did;
        return _regenerator.default.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                verifs = {};
                _context15.prev = 1;
                _context15.next = 4;
                return verifier.verifyDID(profile.proof_did);

              case 4:
                did = _context15.sent;

                if (!profile.proof_github) {
                  _context15.next = 14;
                  break;
                }

                _context15.prev = 6;
                _context15.next = 9;
                return verifier.verifyGithub(did, profile.proof_github);

              case 9:
                verifs.github = _context15.sent;
                _context15.next = 14;
                break;

              case 12:
                _context15.prev = 12;
                _context15.t0 = _context15["catch"](6);

              case 14:
                if (!profile.proof_twitter) {
                  _context15.next = 23;
                  break;
                }

                _context15.prev = 15;
                _context15.next = 18;
                return verifier.verifyTwitter(did, profile.proof_twitter);

              case 18:
                verifs.twitter = _context15.sent;
                _context15.next = 23;
                break;

              case 21:
                _context15.prev = 21;
                _context15.t1 = _context15["catch"](15);

              case 23:
                _context15.next = 27;
                break;

              case 25:
                _context15.prev = 25;
                _context15.t2 = _context15["catch"](1);

              case 27:
                return _context15.abrupt("return", verifs);

              case 28:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this, [[1, 25], [6, 12], [15, 21]]);
      }));

      return function getVerifiedAccounts(_x13) {
        return _getVerifiedAccounts.apply(this, arguments);
      };
    }()
    /**
     * Opens the user space associated with the given address
     *
     * @param     {String}            address                 An ethereum address
     * @param     {ethereumProvider}  ethereumProvider        An ethereum provider
     * @param     {Object}            opts                    Optional parameters
     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box
     * @param     {String}            opts.pinningNode        A string with an ipfs multi-address to a 3box pinning node
     * @param     {Object}            opts.ipfs               A js-ipfs ipfs object
     * @param     {String}            opts.orbitPath          A custom path for orbitdb storage
     * @param     {String}            opts.addressServer      URL of the Address Server
     * @param     {Boolean}           opts.iframeStore        Use iframe for storage, allows shared store across domains. Default true when run in browser.
     * @return    {Box}                                       the 3Box instance for the given address
     */

  }, {
    key: "openBox",
    value: function () {
      var _openBox = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee16(address, ethereumProvider) {
        var opts,
            normalizedAddress,
            muportDID,
            serializedMuDID,
            sig,
            entropy,
            mnemonic,
            box,
            _args16 = arguments;
        return _regenerator.default.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                opts = _args16.length > 2 && _args16[2] !== undefined ? _args16[2] : {};
                // opts = Object.assign({ iframeStore: true }, opts)
                normalizedAddress = address.toLowerCase();
                serializedMuDID = localstorage.get('serializedMuDID_' + normalizedAddress);

                if (!serializedMuDID) {
                  _context16.next = 8;
                  break;
                }

                muportDID = new MuPort(serializedMuDID);
                if (opts.consentCallback) opts.consentCallback(false);
                _context16.next = 18;
                break;

              case 8:
                _context16.next = 10;
                return utils.openBoxConsent(normalizedAddress, ethereumProvider);

              case 10:
                sig = _context16.sent;
                if (opts.consentCallback) opts.consentCallback(true);
                entropy = '0x' + utils.sha256(sig.slice(2));
                mnemonic = HDNode.entropyToMnemonic(entropy);
                _context16.next = 16;
                return MuPort.newIdentity(null, null, {
                  externalMgmtKey: normalizedAddress,
                  mnemonic: mnemonic
                });

              case 16:
                muportDID = _context16.sent;
                localstorage.set('serializedMuDID_' + normalizedAddress, muportDID.serializeState());

              case 18:
                box = new Box(muportDID, ethereumProvider, opts);
                _context16.next = 21;
                return box._load(opts);

              case 21:
                return _context16.abrupt("return", box);

              case 22:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      return function openBox(_x14, _x15) {
        return _openBox.apply(this, arguments);
      };
    }()
  }, {
    key: "isLoggedIn",
    value: function isLoggedIn(address) {
      return Boolean(localstorage.get('serializedMuDID_' + address.toLowerCase()));
    }
  }]);
  return Box;
}();

function initIPFS(_x16, _x17, _x18) {
  return _initIPFS.apply(this, arguments);
}

function _initIPFS() {
  _initIPFS = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee17(ipfs, iframeStore, ipfsOptions) {
    return _regenerator.default.wrap(function _callee17$(_context17) {
      while (1) {
        switch (_context17.prev = _context17.next) {
          case 0:
            // if (!ipfs && !ipfsProxy) throw new Error('No IPFS object configured and no default available for environment')
            if (!!ipfs && iframeStore) console.log('Warning: iframeStore true, orbit db cache in iframe, but the given ipfs object is being used, and may not be running in same iframe.');

            if (!ipfs) {
              _context17.next = 5;
              break;
            }

            return _context17.abrupt("return", ipfs);

          case 5:
            return _context17.abrupt("return", new Promise(function (resolve, reject) {
              ipfs = new IPFS(ipfsOptions || IPFS_OPTIONS);
              ipfs.on('error', function (error) {
                console.error(error);
                reject(error);
              });
              ipfs.on('ready', function () {
                return resolve(ipfs);
              });
            }));

          case 6:
          case "end":
            return _context17.stop();
        }
      }
    }, _callee17, this);
  }));
  return _initIPFS.apply(this, arguments);
}

function getRootStoreAddress(_x19, _x20) {
  return _getRootStoreAddress.apply(this, arguments);
}

function _getRootStoreAddress() {
  _getRootStoreAddress = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee18(serverUrl, identifier) {
    var res;
    return _regenerator.default.wrap(function _callee18$(_context18) {
      while (1) {
        switch (_context18.prev = _context18.next) {
          case 0:
            _context18.next = 2;
            return utils.fetchJson(serverUrl + '/odbAddress/' + identifier);

          case 2:
            res = _context18.sent;

            if (!(res.status === 'success')) {
              _context18.next = 7;
              break;
            }

            return _context18.abrupt("return", res.data.rootStoreAddress);

          case 7:
            throw new Error(res.message);

          case 8:
          case "end":
            return _context18.stop();
        }
      }
    }, _callee18, this);
  }));
  return _getRootStoreAddress.apply(this, arguments);
}

function getProfileAPI(_x21, _x22) {
  return _getProfileAPI.apply(this, arguments);
}

function _getProfileAPI() {
  _getProfileAPI = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee20(rootStoreAddress, serverUrl) {
    return _regenerator.default.wrap(function _callee20$(_context20) {
      while (1) {
        switch (_context20.prev = _context20.next) {
          case 0:
            return _context20.abrupt("return", new Promise(
            /*#__PURE__*/
            function () {
              var _ref5 = (0, _asyncToGenerator2.default)(
              /*#__PURE__*/
              _regenerator.default.mark(function _callee19(resolve, reject) {
                var res;
                return _regenerator.default.wrap(function _callee19$(_context19) {
                  while (1) {
                    switch (_context19.prev = _context19.next) {
                      case 0:
                        _context19.prev = 0;
                        _context19.next = 3;
                        return utils.fetchJson(serverUrl + '/profile?address=' + encodeURIComponent(rootStoreAddress));

                      case 3:
                        res = _context19.sent;
                        resolve(res);
                        _context19.next = 10;
                        break;

                      case 7:
                        _context19.prev = 7;
                        _context19.t0 = _context19["catch"](0);
                        reject(_context19.t0);

                      case 10:
                      case "end":
                        return _context19.stop();
                    }
                  }
                }, _callee19, this, [[0, 7]]);
              }));

              return function (_x23, _x24) {
                return _ref5.apply(this, arguments);
              };
            }()));

          case 1:
          case "end":
            return _context20.stop();
        }
      }
    }, _callee20, this);
  }));
  return _getProfileAPI.apply(this, arguments);
}

module.exports = Box;