"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var localstorage = require('store');

var IPFS = require('ipfs');

var OrbitDB = require('orbit-db');

var Pubsub = require('orbit-db-pubsub'); // const OrbitDBCacheProxy = require('orbit-db-cache-postmsg-proxy').Client
// const { createProxyClient } = require('ipfs-postmsg-proxy')


var ThreeId = require('./3id');

var PublicStore = require('./publicStore');

var PrivateStore = require('./privateStore');

var Verified = require('./verified');

var Space = require('./space');

var utils = require('./utils/index');

var config = require('./config.js');

var API = require('./api');

var ADDRESS_SERVER_URL = config.address_server_url;
var PINNING_NODE = config.pinning_node;
var PINNING_ROOM = config.pinning_room; // const IFRAME_STORE_VERSION = '0.0.3'
// const IFRAME_STORE_URL = `https://iframe.3box.io/${IFRAME_STORE_VERSION}/iframe.html`

var IPFS_OPTIONS = config.ipfs_options;
var globalIPFS, globalOrbitDB; // , ipfsProxy, cacheProxy, iframeLoadedPromise

/*
if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  const iframe = document.createElement('iframe')
  iframe.src = IFRAME_STORE_URL
  iframe.style = 'width:0; height:0; border:0; border:none !important'

  iframeLoadedPromise = new Promise((resolve, reject) => {
    iframe.onload = () => { resolve() }
  })

  document.body.appendChild(iframe)
  // Create proxy clients that talks to the iframe
  const postMessage = iframe.contentWindow.postMessage.bind(iframe.contentWindow)
  ipfsProxy = createProxyClient({ postMessage })
  cacheProxy = OrbitDBCacheProxy({ postMessage })
} */

var Box =
/*#__PURE__*/
function () {
  /**
   * Please use the **openBox** method to instantiate a 3Box
   */
  function Box(threeId, ethereumProvider, ipfs) {
    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    (0, _classCallCheck2.default)(this, Box);
    this._3id = threeId;
    this._web3provider = ethereumProvider;
    this._ipfs = ipfs;
    this._serverUrl = opts.addressServer || ADDRESS_SERVER_URL;

    this._onSyncDoneCB = function () {};
    /**
     * @property {KeyValueStore} public         access the profile store of the users 3Box
     */


    this.public = null;
    /**
     * @property {KeyValueStore} private        access the private store of the users 3Box
     */

    this.private = null;
    /**
     * @property {Verified} verified        check and create verifications
     */

    this.verified = new Verified(this);
    /**
     * @property {Object} spaces            an object containing all open spaces indexed by their name.
     */

    this.spaces = {}; // local store of all pinning server pubsub messages seen related to spaces

    this.spacesPubSubMessages = {};
  }

  (0, _createClass2.default)(Box, [{
    key: "_load",
    value: function () {
      var _load2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3() {
        var _this = this;

        var opts,
            rootStoreName,
            key,
            rootStoreAddress,
            onNewPeer,
            _ref2,
            _ref3,
            pubStoreAddress,
            privStoreAddress,
            syncPromises,
            hasResponse,
            spaceMessageFilterActive,
            filterTimeSet,
            onMessageRes,
            _args3 = arguments;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                opts = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
                rootStoreName = this._3id.muportFingerprint + '.root';
                this.pinningNode = opts.pinningNode || PINNING_NODE;

                this._ipfs.swarm.connect(this.pinningNode, function () {}); // const cache = (opts.iframeStore && !!cacheProxy) ? cacheProxy : null


                this._orbitdb = new OrbitDB(this._ipfs, opts.orbitPath); // , { cache })

                globalOrbitDB = this._orbitdb;
                key = this._3id.getKeyringBySpaceName(rootStoreName).getDBKey();
                _context3.next = 9;
                return this._orbitdb.feed(rootStoreName, {
                  key: key,
                  write: [key.getPublic('hex')]
                });

              case 9:
                this._rootStore = _context3.sent;
                rootStoreAddress = this._rootStore.address.toString();
                _context3.t0 = Pubsub;
                _context3.t1 = this._ipfs;
                _context3.next = 15;
                return this._ipfs.id();

              case 15:
                _context3.t2 = _context3.sent.id;
                this._pubsub = new _context3.t0(_context3.t1, _context3.t2);

                onNewPeer =
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2.default)(
                  /*#__PURE__*/
                  _regenerator.default.mark(function _callee(topic, peer) {
                    return _regenerator.default.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            if (peer === _this.pinningNode.split('/').pop()) {
                              _this._pubsub.publish(PINNING_ROOM, {
                                type: 'PIN_DB',
                                odbAddress: rootStoreAddress
                              });
                            }

                          case 1:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee, this);
                  }));

                  return function onNewPeer(_x2, _x3) {
                    return _ref.apply(this, arguments);
                  };
                }();

                this.public = new PublicStore(this._orbitdb, this._3id.muportFingerprint + '.public', this._linkProfile.bind(this), this._ensurePinningNodeConnected.bind(this), this._3id);
                this.private = new PrivateStore(this._orbitdb, this._3id.muportFingerprint + '.private', this._ensurePinningNodeConnected.bind(this), this._3id);
                _context3.next = 22;
                return Promise.all([this.public._load(), this.private._load()]);

              case 22:
                _ref2 = _context3.sent;
                _ref3 = (0, _slicedToArray2.default)(_ref2, 2);
                pubStoreAddress = _ref3[0];
                privStoreAddress = _ref3[1];
                syncPromises = [];
                hasResponse = {}; // Filters and store space related messages for 3secs, the best effort
                // simple approach, until refactor

                spaceMessageFilterActive = true;
                filterTimeSet = false;

                onMessageRes =
                /*#__PURE__*/
                function () {
                  var _ref4 = (0, _asyncToGenerator2.default)(
                  /*#__PURE__*/
                  _regenerator.default.mark(function _callee2(topic, data) {
                    var promises;
                    return _regenerator.default.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!filterTimeSet) {
                              filterTimeSet = true;
                              setTimeout(function () {
                                spaceMessageFilterActive = false;
                              }, 3000);
                            }

                            if (!(data.type === 'HAS_ENTRIES')) {
                              _context2.next = 13;
                              break;
                            }

                            if (data.odbAddress === privStoreAddress && !hasResponse[privStoreAddress]) {
                              syncPromises.push(_this.private._sync(data.numEntries));
                              hasResponse[privStoreAddress] = true;
                            }

                            if (data.odbAddress === pubStoreAddress && !hasResponse[pubStoreAddress]) {
                              syncPromises.push(_this.public._sync(data.numEntries));
                              hasResponse[pubStoreAddress] = true;
                            }

                            if (spaceMessageFilterActive && data.odbAddress.includes('space') === true) {
                              _this.spacesPubSubMessages[data.odbAddress] = data;
                            }

                            if (!(syncPromises.length === 2)) {
                              _context2.next = 13;
                              break;
                            }

                            promises = syncPromises;
                            syncPromises = [];
                            _context2.next = 10;
                            return Promise.all(promises);

                          case 10:
                            _context2.next = 12;
                            return _this._ensureDIDPublished();

                          case 12:
                            _this._onSyncDoneCB(); // this._pubsub.unsubscribe(PINNING_ROOM)


                          case 13:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this);
                  }));

                  return function onMessageRes(_x4, _x5) {
                    return _ref4.apply(this, arguments);
                  };
                }();

                this._pubsub.subscribe(PINNING_ROOM, onMessageRes, onNewPeer);

                this._createRootStore(rootStoreAddress, privStoreAddress, pubStoreAddress, this.pinningNode);

              case 33:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function _load() {
        return _load2.apply(this, arguments);
      };
    }()
  }, {
    key: "_createRootStore",
    value: function () {
      var _createRootStore2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee4(rootStoreAddress, privOdbAddress, pubOdbAddress) {
        var entries;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._rootStore.load();

              case 2:
                _context4.next = 4;
                return this._rootStore.iterator({
                  limit: -1
                }).collect();

              case 4:
                entries = _context4.sent;

                if (entries.find(function (e) {
                  return e.payload.value.odbAddress === pubOdbAddress;
                })) {
                  _context4.next = 8;
                  break;
                }

                _context4.next = 8;
                return this._rootStore.add({
                  odbAddress: pubOdbAddress
                });

              case 8:
                if (entries.find(function (e) {
                  return e.payload.value.odbAddress === privOdbAddress;
                })) {
                  _context4.next = 11;
                  break;
                }

                _context4.next = 11;
                return this._rootStore.add({
                  odbAddress: privOdbAddress
                });

              case 11:
                this._publishRootStore(rootStoreAddress);

              case 12:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function _createRootStore(_x6, _x7, _x8) {
        return _createRootStore2.apply(this, arguments);
      };
    }()
    /**
     * Get the public profile of a given address
     *
     * @param     {String}    address                 An ethereum address
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.addressServer      URL of the Address Server
     * @param     {Object}    opts.ipfs               A js-ipfs ipfs object
     * @param     {Boolean}   opts.useCacheService    Use 3Box API and Cache Service to fetch profile instead of OrbitDB. Default true.
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with the profile for the given address
     */

  }, {
    key: "openSpace",

    /**
     * Opens the space with the given name in the users 3Box
     *
     * @param     {String}            name                    The name of the space
     * @param     {Object}            opts                    Optional parameters
     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box
     * @param     {Function}          opts.onSyncDone         A function that will be called when the space has finished syncing with the pinning node
     * @return    {Space}                                     the Space instance for the given space name
     */
    value: function () {
      var _openSpace = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee5(name) {
        var opts,
            _args5 = arguments;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                opts = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};

                if (this.spaces[name]) {
                  _context5.next = 15;
                  break;
                }

                this.spaces[name] = new Space(name, this._3id, this._orbitdb, this._rootStore, this._ensurePinningNodeConnected.bind(this));
                _context5.prev = 3;
                opts = Object.assign({
                  numEntriesMessages: this.spacesPubSubMessages
                }, opts);
                _context5.next = 7;
                return this.spaces[name].open(opts);

              case 7:
                _context5.next = 13;
                break;

              case 9:
                _context5.prev = 9;
                _context5.t0 = _context5["catch"](3);
                console.log(_context5.t0);
                delete this.spaces[name];

              case 13:
                _context5.next = 16;
                break;

              case 15:
                if (opts.onSyncDone) {
                  // since the space is already open we can call onSyncDone directly
                  opts.onSyncDone();
                }

              case 16:
                return _context5.abrupt("return", this.spaces[name]);

              case 17:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[3, 9]]);
      }));

      return function openSpace(_x9) {
        return _openSpace.apply(this, arguments);
      };
    }()
    /**
     * Sets the callback function that will be called once when the db is fully synced.
     *
     * @param     {Function}      syncDone        The function that will be called
     */

  }, {
    key: "onSyncDone",
    value: function onSyncDone(syncDone) {
      this._onSyncDoneCB = syncDone;
    }
  }, {
    key: "_publishRootStore",
    value: function () {
      var _publishRootStore2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee6(rootStoreAddress) {
        var addressToken;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this._3id.signJWT({
                  rootStoreAddress: rootStoreAddress
                });

              case 2:
                addressToken = _context6.sent;
                _context6.prev = 3;
                _context6.next = 6;
                return utils.fetchJson(this._serverUrl + '/odbAddress', {
                  address_token: addressToken
                });

              case 6:
                _context6.next = 11;
                break;

              case 8:
                _context6.prev = 8;
                _context6.t0 = _context6["catch"](3);
                throw new Error(_context6.t0);

              case 11:
                return _context6.abrupt("return", true);

              case 12:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[3, 8]]);
      }));

      return function _publishRootStore(_x10) {
        return _publishRootStore2.apply(this, arguments);
      };
    }()
  }, {
    key: "_linkProfile",
    value: function () {
      var _linkProfile2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee7() {
        var address, did, linkData, consent;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                address = this._3id.managementAddress;

                if (localstorage.get('linkConsent_' + address)) {
                  _context7.next = 22;
                  break;
                }

                did = this._3id.getDid();
                _context7.next = 5;
                return this.public.get('ethereum_proof');

              case 5:
                linkData = _context7.sent;

                if (linkData) {
                  _context7.next = 13;
                  break;
                }

                _context7.next = 9;
                return utils.getLinkConsent(address, did, this._web3provider);

              case 9:
                consent = _context7.sent;
                linkData = {
                  consent_msg: consent.msg,
                  consent_signature: consent.sig,
                  linked_did: did
                };
                _context7.next = 13;
                return this.public.set('ethereum_proof', linkData);

              case 13:
                _context7.prev = 13;
                _context7.next = 16;
                return utils.fetchJson(this._serverUrl + '/link', linkData);

              case 16:
                localstorage.set('linkConsent_' + address, true);
                _context7.next = 22;
                break;

              case 19:
                _context7.prev = 19;
                _context7.t0 = _context7["catch"](13);
                console.error(_context7.t0);

              case 22:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[13, 19]]);
      }));

      return function _linkProfile() {
        return _linkProfile2.apply(this, arguments);
      };
    }()
  }, {
    key: "_ensureDIDPublished",
    value: function () {
      var _ensureDIDPublished2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee8() {
        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.public.get('proof_did');

              case 2:
                if (_context8.sent) {
                  _context8.next = 9;
                  break;
                }

                _context8.t0 = this.public;
                _context8.next = 6;
                return this._3id.signJWT();

              case 6:
                _context8.t1 = _context8.sent;
                _context8.next = 9;
                return _context8.t0.set.call(_context8.t0, 'proof_did', _context8.t1);

              case 9:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      return function _ensureDIDPublished() {
        return _ensureDIDPublished2.apply(this, arguments);
      };
    }()
  }, {
    key: "_ensurePinningNodeConnected",
    value: function () {
      var _ensurePinningNodeConnected2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee9(odbAddress) {
        var _this2 = this;

        var roomPeers, rootStoreAddress;
        return _regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this._ipfs.pubsub.peers(odbAddress);

              case 2:
                roomPeers = _context9.sent;

                if (!roomPeers.find(function (p) {
                  return p === _this2.pinningNode.split('/').pop();
                })) {
                  this._ipfs.swarm.connect(this.pinningNode, function () {});

                  rootStoreAddress = this._rootStore.address.toString();

                  this._pubsub.publish(PINNING_ROOM, {
                    type: 'PIN_DB',
                    odbAddress: rootStoreAddress
                  });
                }

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      return function _ensurePinningNodeConnected(_x11) {
        return _ensurePinningNodeConnected2.apply(this, arguments);
      };
    }()
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee10() {
        return _regenerator.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this._orbitdb.stop();

              case 2:
                _context10.next = 4;
                return this._pubsub.disconnect();

              case 4:
                globalOrbitDB = null;

              case 5:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      return function close() {
        return _close.apply(this, arguments);
      };
    }()
    /**
     * Closes the 3box instance and clears local cache. If you call this,
     * users will need to sign a consent message to log in the next time
     * you call openBox.
     */

  }, {
    key: "logout",
    value: function () {
      var _logout = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee11() {
        var address;
        return _regenerator.default.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.close();

              case 2:
                this._3id.logout();

                address = this._3id.managementAddress;
                localstorage.remove('linkConsent_' + address);

              case 5:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      return function logout() {
        return _logout.apply(this, arguments);
      };
    }()
    /**
     * Check if the given address is logged in
     *
     * @param     {String}    address                 An ethereum address
     * @return    {Boolean}                           true if the user is logged in
     */

  }], [{
    key: "getProfile",
    value: function () {
      var _getProfile = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee12(address) {
        var opts,
            normalizedAddress,
            profile,
            _args12 = arguments;
        return _regenerator.default.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                opts = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : {};
                normalizedAddress = address.toLowerCase();
                opts = Object.assign({
                  useCacheService: true
                }, opts);

                if (!opts.useCacheService) {
                  _context12.next = 9;
                  break;
                }

                _context12.next = 6;
                return API.getProfile(normalizedAddress, opts.profileServer);

              case 6:
                profile = _context12.sent;
                _context12.next = 12;
                break;

              case 9:
                _context12.next = 11;
                return this._getProfileOrbit(normalizedAddress, opts);

              case 11:
                profile = _context12.sent;

              case 12:
                return _context12.abrupt("return", profile);

              case 13:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      return function getProfile(_x12) {
        return _getProfile.apply(this, arguments);
      };
    }()
    /**
     * Get a list of public profiles for given addresses. This relies on 3Box profile API.
     *
     * @param     {Array}     address                 An array of ethereum addresses
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with each key an address and value the profile
     */

  }, {
    key: "getProfiles",
    value: function () {
      var _getProfiles = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee13(addressArray) {
        var opts,
            _args13 = arguments;
        return _regenerator.default.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                opts = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : {};
                return _context13.abrupt("return", API.getProfiles(addressArray, opts));

              case 2:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      return function getProfiles(_x13) {
        return _getProfiles.apply(this, arguments);
      };
    }()
  }, {
    key: "_getProfileOrbit",
    value: function () {
      var _getProfileOrbit2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee15(address) {
        var opts,
            rootStoreAddress,
            usingGlobalIPFS,
            usingGlobalOrbitDB,
            ipfs,
            orbitdb,
            cache,
            pinningNode,
            publicStore,
            rootStore,
            readyPromise,
            profileEntry,
            profile,
            closeAll,
            _args15 = arguments;
        return _regenerator.default.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                opts = _args15.length > 1 && _args15[1] !== undefined ? _args15[1] : {};
                // opts = Object.assign({ iframeStore: true }, opts)
                console.log(opts.addressServer);
                _context15.next = 4;
                return API.getRootStoreAddress(address.toLowerCase(), opts.addressServer);

              case 4:
                rootStoreAddress = _context15.sent;
                usingGlobalIPFS = false;
                usingGlobalOrbitDB = false;

                if (!globalIPFS) {
                  _context15.next = 12;
                  break;
                }

                ipfs = globalIPFS;
                usingGlobalIPFS = true;
                _context15.next = 15;
                break;

              case 12:
                _context15.next = 14;
                return initIPFS(opts.ipfs, opts.iframeStore, opts.ipfsOptions);

              case 14:
                ipfs = _context15.sent;

              case 15:
                if (globalOrbitDB) {
                  orbitdb = globalOrbitDB;
                  usingGlobalIPFS = true;
                } else {
                  cache = null; // (opts.iframeStore && !!cacheProxy) ? cacheProxy : null

                  orbitdb = new OrbitDB(ipfs, opts.orbitPath, {
                    cache: cache
                  });
                }

                pinningNode = opts.pinningNode || PINNING_NODE;
                ipfs.swarm.connect(pinningNode, function () {});
                publicStore = new PublicStore(orbitdb);

                if (!rootStoreAddress) {
                  _context15.next = 41;
                  break;
                }

                _context15.next = 22;
                return orbitdb.open(rootStoreAddress);

              case 22:
                rootStore = _context15.sent;
                readyPromise = new Promise(function (resolve, reject) {
                  rootStore.events.on('ready', resolve);
                });
                rootStore.load();
                _context15.next = 27;
                return readyPromise;

              case 27:
                if (rootStore.iterator({
                  limit: -1
                }).collect().length) {
                  _context15.next = 30;
                  break;
                }

                _context15.next = 30;
                return new Promise(function (resolve, reject) {
                  rootStore.events.on('replicate.progress', function (_x, _y, _z, num, max) {
                    if (num === max) {
                      rootStore.events.on('replicated', resolve);
                    }
                  });
                });

              case 30:
                profileEntry = rootStore.iterator({
                  limit: -1
                }).collect().find(function (entry) {
                  return entry.payload.value.odbAddress.split('.')[1] === 'public';
                });
                _context15.next = 33;
                return publicStore._load(profileEntry.payload.value.odbAddress);

              case 33:
                _context15.next = 35;
                return publicStore._sync();

              case 35:
                profile = publicStore.all();

                closeAll =
                /*#__PURE__*/
                function () {
                  var _ref5 = (0, _asyncToGenerator2.default)(
                  /*#__PURE__*/
                  _regenerator.default.mark(function _callee14() {
                    return _regenerator.default.wrap(function _callee14$(_context14) {
                      while (1) {
                        switch (_context14.prev = _context14.next) {
                          case 0:
                            _context14.next = 2;
                            return rootStore.close();

                          case 2:
                            _context14.next = 4;
                            return publicStore.close();

                          case 4:
                            if (usingGlobalOrbitDB) {
                              _context14.next = 7;
                              break;
                            }

                            _context14.next = 7;
                            return orbitdb.stop();

                          case 7:
                            if (!usingGlobalIPFS) {} // await ipfs.stop()


                          case 8:
                          case "end":
                            return _context14.stop();
                        }
                      }
                    }, _callee14, this);
                  }));

                  return function closeAll() {
                    return _ref5.apply(this, arguments);
                  };
                }(); // close but don't wait for it


                closeAll();
                return _context15.abrupt("return", profile);

              case 41:
                return _context15.abrupt("return", null);

              case 42:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      return function _getProfileOrbit(_x14) {
        return _getProfileOrbit2.apply(this, arguments);
      };
    }()
    /**
     * GraphQL for 3Box profile API
     *
     * @param     {Object}    query               A graphQL query object.
     * @param     {Object}    opts                Optional parameters
     * @param     {String}    opts.graphqlServer  URL of graphQL 3Box profile service
     * @return    {Object}                        a json object with each key an address and value the profile
     */

  }, {
    key: "profileGraphQL",
    value: function () {
      var _profileGraphQL = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee16(query) {
        var opts,
            _args16 = arguments;
        return _regenerator.default.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                opts = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : {};
                return _context16.abrupt("return", API.profileGraphQL(query, opts.graphqlServer));

              case 2:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      return function profileGraphQL(_x15) {
        return _profileGraphQL.apply(this, arguments);
      };
    }()
    /**
     * Verifies the proofs of social accounts that is present in the profile.
     *
     * @param     {Object}            profile                 A user profile object, received from the `getProfile` function
     * @return    {Object}                                    An object containing the accounts that have been verified
     */

  }, {
    key: "getVerifiedAccounts",
    value: function () {
      var _getVerifiedAccounts = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee17(profile) {
        return _regenerator.default.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                return _context17.abrupt("return", API.getVerifiedAccounts(profile));

              case 1:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      return function getVerifiedAccounts(_x16) {
        return _getVerifiedAccounts.apply(this, arguments);
      };
    }()
    /**
     * Opens the 3Box associated with the given address
     *
     * @param     {String}            address                 An ethereum address
     * @param     {ethereumProvider}  ethereumProvider        An ethereum provider
     * @param     {Object}            opts                    Optional parameters
     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box
     * @param     {String}            opts.pinningNode        A string with an ipfs multi-address to a 3box pinning node
     * @param     {Object}            opts.ipfs               A js-ipfs ipfs object
     * @param     {String}            opts.addressServer      URL of the Address Server
     * @return    {Box}                                       the 3Box instance for the given address
     */

  }, {
    key: "openBox",
    value: function () {
      var _openBox = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee18(address, ethereumProvider) {
        var opts,
            ipfs,
            _3id,
            box,
            _args18 = arguments;

        return _regenerator.default.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                opts = _args18.length > 2 && _args18[2] !== undefined ? _args18[2] : {};
                _context18.t0 = globalIPFS;

                if (_context18.t0) {
                  _context18.next = 6;
                  break;
                }

                _context18.next = 5;
                return initIPFS(opts.ipfs, opts.iframeStore, opts.ipfsOptions);

              case 5:
                _context18.t0 = _context18.sent;

              case 6:
                ipfs = _context18.t0;
                globalIPFS = ipfs;
                _context18.next = 10;
                return ThreeId.getIdFromEthAddress(address, ethereumProvider, ipfs, opts);

              case 10:
                _3id = _context18.sent;
                box = new Box(_3id, ethereumProvider, ipfs, opts);
                _context18.next = 14;
                return box._load(opts);

              case 14:
                return _context18.abrupt("return", box);

              case 15:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      return function openBox(_x17, _x18) {
        return _openBox.apply(this, arguments);
      };
    }()
  }, {
    key: "isLoggedIn",
    value: function isLoggedIn(address) {
      return ThreeId.isLoggedIn(address);
    }
  }]);
  return Box;
}();

function initIPFS(_x19, _x20, _x21) {
  return _initIPFS.apply(this, arguments);
}

function _initIPFS() {
  _initIPFS = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee19(ipfs, iframeStore, ipfsOptions) {
    return _regenerator.default.wrap(function _callee19$(_context19) {
      while (1) {
        switch (_context19.prev = _context19.next) {
          case 0:
            // if (!ipfs && !ipfsProxy) throw new Error('No IPFS object configured and no default available for environment')
            if (!!ipfs && iframeStore) console.log('Warning: iframeStore true, orbit db cache in iframe, but the given ipfs object is being used, and may not be running in same iframe.');

            if (!ipfs) {
              _context19.next = 5;
              break;
            }

            return _context19.abrupt("return", ipfs);

          case 5:
            return _context19.abrupt("return", new Promise(function (resolve, reject) {
              ipfs = new IPFS(ipfsOptions || IPFS_OPTIONS);
              ipfs.on('error', function (error) {
                console.error(error);
                reject(error);
              });
              ipfs.on('ready', function () {
                return resolve(ipfs);
              });
            }));

          case 6:
          case "end":
            return _context19.stop();
        }
      }
    }, _callee19, this);
  }));
  return _initIPFS.apply(this, arguments);
}

module.exports = Box;