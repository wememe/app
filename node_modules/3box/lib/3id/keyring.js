"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var HDNode = require('ethers').utils.HDNode;

var nacl = require('tweetnacl');

nacl.util = require('tweetnacl-util');

var SimpleSigner = require('did-jwt').SimpleSigner;

var BASE_PATH = "m/7696500'/0'/0'";
var MM_PATH = "m/44'/60'/0'/0";

var Keyring =
/*#__PURE__*/
function () {
  function Keyring() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, Keyring);
    this.mnemonic = opts.mnemonic;

    if (opts.entropy) {
      this.mnemonic = HDNode.entropyToMnemonic(opts.entropy);
    }

    if (!this.mnemonic) throw new Error('Mnemonic or entropy needs to be specified');
    var seedNode = HDNode.fromMnemonic(this.mnemonic);
    var baseNode = seedNode.derivePath(BASE_PATH);
    this.signingKey = baseNode.derivePath("0");
    var tmpEncKey = Buffer.from(baseNode.derivePath("2").privateKey.slice(2), 'hex');
    this.asymEncryptionKey = nacl.box.keyPair.fromSecretKey(new Uint8Array(tmpEncKey));
    this.symEncryptionKey = new Uint8Array(Buffer.from(baseNode.derivePath("3").privateKey.slice(2), 'hex'));
    this.ethereumKey = seedNode.derivePath(MM_PATH).derivePath("0");
  }

  (0, _createClass2.default)(Keyring, [{
    key: "asymEncrypt",
    value: function asymEncrypt(msg, toPublic, nonce) {
      nonce = nonce || randomNonce();
      toPublic = nacl.util.decodeBase64(toPublic);

      if (typeof msg === 'string') {
        msg = nacl.util.decodeUTF8(msg);
      }

      var ciphertext = nacl.box(msg, nonce, toPublic, this.asymEncryptionKey.secretKey);
      return {
        nonce: nacl.util.encodeBase64(nonce),
        ciphertext: nacl.util.encodeBase64(ciphertext)
      };
    }
  }, {
    key: "asymDecrypt",
    value: function asymDecrypt(ciphertext, fromPublic, nonce, toBuffer) {
      fromPublic = nacl.util.decodeBase64(fromPublic);
      ciphertext = nacl.util.decodeBase64(ciphertext);
      nonce = nacl.util.decodeBase64(nonce);
      var cleartext = nacl.box.open(ciphertext, nonce, fromPublic, this.asymEncryptionKey.secretKey);

      if (toBuffer) {
        return cleartext ? Buffer.from(cleartext) : null;
      }

      return cleartext ? nacl.util.encodeUTF8(cleartext) : null;
    }
  }, {
    key: "symEncrypt",
    value: function symEncrypt(msg, nonce) {
      return symEncryptBase(msg, this.symEncryptionKey, nonce);
    }
  }, {
    key: "symDecrypt",
    value: function symDecrypt(ciphertext, nonce, toBuffer) {
      return symDecryptBase(ciphertext, this.symEncryptionKey, nonce, toBuffer);
    }
  }, {
    key: "getJWTSigner",
    value: function getJWTSigner() {
      return SimpleSigner(this.signingKey.privateKey.slice(2));
    }
  }, {
    key: "getPublicKeys",
    value: function getPublicKeys() {
      return {
        signingKey: this.signingKey.publicKey.slice(2),
        ethereumKey: this.ethereumKey.publicKey.slice(2),
        asymEncryptionKey: nacl.util.encodeBase64(this.asymEncryptionKey.publicKey)
      };
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return JSON.stringify({
        mnemonic: this.mnemonic
      });
    }
  }]);
  return Keyring;
}();

var randomNonce = function randomNonce() {
  return nacl.randomBytes(24);
};

var symEncryptBase = function symEncryptBase(msg, symKey, nonce) {
  nonce = nonce || randomNonce();

  if (typeof msg === 'string') {
    msg = nacl.util.decodeUTF8(msg);
  }

  var ciphertext = nacl.secretbox(msg, nonce, symKey);
  return {
    nonce: nacl.util.encodeBase64(nonce),
    ciphertext: nacl.util.encodeBase64(ciphertext)
  };
};

var symDecryptBase = function symDecryptBase(ciphertext, symKey, nonce, toBuffer) {
  ciphertext = nacl.util.decodeBase64(ciphertext);
  nonce = nacl.util.decodeBase64(nonce);
  var cleartext = nacl.secretbox.open(ciphertext, nonce, symKey);

  if (toBuffer) {
    return cleartext ? Buffer.from(cleartext) : null;
  }

  return cleartext ? nacl.util.encodeUTF8(cleartext) : null;
};

module.exports = Keyring;