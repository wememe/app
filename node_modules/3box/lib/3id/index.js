"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var HDNode = require('ethers').utils.HDNode;

var didJWT = require('did-jwt');

var IpfsMini = require('ipfs-mini');

var localstorage = require('store');

var utils = require('../utils/index');

var Keyring = require('./keyring');

var config = require('../config.js');

var STORAGE_KEY = 'serialized3id_';
var MUPORT_IPFS = {
  host: config.muport_ipfs_host,
  port: config.muport_ipfs_port,
  protocol: config.muport_ipfs_protocol
};

var ThreeId =
/*#__PURE__*/
function () {
  function ThreeId(serializeState, ethereum, ipfs, opts) {
    (0, _classCallCheck2.default)(this, ThreeId);
    this._ethereum = ethereum;
    this._ipfs = ipfs;
    this._keyrings = {};

    this._init3id(serializeState, opts);

    localstorage.set(STORAGE_KEY + this.managementAddress, this.serializeState());
  }

  (0, _createClass2.default)(ThreeId, [{
    key: "signJWT",
    value: function () {
      var _signJWT = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(payload) {
        var settings;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                settings = {
                  signer: this._mainKeyring.getJWTSigner(),
                  issuer: this.getDid()
                };
                return _context.abrupt("return", didJWT.createJWT(payload, settings));

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function signJWT(_x) {
        return _signJWT.apply(this, arguments);
      };
    }()
  }, {
    key: "getDid",
    value: function getDid() {
      return this._muportDID;
    }
  }, {
    key: "serializeState",
    value: function serializeState() {
      var _this = this;

      var stateObj = {
        managementAddress: this.managementAddress,
        seed: this._mainKeyring.serialize(),
        spaceSeeds: {}
      };
      Object.keys(this._keyrings).map(function (name) {
        stateObj.spaceSeeds[name] = _this._keyrings[name].serialize();
      });
      return JSON.stringify(stateObj);
    }
  }, {
    key: "_init3id",
    value: function _init3id(serializeState) {
      var _this2 = this;

      var state = JSON.parse(serializeState);
      this.managementAddress = state.managementAddress;
      this._mainKeyring = new Keyring(state.seed);
      Object.keys(state.spaceSeeds).map(function (name) {
        _this2._keyrings[name] = new Keyring(state.spaceSeeds[name]);
      });
    }
  }, {
    key: "_initMuport",
    value: function () {
      var _initMuport2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3(muportIpfs) {
        var keys, doc, docHash, publishToInfura;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                keys = this._mainKeyring.getPublicKeys();
                doc = createMuportDocument(keys.signingKey, this.managementAddress, keys.asymEncryptionKey);
                _context3.next = 4;
                return this._ipfs.files.add(Buffer.from(JSON.stringify(doc)));

              case 4:
                docHash = _context3.sent[0].hash;
                this._muportDID = 'did:muport:' + docHash;
                this.muportFingerprint = utils.sha256Multihash(this._muportDID);

                publishToInfura =
                /*#__PURE__*/
                function () {
                  var _ref = (0, _asyncToGenerator2.default)(
                  /*#__PURE__*/
                  _regenerator.default.mark(function _callee2() {
                    var ipfsMini;
                    return _regenerator.default.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            ipfsMini = new IpfsMini(muportIpfs);
                            ipfsMini.addJSON(doc, function (err, res) {
                              if (err) console.error(err);
                            });

                          case 2:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this);
                  }));

                  return function publishToInfura() {
                    return _ref.apply(this, arguments);
                  };
                }();

                publishToInfura();

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function _initMuport(_x2) {
        return _initMuport2.apply(this, arguments);
      };
    }()
  }, {
    key: "getKeyringBySpaceName",
    value: function getKeyringBySpaceName(name) {
      var split = name.split('.');

      if (split[0] === this.muportFingerprint) {
        return this._mainKeyring;
      } else {
        return this._keyrings[split[2]];
      }
    }
  }, {
    key: "initKeyringByName",
    value: function () {
      var _initKeyringByName = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee4(name) {
        var sig, entropy, seed;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (this._keyrings[name]) {
                  _context4.next = 11;
                  break;
                }

                _context4.next = 3;
                return utils.openSpaceConsent(this.managementAddress, this._ethereum, name);

              case 3:
                sig = _context4.sent;
                entropy = '0x' + utils.sha256(sig.slice(2));
                seed = HDNode.mnemonicToSeed(HDNode.entropyToMnemonic(entropy));
                this._keyrings[name] = new Keyring(seed);
                localstorage.set(STORAGE_KEY + this.managementAddress, this.serializeState());
                return _context4.abrupt("return", true);

              case 11:
                return _context4.abrupt("return", false);

              case 12:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function initKeyringByName(_x3) {
        return _initKeyringByName.apply(this, arguments);
      };
    }()
  }, {
    key: "logout",
    value: function logout() {
      localstorage.remove(STORAGE_KEY + this.managementAddress);
    }
  }], [{
    key: "isLoggedIn",
    value: function isLoggedIn(address) {
      return Boolean(localstorage.get(STORAGE_KEY + address.toLowerCase()));
    }
  }, {
    key: "getIdFromEthAddress",
    value: function () {
      var _getIdFromEthAddress = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee5(address, ethereum, ipfs) {
        var opts,
            normalizedAddress,
            serialized3id,
            sig,
            entropy,
            mnemonic,
            seed,
            _3id,
            _args5 = arguments;

        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                opts = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : {};
                normalizedAddress = address.toLowerCase();
                serialized3id = localstorage.get(STORAGE_KEY + normalizedAddress);

                if (!serialized3id) {
                  _context5.next = 7;
                  break;
                }

                if (opts.consentCallback) opts.consentCallback(false);
                _context5.next = 15;
                break;

              case 7:
                _context5.next = 9;
                return utils.openBoxConsent(normalizedAddress, ethereum);

              case 9:
                sig = _context5.sent;
                if (opts.consentCallback) opts.consentCallback(true);
                entropy = '0x' + utils.sha256(sig.slice(2));
                mnemonic = HDNode.entropyToMnemonic(entropy);
                seed = HDNode.mnemonicToSeed(mnemonic);
                serialized3id = JSON.stringify({
                  managementAddress: address,
                  seed: seed,
                  spaceSeeds: {}
                });

              case 15:
                _3id = new ThreeId(serialized3id, ethereum, ipfs, opts);
                _context5.next = 18;
                return _3id._initMuport(opts.muportIpfs || MUPORT_IPFS);

              case 18:
                return _context5.abrupt("return", _3id);

              case 19:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function getIdFromEthAddress(_x4, _x5, _x6) {
        return _getIdFromEthAddress.apply(this, arguments);
      };
    }()
  }]);
  return ThreeId;
}();

var createMuportDocument = function createMuportDocument(signingKey, managementKey, asymEncryptionKey) {
  return {
    version: 1,
    signingKey: signingKey,
    managementKey: managementKey,
    asymEncryptionKey: asymEncryptionKey
  };
};

module.exports = ThreeId;