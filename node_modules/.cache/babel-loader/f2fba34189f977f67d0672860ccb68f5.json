{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar PeerId = require('peer-id');\n\nvar Record = require('libp2p-record').Record;\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar series = require('async/series');\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('jsipfs:ipns:publisher');\nlog.error = debug('jsipfs:ipns:publisher:error');\n\nvar ipns = require('ipns');\n\nvar defaultRecordTtl = 60 * 60 * 1000; // IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\n\nvar IpnsPublisher =\n/*#__PURE__*/\nfunction () {\n  function IpnsPublisher(routing, repo) {\n    _classCallCheck(this, IpnsPublisher);\n\n    this._routing = routing;\n    this._repo = repo;\n  } // publish record with a eol\n\n\n  _createClass(IpnsPublisher, [{\n    key: \"publishWithEOL\",\n    value: function publishWithEOL(privKey, value, lifetime, callback) {\n      var _this = this;\n\n      if (!privKey || !privKey.bytes) {\n        var errMsg = \"one or more of the provided parameters are not defined\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER'));\n      }\n\n      PeerId.createFromPrivKey(privKey.bytes, function (err, peerId) {\n        if (err) {\n          callback(err);\n        }\n\n        _this._updateOrCreateRecord(privKey, value, lifetime, peerId, function (err, record) {\n          if (err) {\n            return callback(err);\n          }\n\n          _this._putRecordToRouting(record, peerId, callback);\n        });\n      });\n    } // Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n\n  }, {\n    key: \"publish\",\n    value: function publish(privKey, value, callback) {\n      this.publishWithEOL(privKey, value, defaultRecordTtl, callback);\n    }\n  }, {\n    key: \"_putRecordToRouting\",\n    value: function _putRecordToRouting(record, peerId, callback) {\n      var _this2 = this;\n\n      if (!PeerId.isPeerId(peerId)) {\n        var errMsg = \"peerId received is not valid\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'));\n      }\n\n      var publicKey = peerId._pubKey;\n      ipns.embedPublicKey(publicKey, record, function (err, embedPublicKeyRecord) {\n        if (err) {\n          return callback(err);\n        }\n\n        var keys;\n\n        try {\n          keys = ipns.getIdKeys(peerId.id);\n        } catch (err) {\n          log.error(err);\n          return callback(err);\n        }\n\n        series([function (cb) {\n          return _this2._publishEntry(keys.ipnsKey, embedPublicKeyRecord || record, peerId, cb);\n        }, // Publish the public key if a public key cannot be extracted from the ID\n        // We will be able to deprecate this part in the future, since the public keys will be only in the peerId\n        function (cb) {\n          return embedPublicKeyRecord ? _this2._publishPublicKey(keys.pkKey, publicKey, peerId, cb) : cb();\n        }], function (err) {\n          if (err) {\n            log.error(err);\n            return callback(err);\n          }\n\n          callback(null, embedPublicKeyRecord || record);\n        });\n      });\n    }\n  }, {\n    key: \"_publishEntry\",\n    value: function _publishEntry(key, entry, peerId, callback) {\n      if (!Key.isKey(key)) {\n        var errMsg = \"datastore key does not have a valid format\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'));\n      }\n\n      var rec;\n\n      try {\n        // Marshal record\n        var entryData = ipns.marshal(entry); // Marshal to libp2p record\n\n        rec = new Record(key.toBuffer(), entryData);\n      } catch (err) {\n        log.error(err);\n        return callback(err);\n      } // TODO Routing - this should be replaced by a put to the DHT\n\n\n      this._repo.datastore.put(key, rec.serialize(), function (err, res) {\n        if (err) {\n          var _errMsg = \"ipns record for \".concat(key.toString(), \" could not be stored in the routing\");\n\n          log.error(_errMsg);\n          return callback(errcode(new Error(_errMsg), 'ERR_STORING_IN_DATASTORE'));\n        }\n\n        log(\"ipns record for \".concat(key.toString(), \" was stored in the routing\"));\n        callback(null, res);\n      });\n    }\n  }, {\n    key: \"_publishPublicKey\",\n    value: function _publishPublicKey(key, publicKey, peerId, callback) {\n      if (!Key.isKey(key)) {\n        var errMsg = \"datastore key does not have a valid format\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY'));\n      }\n\n      if (!publicKey || !publicKey.bytes) {\n        var _errMsg2 = \"one or more of the provided parameters are not defined\";\n        log.error(_errMsg2);\n        return callback(errcode(new Error(_errMsg2), 'ERR_UNDEFINED_PARAMETER'));\n      }\n\n      var rec;\n\n      try {\n        // Marshal to libp2p record\n        rec = new Record(key.toBuffer(), publicKey.bytes);\n      } catch (err) {\n        log.error(err);\n        return callback(err);\n      } // TODO Routing - this should be replaced by a put to the DHT\n\n\n      this._repo.datastore.put(key, rec.serialize(), function (err, res) {\n        if (err) {\n          var _errMsg3 = \"public key for \".concat(key.toString(), \" could not be stored in the routing\");\n\n          log.error(_errMsg3);\n          return callback(errcode(new Error(_errMsg3), 'ERR_STORING_IN_DATASTORE'));\n        }\n\n        log(\"public key for \".concat(key.toString(), \" was stored in the routing\"));\n        callback(null, res);\n      });\n    } // Returns the record this node has published corresponding to the given peer ID.\n    // If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n\n  }, {\n    key: \"_getPublished\",\n    value: function _getPublished(peerId, options, callback) {\n      if (!PeerId.isPeerId(peerId)) {\n        var errMsg = \"peerId received is not valid\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'));\n      }\n\n      options = options || {};\n      var checkRouting = !(options.checkRouting === false);\n\n      this._repo.datastore.get(ipns.getLocalKey(peerId.id), function (err, dsVal) {\n        var result;\n\n        if (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            var _errMsg4 = \"unexpected error getting the ipns record \".concat(peerId.id, \" from datastore\");\n\n            log.error(_errMsg4);\n            return callback(errcode(new Error(_errMsg4), 'ERR_UNEXPECTED_DATASTORE_RESPONSE'));\n          } else {\n            if (!checkRouting) {\n              return callback(null, null);\n            } else {\n              // TODO ROUTING - get from DHT\n              return callback(new Error('not implemented yet'));\n            }\n          }\n        }\n\n        if (Buffer.isBuffer(dsVal)) {\n          result = dsVal;\n        } else {\n          var _errMsg5 = \"found ipns record that we couldn't convert to a value\";\n          log.error(_errMsg5);\n          return callback(errcode(new Error(_errMsg5), 'ERR_INVALID_IPNS_RECORD'));\n        } // unmarshal data\n\n\n        try {\n          result = ipns.unmarshal(dsVal);\n        } catch (err) {\n          var _errMsg6 = \"found ipns record that we couldn't convert to a value\";\n          log.error(_errMsg6);\n          return callback(null, null);\n        }\n\n        callback(null, result);\n      });\n    }\n  }, {\n    key: \"_updateOrCreateRecord\",\n    value: function _updateOrCreateRecord(privKey, value, validity, peerId, callback) {\n      var _this3 = this;\n\n      if (!PeerId.isPeerId(peerId)) {\n        var errMsg = \"peerId received is not valid\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID'));\n      }\n\n      var getPublishedOptions = {\n        checkRouting: false // TODO ROUTING - change to true\n\n      };\n\n      this._getPublished(peerId, getPublishedOptions, function (err, record) {\n        if (err) {\n          return callback(err);\n        } // Determinate the record sequence number\n\n\n        var seqNumber = 0;\n\n        if (record && record.sequence !== undefined) {\n          seqNumber = record.value.toString() !== value ? record.sequence + 1 : record.sequence;\n        } // Create record\n\n\n        ipns.create(privKey, value, seqNumber, validity, function (err, entryData) {\n          if (err) {\n            var _errMsg7 = \"ipns record for \".concat(value, \" could not be created\");\n\n            log.error(_errMsg7);\n            return callback(errcode(new Error(_errMsg7), 'ERR_CREATING_IPNS_RECORD'));\n          } // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n          // Marshal record\n\n\n          var data = ipns.marshal(entryData); // Store the new record\n\n          _this3._repo.datastore.put(ipns.getLocalKey(peerId.id), data, function (err, res) {\n            if (err) {\n              var _errMsg8 = \"ipns record for \".concat(value, \" could not be stored in the datastore\");\n\n              log.error(_errMsg8);\n              return callback(errcode(new Error(_errMsg8), 'ERR_STORING_IN_DATASTORE'));\n            }\n\n            log(\"ipns record for \".concat(value, \" was stored in the datastore\"));\n            callback(null, entryData);\n          });\n        });\n      });\n    }\n  }]);\n\n  return IpnsPublisher;\n}();\n\nexports = module.exports = IpnsPublisher;","map":null,"metadata":{},"sourceType":"script"}