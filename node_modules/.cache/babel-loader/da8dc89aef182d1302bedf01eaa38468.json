{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Readable = require('readable-stream');\n\nvar mapSeries = require('p-each-series');\n\nvar Log = require('ipfs-log');\n\nvar Index = require('./Index');\n\nvar Replicator = require('./Replicator');\n\nvar ReplicationInfo = require('./replication-info');\n\nvar Logger = require('logplease');\n\nvar logger = Logger.create(\"orbit-db.store\", {\n  color: Logger.Colors.Blue\n});\nLogger.setLogLevel('ERROR');\nvar DefaultOptions = {\n  Index: Index,\n  maxHistory: -1,\n  path: './orbitdb',\n  replicate: true,\n  referenceCount: 64,\n  replicationConcurrency: 128\n};\n\nvar Store =\n/*#__PURE__*/\nfunction () {\n  function Store(ipfs, peerId, address, options) {\n    var _this = this;\n\n    _classCallCheck(this, Store);\n\n    // Set the options\n    var opts = Object.assign({}, DefaultOptions);\n    Object.assign(opts, options);\n    this.options = opts; // Default type\n\n    this._type = 'store'; // Create IDs, names and paths\n\n    this.id = address.toString();\n    this.uid = peerId;\n    this.address = address;\n    this.dbname = address.path || '';\n    this.events = new EventEmitter(); // External dependencies\n\n    this._ipfs = ipfs;\n    this._cache = options.cache;\n    this._keystore = options.keystore;\n    this._key = options && options.key ? options.key : this._keystore.getKey(peerId) || this._keystore.createKey(peerId); // FIX: duck typed interface\n\n    this._ipfs.keystore = this._keystore; // Access mapping\n\n    var defaultAccess = {\n      admin: [this._key.getPublic('hex')],\n      read: [],\n      // Not used atm, anyone can read\n      write: [this._key.getPublic('hex')]\n    };\n    this.access = options.accessController || defaultAccess; // Create the operations log\n\n    this._oplog = new Log(this._ipfs, this.id, null, null, null, this._key, this.access.write); // Create the index\n\n    this._index = new this.options.Index(this.uid); // Replication progress info\n\n    this._replicationStatus = new ReplicationInfo(); // Statistics\n\n    this._stats = {\n      snapshot: {\n        bytesLoaded: -1\n      },\n      syncRequestsReceieved: 0\n    };\n\n    try {\n      this._replicator = new Replicator(this, this.options.replicationConcurrency); // For internal backwards compatibility,\n      // to be removed in future releases\n\n      this._loader = this._replicator;\n\n      this._replicator.on('load.added', function (entry) {\n        // Update the latest entry state (latest is the entry with largest clock time)\n        _this._replicationStatus.queued++;\n\n        _this._recalculateReplicationMax(entry.clock ? entry.clock.time : 0); // logger.debug(`<replicate>`)\n\n\n        _this.events.emit('replicate', _this.address.toString(), entry);\n      });\n\n      this._replicator.on('load.progress', function (id, hash, entry, have, bufferedLength) {\n        if (_this._replicationStatus.buffered > bufferedLength) {\n          _this._recalculateReplicationProgress(_this.replicationStatus.progress + bufferedLength);\n        } else {\n          _this._recalculateReplicationProgress(_this._oplog.length + bufferedLength);\n        }\n\n        _this._replicationStatus.buffered = bufferedLength;\n\n        _this._recalculateReplicationMax(_this.replicationStatus.progress); // logger.debug(`<replicate.progress>`)\n\n\n        _this.events.emit('replicate.progress', _this.address.toString(), hash, entry, _this.replicationStatus.progress, _this.replicationStatus.max);\n      });\n\n      var onLoadCompleted =\n      /*#__PURE__*/\n      function () {\n        var _ref = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee(logs, have) {\n          var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, log, heads;\n\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  _iteratorNormalCompletion = true;\n                  _didIteratorError = false;\n                  _iteratorError = undefined;\n                  _context.prev = 4;\n                  _iterator = logs[Symbol.iterator]();\n\n                case 6:\n                  if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                    _context.next = 13;\n                    break;\n                  }\n\n                  log = _step.value;\n                  _context.next = 10;\n                  return _this._oplog.join(log);\n\n                case 10:\n                  _iteratorNormalCompletion = true;\n                  _context.next = 6;\n                  break;\n\n                case 13:\n                  _context.next = 19;\n                  break;\n\n                case 15:\n                  _context.prev = 15;\n                  _context.t0 = _context[\"catch\"](4);\n                  _didIteratorError = true;\n                  _iteratorError = _context.t0;\n\n                case 19:\n                  _context.prev = 19;\n                  _context.prev = 20;\n\n                  if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                  }\n\n                case 22:\n                  _context.prev = 22;\n\n                  if (!_didIteratorError) {\n                    _context.next = 25;\n                    break;\n                  }\n\n                  throw _iteratorError;\n\n                case 25:\n                  return _context.finish(22);\n\n                case 26:\n                  return _context.finish(19);\n\n                case 27:\n                  _this._replicationStatus.queued -= logs.length;\n                  _this._replicationStatus.buffered = _this._replicator._buffer.length;\n                  _context.next = 31;\n                  return _this._updateIndex();\n\n                case 31:\n                  //only store heads that has been verified and merges\n                  heads = _this._oplog.heads;\n                  _context.next = 34;\n                  return _this._cache.set('_remoteHeads', heads);\n\n                case 34:\n                  logger.debug(\"Saved heads \".concat(heads.length, \" [\").concat(heads.map(function (e) {\n                    return e.hash;\n                  }).join(', '), \"]\")); // logger.debug(`<replicated>`)\n\n                  _this.events.emit('replicated', _this.address.toString(), logs.length);\n\n                  _context.next = 41;\n                  break;\n\n                case 38:\n                  _context.prev = 38;\n                  _context.t1 = _context[\"catch\"](0);\n                  console.error(_context.t1);\n\n                case 41:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this, [[0, 38], [4, 15, 19, 27], [20,, 22, 26]]);\n        }));\n\n        return function onLoadCompleted(_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      this._replicator.on('load.end', onLoadCompleted);\n    } catch (e) {\n      console.error(\"Store Error:\", e);\n    }\n  }\n\n  _createClass(Store, [{\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.options.onClose) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                _context2.next = 3;\n                return this.options.onClose(this.address.toString());\n\n              case 3:\n                //Replicator teardown logic\n                this._replicator.stop(); // Reset replication statistics\n\n\n                this._replicationStatus.reset(); // Reset database statistics\n\n\n                this._stats = {\n                  snapshot: {\n                    bytesLoaded: -1\n                  },\n                  syncRequestsReceieved: 0 // Remove all event listeners\n\n                };\n                this.events.removeAllListeners('load');\n                this.events.removeAllListeners('load.progress');\n                this.events.removeAllListeners('replicate');\n                this.events.removeAllListeners('replicate.progress');\n                this.events.removeAllListeners('replicated');\n                this.events.removeAllListeners('ready');\n                this.events.removeAllListeners('write'); // Close cache\n\n                _context2.next = 15;\n                return this._cache.close();\n\n              case 15:\n                // Database is now closed\n                // TODO: afaik we don't use 'closed' event anymore,\n                // to be removed in future releases\n                this.events.emit('closed', this.address.toString());\n                return _context2.abrupt(\"return\", Promise.resolve());\n\n              case 17:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n    /**\n     * Drops a database and removes local data\n     * @return {[None]}\n     */\n\n  }, {\n    key: \"drop\",\n    value: function () {\n      var _drop = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.close();\n\n              case 2:\n                _context3.next = 4;\n                return this._cache.destroy();\n\n              case 4:\n                // Reset\n                this._index = new this.options.Index(this.uid);\n                this._oplog = new Log(this._ipfs, this.id, null, null, null, this._key, this.access.write);\n                this._cache = this.options.cache;\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function drop() {\n        return _drop.apply(this, arguments);\n      }\n\n      return drop;\n    }()\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(amount) {\n        var _this2 = this;\n\n        var localHeads, remoteHeads, heads;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                amount = amount || this.options.maxHistory;\n                _context5.next = 3;\n                return this._cache.get('_localHeads');\n\n              case 3:\n                _context5.t0 = _context5.sent;\n\n                if (_context5.t0) {\n                  _context5.next = 6;\n                  break;\n                }\n\n                _context5.t0 = [];\n\n              case 6:\n                localHeads = _context5.t0;\n                _context5.next = 9;\n                return this._cache.get('_remoteHeads');\n\n              case 9:\n                _context5.t1 = _context5.sent;\n\n                if (_context5.t1) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                _context5.t1 = [];\n\n              case 12:\n                remoteHeads = _context5.t1;\n                heads = localHeads.concat(remoteHeads);\n                if (heads.length > 0) this.events.emit('load', this.address.toString(), heads);\n                _context5.next = 17;\n                return mapSeries(heads,\n                /*#__PURE__*/\n                function () {\n                  var _ref2 = _asyncToGenerator(\n                  /*#__PURE__*/\n                  _regeneratorRuntime.mark(function _callee4(head) {\n                    var log;\n                    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            _this2._recalculateReplicationMax(head.clock.time);\n\n                            _context4.next = 3;\n                            return Log.fromEntryHash(_this2._ipfs, head.hash, _this2._oplog.id, amount, _this2._oplog.values, _this2._key, _this2.access.write, _this2._onLoadProgress.bind(_this2));\n\n                          case 3:\n                            log = _context4.sent;\n                            _context4.next = 6;\n                            return _this2._oplog.join(log, amount);\n\n                          case 6:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4, this);\n                  }));\n\n                  return function (_x4) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }());\n\n              case 17:\n                if (!(heads.length > 0)) {\n                  _context5.next = 20;\n                  break;\n                }\n\n                _context5.next = 20;\n                return this._updateIndex();\n\n              case 20:\n                this.events.emit('ready', this.address.toString(), this._oplog.heads);\n\n              case 21:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function load(_x3) {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n  }, {\n    key: \"sync\",\n    value: function sync(heads) {\n      var _this3 = this;\n\n      this._stats.syncRequestsReceieved += 1;\n      logger.debug(\"Sync request #\".concat(this._stats.syncRequestsReceieved, \" \").concat(heads.length));\n      if (heads.length === 0) return; // To simulate network latency, uncomment this line\n      // and comment out the rest of the function\n      // That way the object (received as head message from pubsub)\n      // doesn't get written to IPFS and so when the Replicator is fetching\n      // the log, it'll fetch it from the network instead from the disk.\n      // return this._replicator.load(heads)\n\n      var saveToIpfs = function saveToIpfs(head) {\n        if (!head) {\n          console.warn(\"Warning: Given input entry was 'null'.\");\n          return Promise.resolve(null);\n        }\n\n        if (!_this3.access.write.includes(head.key) && !_this3.access.write.includes('*')) {\n          console.warn(\"Warning: Given input entry is not allowed in this log and was discarded (no write access).\");\n          return Promise.resolve(null);\n        } // TODO: verify the entry's signature here\n\n\n        var logEntry = Object.assign({}, head);\n        logEntry.hash = null;\n        return _this3._ipfs.object.put(Buffer.from(JSON.stringify(logEntry))).then(function (dagObj) {\n          return dagObj.toJSON().multihash;\n        }).then(function (hash) {\n          // We need to make sure that the head message's hash actually\n          // matches the hash given by IPFS in order to verify that the\n          // message contents are authentic\n          if (hash !== head.hash) {\n            console.warn('\"WARNING! Head hash didn\\'t match the contents');\n          }\n\n          return hash;\n        }).then(function () {\n          return head;\n        });\n      };\n\n      return mapSeries(heads, saveToIpfs).then(\n      /*#__PURE__*/\n      function () {\n        var _ref3 = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee6(saved) {\n          return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  return _context6.abrupt(\"return\", _this3._replicator.load(saved.filter(function (e) {\n                    return e !== null;\n                  })));\n\n                case 1:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6, this);\n        }));\n\n        return function (_x5) {\n          return _ref3.apply(this, arguments);\n        };\n      }());\n    }\n  }, {\n    key: \"loadMoreFrom\",\n    value: function loadMoreFrom(amount, entries) {\n      this._replicator.load(entries);\n    }\n  }, {\n    key: \"saveSnapshot\",\n    value: function () {\n      var _saveSnapshot = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7() {\n        var unfinished, snapshotData, header, rs, size, bytes, addToStream, snapshot;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                unfinished = this._replicator.getQueue();\n                snapshotData = this._oplog.toSnapshot();\n                header = new Buffer(JSON.stringify({\n                  id: snapshotData.id,\n                  heads: snapshotData.heads,\n                  size: snapshotData.values.length,\n                  type: this.type\n                }));\n                rs = new Readable();\n                size = new Uint16Array([header.length]);\n                bytes = new Buffer(size.buffer);\n                rs.push(bytes);\n                rs.push(header);\n\n                addToStream = function addToStream(val) {\n                  var str = new Buffer(JSON.stringify(val));\n                  var size = new Uint16Array([str.length]);\n                  rs.push(new Buffer(size.buffer));\n                  rs.push(str);\n                };\n\n                snapshotData.values.forEach(addToStream);\n                rs.push(null); // tell the stream we're finished\n\n                _context7.next = 13;\n                return this._ipfs.files.add(rs);\n\n              case 13:\n                snapshot = _context7.sent;\n                _context7.next = 16;\n                return this._cache.set('snapshot', snapshot[snapshot.length - 1]);\n\n              case 16:\n                _context7.next = 18;\n                return this._cache.set('queue', unfinished);\n\n              case 18:\n                logger.debug(\"Saved snapshot: \".concat(snapshot[snapshot.length - 1].hash, \", queue length: \").concat(unfinished.length));\n                return _context7.abrupt(\"return\", snapshot);\n\n              case 20:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function saveSnapshot() {\n        return _saveSnapshot.apply(this, arguments);\n      }\n\n      return saveSnapshot;\n    }()\n  }, {\n    key: \"loadFromSnapshot\",\n    value: function () {\n      var _loadFromSnapshot = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8(onProgressCallback) {\n        var _this4 = this;\n\n        var maxClock, queue, snapshot, res, loadSnapshotData, onProgress, snapshotData, log;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                this.events.emit('load', this.address.toString());\n\n                maxClock = function maxClock(res, val) {\n                  return Math.max(res, val.clock.time);\n                };\n\n                _context8.next = 4;\n                return this._cache.get('queue');\n\n              case 4:\n                queue = _context8.sent;\n                this.sync(queue || []);\n                _context8.next = 8;\n                return this._cache.get('snapshot');\n\n              case 8:\n                snapshot = _context8.sent;\n\n                if (!snapshot) {\n                  _context8.next = 31;\n                  break;\n                }\n\n                _context8.next = 12;\n                return this._ipfs.files.catReadableStream(snapshot.hash);\n\n              case 12:\n                res = _context8.sent;\n\n                loadSnapshotData = function loadSnapshotData() {\n                  return new Promise(function (resolve, reject) {\n                    var buf = new Buffer(0);\n                    var q = [];\n\n                    var bufferData = function bufferData(d) {\n                      _this4._byteSize += d.length;\n\n                      if (q.length < 20000) {\n                        q.push(d);\n                      } else {\n                        var a = Buffer.concat(q);\n                        buf = Buffer.concat([buf, a]);\n                        q = [];\n                      }\n                    };\n\n                    var done = function done() {\n                      if (q.length > 0) {\n                        var _a = Buffer.concat(q);\n\n                        buf = Buffer.concat([buf, _a]);\n                      }\n\n                      function toArrayBuffer(buf) {\n                        var ab = new ArrayBuffer(buf.length);\n                        var view = new Uint8Array(ab);\n\n                        for (var i = 0; i < buf.length; ++i) {\n                          view[i] = buf[i];\n                        }\n\n                        return ab;\n                      }\n\n                      var headerSize = parseInt(new Uint16Array(toArrayBuffer(buf.slice(0, 2))));\n                      var header;\n\n                      try {\n                        header = JSON.parse(buf.slice(2, headerSize + 2));\n                      } catch (e) {// TODO\n                      }\n\n                      var values = [];\n                      var a = 2 + headerSize;\n\n                      while (a < buf.length) {\n                        var s = parseInt(new Uint16Array(toArrayBuffer(buf.slice(a, a + 2))));\n                        a += 2;\n                        var data = buf.slice(a, a + s);\n\n                        try {\n                          var d = JSON.parse(data);\n                          values.push(d);\n                        } catch (e) {}\n\n                        a += s;\n                      }\n\n                      if (header) {\n                        _this4._type = header.type;\n                        resolve({\n                          values: values,\n                          id: header.id,\n                          heads: header.heads,\n                          type: header.type\n                        });\n                      } else {\n                        resolve({\n                          values: values,\n                          id: null,\n                          heads: null,\n                          type: null\n                        });\n                      }\n                    };\n\n                    res.on('data', bufferData);\n                    res.on('end', done);\n                  });\n                };\n\n                onProgress = function onProgress(hash, entry, count, total) {\n                  _this4._recalculateReplicationStatus(count, entry.clock.time);\n\n                  _this4._onLoadProgress(hash, entry);\n                }; // Fetch the entries\n                // Timeout 1 sec to only load entries that are already fetched (in order to not get stuck at loading)\n\n\n                _context8.next = 17;\n                return loadSnapshotData();\n\n              case 17:\n                snapshotData = _context8.sent;\n\n                this._recalculateReplicationMax(snapshotData.values.reduce(maxClock, 0));\n\n                if (!snapshotData) {\n                  _context8.next = 28;\n                  break;\n                }\n\n                _context8.next = 22;\n                return Log.fromJSON(this._ipfs, snapshotData, -1, this._key, this.access.write, 1000, onProgress);\n\n              case 22:\n                log = _context8.sent;\n                _context8.next = 25;\n                return this._oplog.join(log);\n\n              case 25:\n                _context8.next = 27;\n                return this._updateIndex();\n\n              case 27:\n                this.events.emit('replicated', this.address.toString());\n\n              case 28:\n                this.events.emit('ready', this.address.toString(), this._oplog.heads);\n                _context8.next = 32;\n                break;\n\n              case 31:\n                throw new Error(\"Snapshot for \".concat(this.address, \" not found!\"));\n\n              case 32:\n                return _context8.abrupt(\"return\", this);\n\n              case 33:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function loadFromSnapshot(_x6) {\n        return _loadFromSnapshot.apply(this, arguments);\n      }\n\n      return loadFromSnapshot;\n    }()\n  }, {\n    key: \"_updateIndex\",\n    value: function () {\n      var _updateIndex2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee9() {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                this._recalculateReplicationMax();\n\n                _context9.next = 3;\n                return this._index.updateIndex(this._oplog);\n\n              case 3:\n                this._recalculateReplicationProgress();\n\n              case 4:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function _updateIndex() {\n        return _updateIndex2.apply(this, arguments);\n      }\n\n      return _updateIndex;\n    }()\n  }, {\n    key: \"_addOperation\",\n    value: function () {\n      var _addOperation2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee10(data, batchOperation, lastOperation, onProgressCallback) {\n        var entry;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (!this._oplog) {\n                  _context10.next = 12;\n                  break;\n                }\n\n                _context10.next = 3;\n                return this._oplog.append(data, this.options.referenceCount);\n\n              case 3:\n                entry = _context10.sent;\n\n                this._recalculateReplicationStatus(this.replicationStatus.progress + 1, entry.clock.time);\n\n                _context10.next = 7;\n                return this._cache.set('_localHeads', [entry]);\n\n              case 7:\n                _context10.next = 9;\n                return this._updateIndex();\n\n              case 9:\n                this.events.emit('write', this.address.toString(), entry, this._oplog.heads);\n                if (onProgressCallback) onProgressCallback(entry);\n                return _context10.abrupt(\"return\", entry.hash);\n\n              case 12:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function _addOperation(_x7, _x8, _x9, _x10) {\n        return _addOperation2.apply(this, arguments);\n      }\n\n      return _addOperation;\n    }()\n  }, {\n    key: \"_addOperationBatch\",\n    value: function _addOperationBatch(data, batchOperation, lastOperation, onProgressCallback) {\n      throw new Error(\"Not implemented!\");\n    }\n  }, {\n    key: \"_onLoadProgress\",\n    value: function _onLoadProgress(hash, entry, progress, total) {\n      this._recalculateReplicationStatus(progress, total);\n\n      this.events.emit('load.progress', this.address.toString(), hash, entry, this.replicationStatus.progress, this.replicationStatus.max);\n    }\n    /* Replication Status state updates */\n\n  }, {\n    key: \"_recalculateReplicationProgress\",\n    value: function _recalculateReplicationProgress(max) {\n      this._replicationStatus.progress = Math.max.apply(null, [this._replicationStatus.progress, this._oplog.length, max || 0]);\n\n      this._recalculateReplicationMax(this.replicationStatus.progress);\n    }\n  }, {\n    key: \"_recalculateReplicationMax\",\n    value: function _recalculateReplicationMax(max) {\n      this._replicationStatus.max = Math.max.apply(null, [this._replicationStatus.max, this._oplog.length, max || 0]);\n    }\n  }, {\n    key: \"_recalculateReplicationStatus\",\n    value: function _recalculateReplicationStatus(maxProgress, maxTotal) {\n      this._recalculateReplicationProgress(maxProgress);\n\n      this._recalculateReplicationMax(maxTotal);\n    }\n  }, {\n    key: \"all\",\n    get: function get() {\n      var _this5 = this;\n\n      return Array.isArray(this._index._index) ? this._index._index : Object.keys(this._index._index).map(function (e) {\n        return _this5._index._index[e];\n      });\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n  }, {\n    key: \"key\",\n    get: function get() {\n      return this._key;\n    }\n    /**\n     * Returns the database's current replication status information\n     * @return {[Object]} [description]\n     */\n\n  }, {\n    key: \"replicationStatus\",\n    get: function get() {\n      return this._replicationStatus;\n    }\n  }]);\n\n  return Store;\n}();\n\nmodule.exports = Store;","map":null,"metadata":{},"sourceType":"script"}