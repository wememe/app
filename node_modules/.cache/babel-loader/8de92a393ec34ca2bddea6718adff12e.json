{"ast":null,"code":"'use strict';\n\nvar util = require('./util');\n\nvar traverse = require('traverse');\n\nexports = module.exports;\nexports.multicodec = 'git-raw';\nexports.defaultHashAlg = 'sha1';\nvar personInfoPaths = ['original', 'name', 'email', 'date'];\n\nexports.resolve = function (binaryBlob, path, callback) {\n  if (typeof path === 'function') {\n    callback = path;\n    path = undefined;\n  }\n\n  util.deserialize(binaryBlob, function (err, node) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (!path || path === '/') {\n      return callback(null, {\n        value: node,\n        remainderPath: ''\n      });\n    }\n\n    if (Buffer.isBuffer(node)) {\n      // git blob\n      return callback(null, {\n        value: node,\n        remainderPath: path\n      });\n    }\n\n    var parts = path.split('/');\n    var val = traverse(node).get(parts);\n\n    if (val) {\n      return callback(null, {\n        value: val,\n        remainderPath: ''\n      });\n    }\n\n    var value;\n    var len = parts.length;\n\n    for (var i = 0; i < len; i++) {\n      var partialPath = parts.shift();\n\n      if (Array.isArray(node)) {\n        value = node[Number(partialPath)];\n      }\n\n      if (node[partialPath]) {\n        value = node[partialPath];\n      } else {\n        // can't traverse more\n        if (!value) {\n          return callback(new Error('path not available at root'));\n        } else {\n          parts.unshift(partialPath);\n          return callback(null, {\n            value: value,\n            remainderPath: parts.join('/')\n          });\n        }\n      }\n\n      node = value;\n    }\n  });\n};\n\nexports.tree = function (binaryBlob, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  options = options || {};\n  util.deserialize(binaryBlob, function (err, node) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (Buffer.isBuffer(node)) {\n      // git blob\n      return callback(null, []);\n    }\n\n    var paths = [];\n\n    switch (node.gitType) {\n      case 'commit':\n        paths = ['message', 'tree'];\n        paths = paths.concat(personInfoPaths.map(function (e) {\n          return 'author/' + e;\n        }));\n        paths = paths.concat(personInfoPaths.map(function (e) {\n          return 'committer/' + e;\n        }));\n        paths = paths.concat(node.parents.map(function (_, e) {\n          return 'parents/' + e;\n        }));\n\n        if (node.encoding) {\n          paths.push('encoding');\n        }\n\n        break;\n\n      case 'tag':\n        paths = ['object', 'type', 'tag', 'message'];\n\n        if (node.tagger) {\n          paths = paths.concat(personInfoPaths.map(function (e) {\n            return 'tagger/' + e;\n          }));\n        }\n\n        break;\n\n      default:\n        // tree\n        Object.keys(node).forEach(function (dir) {\n          paths.push(dir);\n          paths.push(dir + '/hash');\n          paths.push(dir + '/mode');\n        });\n    }\n\n    callback(null, paths);\n  });\n};\n\nexports.isLink = function (binaryBlob, path, callback) {\n  exports.resolve(binaryBlob, path, function (err, result) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (result.remainderPath.length > 0) {\n      return callback(new Error('path out of scope'));\n    }\n\n    if (typeof result.value === 'object' && result.value['/']) {\n      callback(null, result.value);\n    } else {\n      callback(null, false);\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}