{"ast":null,"code":"// See: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\nvar secp256k1 = new (require('elliptic').ec)('secp256k1');\n\nvar wordlist = function () {\n  var words = require('./words.json');\n\n  return words.replace(/([A-Z])/g, ' $1').toLowerCase().substring(1).split(' ');\n}();\n\nvar utils = function () {\n  var convert = require('../utils/convert.js');\n\n  var sha2 = require('../utils/sha2');\n\n  var hmac = require('../utils/hmac');\n\n  return {\n    defineProperty: require('../utils/properties.js').defineProperty,\n    arrayify: convert.arrayify,\n    bigNumberify: require('../utils/bignumber.js').bigNumberify,\n    hexlify: convert.hexlify,\n    toUtf8Bytes: require('../utils/utf8.js').toUtf8Bytes,\n    sha256: sha2.sha256,\n    createSha512Hmac: hmac.createSha512Hmac,\n    pbkdf2: require('../utils/pbkdf2.js')\n  };\n}(); // \"Bitcoin seed\"\n\n\nvar MasterSecret = utils.toUtf8Bytes('Bitcoin seed');\nvar HardenedBit = 0x80000000; // Returns a byte with the MSB bits set\n\nfunction getUpperMask(bits) {\n  return (1 << bits) - 1 << 8 - bits;\n} // Returns a byte with the LSB bits set\n\n\nfunction getLowerMask(bits) {\n  return (1 << bits) - 1;\n}\n\nfunction HDNode(keyPair, chainCode, index, depth) {\n  if (!(this instanceof HDNode)) {\n    throw new Error('missing new');\n  }\n\n  utils.defineProperty(this, '_keyPair', keyPair);\n  utils.defineProperty(this, 'privateKey', utils.hexlify(keyPair.priv.toArray('be', 32)));\n  utils.defineProperty(this, 'publicKey', '0x' + keyPair.getPublic(true, 'hex'));\n  utils.defineProperty(this, 'chainCode', utils.hexlify(chainCode));\n  utils.defineProperty(this, 'index', index);\n  utils.defineProperty(this, 'depth', depth);\n}\n\nutils.defineProperty(HDNode.prototype, '_derive', function (index) {\n  // Public parent key -> public child key\n  if (!this.privateKey) {\n    if (index >= HardenedBit) {\n      throw new Error('cannot derive child of neutered node');\n    }\n\n    throw new Error('not implemented');\n  }\n\n  var data = new Uint8Array(37);\n\n  if (index & HardenedBit) {\n    // Data = 0x00 || ser_256(k_par)\n    data.set(utils.arrayify(this.privateKey), 1);\n  } else {\n    // Data = ser_p(point(k_par))\n    data.set(this._keyPair.getPublic().encode(null, true));\n  } // Data += ser_32(i)\n\n\n  for (var i = 24; i >= 0; i -= 8) {\n    data[33 + (i >> 3)] = index >> 24 - i & 0xff;\n  }\n\n  var I = utils.arrayify(utils.createSha512Hmac(this.chainCode).update(data).digest());\n  var IL = utils.bigNumberify(I.slice(0, 32));\n  var IR = I.slice(32);\n  var ki = IL.add('0x' + this._keyPair.getPrivate('hex')).mod('0x' + secp256k1.curve.n.toString(16));\n  return new HDNode(secp256k1.keyFromPrivate(utils.arrayify(ki)), I.slice(32), index, this.depth + 1);\n});\nutils.defineProperty(HDNode.prototype, 'derivePath', function (path) {\n  var components = path.split('/');\n\n  if (components.length === 0 || components[0] === 'm' && this.depth !== 0) {\n    throw new Error('invalid path');\n  }\n\n  if (components[0] === 'm') {\n    components.shift();\n  }\n\n  var result = this;\n\n  for (var i = 0; i < components.length; i++) {\n    var component = components[i];\n\n    if (component.match(/^[0-9]+'$/)) {\n      var index = parseInt(component.substring(0, component.length - 1));\n\n      if (index >= HardenedBit) {\n        throw new Error('invalid path index - ' + component);\n      }\n\n      result = result._derive(HardenedBit + index);\n    } else if (component.match(/^[0-9]+$/)) {\n      var index = parseInt(component);\n\n      if (index >= HardenedBit) {\n        throw new Error('invalid path index - ' + component);\n      }\n\n      result = result._derive(index);\n    } else {\n      throw new Error('invalid path component - ' + component);\n    }\n  }\n\n  return result;\n});\nutils.defineProperty(HDNode, 'fromMnemonic', function (mnemonic) {\n  // Check that the checksum s valid (will throw an error)\n  mnemonicToEntropy(mnemonic);\n  return HDNode.fromSeed(mnemonicToSeed(mnemonic));\n});\nutils.defineProperty(HDNode, 'fromSeed', function (seed) {\n  seed = utils.arrayify(seed);\n\n  if (seed.length < 16 || seed.length > 64) {\n    throw new Error('invalid seed');\n  }\n\n  var I = utils.arrayify(utils.createSha512Hmac(MasterSecret).update(seed).digest());\n  return new HDNode(secp256k1.keyFromPrivate(I.slice(0, 32)), I.slice(32), 0, 0, 0);\n});\n\nfunction mnemonicToSeed(mnemonic, password) {\n  if (!password) {\n    password = '';\n  } else if (password.normalize) {\n    password = password.normalize('NFKD');\n  } else {\n    for (var i = 0; i < password.length; i++) {\n      var c = password.charCodeAt(i);\n\n      if (c < 32 || c > 127) {\n        throw new Error('passwords with non-ASCII characters not supported in this environment');\n      }\n    }\n  }\n\n  mnemonic = utils.toUtf8Bytes(mnemonic, 'NFKD');\n  var salt = utils.toUtf8Bytes('mnemonic' + password, 'NFKD');\n  return utils.hexlify(utils.pbkdf2(mnemonic, salt, 2048, 64, utils.createSha512Hmac));\n}\n\nfunction mnemonicToEntropy(mnemonic) {\n  var words = mnemonic.toLowerCase().split(' ');\n\n  if (words.length % 3 !== 0) {\n    throw new Error('invalid mnemonic');\n  }\n\n  var entropy = utils.arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n  var offset = 0;\n\n  for (var i = 0; i < words.length; i++) {\n    var index = wordlist.indexOf(words[i]);\n\n    if (index === -1) {\n      throw new Error('invalid mnemonic');\n    }\n\n    for (var bit = 0; bit < 11; bit++) {\n      if (index & 1 << 10 - bit) {\n        entropy[offset >> 3] |= 1 << 7 - offset % 8;\n      }\n\n      offset++;\n    }\n  }\n\n  var entropyBits = 32 * words.length / 3;\n  var checksumBits = words.length / 3;\n  var checksumMask = getUpperMask(checksumBits);\n  var checksum = utils.arrayify(utils.sha256(entropy.slice(0, entropyBits / 8)))[0];\n  checksum &= checksumMask;\n\n  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n    throw new Error('invalid checksum');\n  }\n\n  return utils.hexlify(entropy.slice(0, entropyBits / 8));\n}\n\nfunction entropyToMnemonic(entropy) {\n  entropy = utils.arrayify(entropy);\n\n  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {\n    throw new Error('invalid entropy');\n  }\n\n  var words = [0];\n  var remainingBits = 11;\n\n  for (var i = 0; i < entropy.length; i++) {\n    // Consume the whole byte (with still more to go)\n    if (remainingBits > 8) {\n      words[words.length - 1] <<= 8;\n      words[words.length - 1] |= entropy[i];\n      remainingBits -= 8; // This byte will complete an 11-bit index\n    } else {\n      words[words.length - 1] <<= remainingBits;\n      words[words.length - 1] |= entropy[i] >> 8 - remainingBits; // Start the next word\n\n      words.push(entropy[i] & getLowerMask(8 - remainingBits));\n      remainingBits += 3;\n    }\n  } // Compute the checksum bits\n\n\n  var checksum = utils.arrayify(utils.sha256(entropy))[0];\n  var checksumBits = entropy.length / 4;\n  checksum &= getUpperMask(checksumBits); // Shift the checksum into the word indices\n\n  words[words.length - 1] <<= checksumBits;\n  words[words.length - 1] |= checksum >> 8 - checksumBits; // Convert indices into words\n\n  for (var i = 0; i < words.length; i++) {\n    words[i] = wordlist[words[i]];\n  }\n\n  return words.join(' ');\n}\n\nfunction isValidMnemonic(mnemonic) {\n  try {\n    mnemonicToEntropy(mnemonic);\n    return true;\n  } catch (error) {}\n\n  return false;\n}\n\nmodule.exports = {\n  fromMnemonic: HDNode.fromMnemonic,\n  fromSeed: HDNode.fromSeed,\n  mnemonicToEntropy: mnemonicToEntropy,\n  entropyToMnemonic: entropyToMnemonic,\n  mnemonicToSeed: mnemonicToSeed,\n  isValidMnemonic: isValidMnemonic\n};","map":null,"metadata":{},"sourceType":"script"}