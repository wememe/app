{"ast":null,"code":"/* Copyright (c) 2013 Rod Vagg, MIT License */\nvar xtend = require('xtend'),\n    AbstractIterator = require('./abstract-iterator'),\n    AbstractChainedBatch = require('./abstract-chained-batch');\n\nfunction AbstractLevelDOWN(location) {\n  if (!arguments.length || location === undefined) throw new Error('constructor requires at least a location argument');\n  if (typeof location != 'string') throw new Error('constructor requires a location string argument');\n  this.location = location;\n  this.status = 'new';\n}\n\nAbstractLevelDOWN.prototype.open = function (options, callback) {\n  var self = this,\n      oldStatus = this.status;\n  if (typeof options == 'function') callback = options;\n  if (typeof callback != 'function') throw new Error('open() requires a callback argument');\n  if (typeof options != 'object') options = {};\n  options.createIfMissing = options.createIfMissing != false;\n  options.errorIfExists = !!options.errorIfExists;\n\n  if (typeof this._open == 'function') {\n    this.status = 'opening';\n\n    this._open(options, function (err) {\n      if (err) {\n        self.status = oldStatus;\n        return callback(err);\n      }\n\n      self.status = 'open';\n      callback();\n    });\n  } else {\n    this.status = 'open';\n    process.nextTick(callback);\n  }\n};\n\nAbstractLevelDOWN.prototype.close = function (callback) {\n  var self = this,\n      oldStatus = this.status;\n  if (typeof callback != 'function') throw new Error('close() requires a callback argument');\n\n  if (typeof this._close == 'function') {\n    this.status = 'closing';\n\n    this._close(function (err) {\n      if (err) {\n        self.status = oldStatus;\n        return callback(err);\n      }\n\n      self.status = 'closed';\n      callback();\n    });\n  } else {\n    this.status = 'closed';\n    process.nextTick(callback);\n  }\n};\n\nAbstractLevelDOWN.prototype.get = function (key, options, callback) {\n  var err;\n  if (typeof options == 'function') callback = options;\n  if (typeof callback != 'function') throw new Error('get() requires a callback argument');\n  if (err = this._checkKey(key, 'key', this._isBuffer)) return callback(err);\n  if (!this._isBuffer(key)) key = String(key);\n  if (typeof options != 'object') options = {};\n  options.asBuffer = options.asBuffer != false;\n  if (typeof this._get == 'function') return this._get(key, options, callback);\n  process.nextTick(function () {\n    callback(new Error('NotFound'));\n  });\n};\n\nAbstractLevelDOWN.prototype.put = function (key, value, options, callback) {\n  var err;\n  if (typeof options == 'function') callback = options;\n  if (typeof callback != 'function') throw new Error('put() requires a callback argument');\n  if (err = this._checkKey(key, 'key', this._isBuffer)) return callback(err);\n  if (!this._isBuffer(key)) key = String(key); // coerce value to string in node, don't touch it in browser\n  // (indexeddb can store any JS type)\n\n  if (value != null && !this._isBuffer(value) && !process.browser) value = String(value);\n  if (typeof options != 'object') options = {};\n  if (typeof this._put == 'function') return this._put(key, value, options, callback);\n  process.nextTick(callback);\n};\n\nAbstractLevelDOWN.prototype.del = function (key, options, callback) {\n  var err;\n  if (typeof options == 'function') callback = options;\n  if (typeof callback != 'function') throw new Error('del() requires a callback argument');\n  if (err = this._checkKey(key, 'key', this._isBuffer)) return callback(err);\n  if (!this._isBuffer(key)) key = String(key);\n  if (typeof options != 'object') options = {};\n  if (typeof this._del == 'function') return this._del(key, options, callback);\n  process.nextTick(callback);\n};\n\nAbstractLevelDOWN.prototype.batch = function (array, options, callback) {\n  if (!arguments.length) return this._chainedBatch();\n  if (typeof options == 'function') callback = options;\n  if (typeof array == 'function') callback = array;\n  if (typeof callback != 'function') throw new Error('batch(array) requires a callback argument');\n  if (!Array.isArray(array)) return callback(new Error('batch(array) requires an array argument'));\n  if (!options || typeof options != 'object') options = {};\n  var i = 0,\n      l = array.length,\n      e,\n      err;\n\n  for (; i < l; i++) {\n    e = array[i];\n    if (typeof e != 'object') continue;\n    if (err = this._checkKey(e.type, 'type', this._isBuffer)) return callback(err);\n    if (err = this._checkKey(e.key, 'key', this._isBuffer)) return callback(err);\n  }\n\n  if (typeof this._batch == 'function') return this._batch(array, options, callback);\n  process.nextTick(callback);\n}; //TODO: remove from here, not a necessary primitive\n\n\nAbstractLevelDOWN.prototype.approximateSize = function (start, end, callback) {\n  if (start == null || end == null || typeof start == 'function' || typeof end == 'function') {\n    throw new Error('approximateSize() requires valid `start`, `end` and `callback` arguments');\n  }\n\n  if (typeof callback != 'function') throw new Error('approximateSize() requires a callback argument');\n  if (!this._isBuffer(start)) start = String(start);\n  if (!this._isBuffer(end)) end = String(end);\n  if (typeof this._approximateSize == 'function') return this._approximateSize(start, end, callback);\n  process.nextTick(function () {\n    callback(null, 0);\n  });\n};\n\nAbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {\n  var self = this;\n  options = xtend(options);\n  ['start', 'end', 'gt', 'gte', 'lt', 'lte'].forEach(function (o) {\n    if (options[o] && self._isBuffer(options[o]) && options[o].length === 0) delete options[o];\n  });\n  options.reverse = !!options.reverse;\n  options.keys = options.keys != false;\n  options.values = options.values != false;\n  options.limit = 'limit' in options ? options.limit : -1;\n  options.keyAsBuffer = options.keyAsBuffer != false;\n  options.valueAsBuffer = options.valueAsBuffer != false;\n  return options;\n};\n\nAbstractLevelDOWN.prototype.iterator = function (options) {\n  if (typeof options != 'object') options = {};\n  options = this._setupIteratorOptions(options);\n  if (typeof this._iterator == 'function') return this._iterator(options);\n  return new AbstractIterator(this);\n};\n\nAbstractLevelDOWN.prototype._chainedBatch = function () {\n  return new AbstractChainedBatch(this);\n};\n\nAbstractLevelDOWN.prototype._isBuffer = function (obj) {\n  return Buffer.isBuffer(obj);\n};\n\nAbstractLevelDOWN.prototype._checkKey = function (obj, type) {\n  if (obj === null || obj === undefined) return new Error(type + ' cannot be `null` or `undefined`');\n\n  if (this._isBuffer(obj)) {\n    if (obj.length === 0) return new Error(type + ' cannot be an empty Buffer');\n  } else if (String(obj) === '') return new Error(type + ' cannot be an empty String');\n};\n\nmodule.exports = AbstractLevelDOWN;","map":null,"metadata":{},"sourceType":"script"}