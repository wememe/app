{"ast":null,"code":"'use strict';\n\nvar mh = require('multihashing-async');\n\nvar lp = require('pull-length-prefixed');\n\nvar pull = require('pull-stream');\n\nvar crypto = require('libp2p-crypto');\n\nvar parallel = require('async/parallel');\n\nexports.exchanges = ['P-256', 'P-384', 'P-521'];\nexports.ciphers = ['AES-256', 'AES-128'];\nexports.hashes = ['SHA256', 'SHA512']; // Determines which algorithm to use.  Note:  f(a, b) = f(b, a)\n\nexports.theBest = function (order, p1, p2) {\n  var first;\n  var second;\n\n  if (order < 0) {\n    first = p2;\n    second = p1;\n  } else if (order > 0) {\n    first = p1;\n    second = p2;\n  } else {\n    return p1[0];\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = first[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var firstCandidate = _step.value;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = second[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var secondCandidate = _step2.value;\n\n          if (firstCandidate === secondCandidate) {\n            return firstCandidate;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  throw new Error('No algorithms in common!');\n};\n\nexports.makeMacAndCipher = function (target, callback) {\n  parallel([function (cb) {\n    return makeMac(target.hashT, target.keys.macKey, cb);\n  }, function (cb) {\n    return makeCipher(target.cipherT, target.keys.iv, target.keys.cipherKey, cb);\n  }], function (err, macAndCipher) {\n    if (err) {\n      return callback(err);\n    }\n\n    target.mac = macAndCipher[0];\n    target.cipher = macAndCipher[1];\n    callback();\n  });\n};\n\nfunction makeMac(hash, key, callback) {\n  crypto.hmac.create(hash, key, callback);\n}\n\nfunction makeCipher(cipherType, iv, key, callback) {\n  if (cipherType === 'AES-128' || cipherType === 'AES-256') {\n    return crypto.aes.create(key, iv, callback);\n  } // TODO: figure out if Blowfish is needed and if so find a library for it.\n\n\n  callback(new Error(\"unrecognized cipher type: \".concat(cipherType)));\n}\n\nexports.selectBest = function (local, remote, cb) {\n  exports.digest(Buffer.concat([remote.pubKeyBytes, local.nonce]), function (err, oh1) {\n    if (err) {\n      return cb(err);\n    }\n\n    exports.digest(Buffer.concat([local.pubKeyBytes, remote.nonce]), function (err, oh2) {\n      if (err) {\n        return cb(err);\n      }\n\n      var order = Buffer.compare(oh1, oh2);\n\n      if (order === 0) {\n        return cb(new Error('you are trying to talk to yourself'));\n      }\n\n      cb(null, {\n        curveT: exports.theBest(order, local.exchanges, remote.exchanges),\n        cipherT: exports.theBest(order, local.ciphers, remote.ciphers),\n        hashT: exports.theBest(order, local.hashes, remote.hashes),\n        order: order\n      });\n    });\n  });\n};\n\nexports.digest = function (buf, cb) {\n  mh.digest(buf, 'sha2-256', buf.length, cb);\n};\n\nexports.write = function write(state, msg, cb) {\n  cb = cb || function () {};\n\n  pull(pull.values([msg]), lp.encode({\n    fixed: true,\n    bytes: 4\n  }), pull.collect(function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    state.shake.write(res[0]);\n    cb();\n  }));\n};\n\nexports.read = function read(reader, cb) {\n  lp.decodeFromReader(reader, {\n    fixed: true,\n    bytes: 4\n  }, cb);\n};","map":null,"metadata":{},"sourceType":"script"}