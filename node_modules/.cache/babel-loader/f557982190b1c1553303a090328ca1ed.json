{"ast":null,"code":"/* @flow */\n'use strict';\n\nvar _possibleConstructorReturn = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar leftPad = require('left-pad');\n\nvar Key = require('interface-datastore').Key;\n\nvar readme = require('./shard-readme'); // eslint-disable-next-line\n\n/*:: import type {Datastore, Callback} from 'interface-datastore'\n\nexport interface ShardV1 {\n  name: string;\n  param: number;\n  fun(string): string;\n  toString(): string;\n}\n*/\n\n\nvar PREFIX = exports.PREFIX = '/repo/flatfs/shard/';\nvar SHARDING_FN = exports.SHARDING_FN = 'SHARDING';\nexports.README_FN = '_README';\n\nvar Shard =\n/*#__PURE__*/\nfunction () {\n  /* :: name: string */\n\n  /* :: param: number */\n\n  /* :: _padding: string */\n  function Shard(param\n  /* : number */\n  ) {\n    _classCallCheck(this, Shard);\n\n    this.param = param;\n  }\n\n  _createClass(Shard, [{\n    key: \"fun\",\n    value: function fun(str\n    /* : string */\n    )\n    /* : string */\n    {\n      throw new Error('implement me');\n    }\n  }, {\n    key: \"toString\",\n    value: function toString()\n    /* : string */\n    {\n      return \"\".concat(PREFIX, \"v1/\").concat(this.name, \"/\").concat(this.param);\n    }\n  }]);\n\n  return Shard;\n}();\n\nvar Prefix =\n/*#__PURE__*/\nfunction (_Shard) {\n  _inherits(Prefix, _Shard);\n\n  function Prefix(prefixLen\n  /* : number */\n  ) {\n    var _this;\n\n    _classCallCheck(this, Prefix);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Prefix).call(this, prefixLen));\n    _this._padding = leftPad('', prefixLen, '_');\n    _this.name = 'prefix';\n    return _this;\n  }\n\n  _createClass(Prefix, [{\n    key: \"fun\",\n    value: function fun(noslash\n    /* : string */\n    )\n    /* : string */\n    {\n      return (noslash + this._padding).slice(0, this.param);\n    }\n  }]);\n\n  return Prefix;\n}(Shard);\n\nvar Suffix =\n/*#__PURE__*/\nfunction (_Shard2) {\n  _inherits(Suffix, _Shard2);\n\n  function Suffix(suffixLen\n  /* : number */\n  ) {\n    var _this2;\n\n    _classCallCheck(this, Suffix);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Suffix).call(this, suffixLen));\n    _this2._padding = leftPad('', suffixLen, '_');\n    _this2.name = 'suffix';\n    return _this2;\n  }\n\n  _createClass(Suffix, [{\n    key: \"fun\",\n    value: function fun(noslash\n    /* : string */\n    )\n    /* : string */\n    {\n      var s = this._padding + noslash;\n      return s.slice(s.length - this.param);\n    }\n  }]);\n\n  return Suffix;\n}(Shard);\n\nvar NextToLast =\n/*#__PURE__*/\nfunction (_Shard3) {\n  _inherits(NextToLast, _Shard3);\n\n  function NextToLast(suffixLen\n  /* : number */\n  ) {\n    var _this3;\n\n    _classCallCheck(this, NextToLast);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(NextToLast).call(this, suffixLen));\n    _this3._padding = leftPad('', suffixLen + 1, '_');\n    _this3.name = 'next-to-last';\n    return _this3;\n  }\n\n  _createClass(NextToLast, [{\n    key: \"fun\",\n    value: function fun(noslash\n    /* : string */\n    )\n    /* : string */\n    {\n      var s = this._padding + noslash;\n      var offset = s.length - this.param - 1;\n      return s.slice(offset, offset + this.param);\n    }\n  }]);\n\n  return NextToLast;\n}(Shard);\n/**\n * Convert a given string to the matching sharding function.\n *\n * @param {string} str\n * @returns {ShardV1}\n */\n\n\nfunction parseShardFun(str\n/* : string */\n)\n/* : ShardV1 */\n{\n  str = str.trim();\n\n  if (str.length === 0) {\n    throw new Error('empty shard string');\n  }\n\n  if (!str.startsWith(PREFIX)) {\n    throw new Error(\"invalid or no path prefix: \".concat(str));\n  }\n\n  var parts = str.slice(PREFIX.length).split('/');\n  var version = parts[0];\n\n  if (version !== 'v1') {\n    throw new Error(\"expect 'v1' version, got '\".concat(version, \"'\"));\n  }\n\n  var name = parts[1];\n\n  if (!parts[2]) {\n    throw new Error('missing param');\n  }\n\n  var param = parseInt(parts[2], 10);\n\n  switch (name) {\n    case 'prefix':\n      return new Prefix(param);\n\n    case 'suffix':\n      return new Suffix(param);\n\n    case 'next-to-last':\n      return new NextToLast(param);\n\n    default:\n      throw new Error(\"unkown sharding function: \".concat(name));\n  }\n}\n\nexports.readShardFun = function (path\n/* : string */\n, store\n/* : Datastore<Buffer> */\n, callback\n/* : Callback<ShardV1> */\n)\n/* : void */\n{\n  var key = new Key(path).child(new Key(SHARDING_FN));\n  var get = typeof store.getRaw === 'function' ? store.getRaw.bind(store) : store.get.bind(store);\n  get(key, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n\n    var shard;\n\n    try {\n      shard = parseShardFun((res || '').toString().trim());\n    } catch (err) {\n      return callback(err);\n    }\n\n    callback(null, shard);\n  });\n};\n\nexports.readme = readme;\nexports.parseShardFun = parseShardFun;\nexports.Prefix = Prefix;\nexports.Suffix = Suffix;\nexports.NextToLast = NextToLast;","map":null,"metadata":{},"sourceType":"script"}