{"ast":null,"code":"(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(['exports', 'bignumber.js', 'core-decorators', 'memoizerific'], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports, require('bignumber.js'), require('core-decorators'), require('memoizerific'));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports, global.bignumber, global.coreDecorators, global.memoizerific);\n    global.index = mod.exports;\n  }\n})(this, function (exports, _bignumber, _coreDecorators, _memoizerific) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  var _bignumber2 = _interopRequireDefault(_bignumber);\n\n  var _memoizerific2 = _interopRequireDefault(_memoizerific);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  var _createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n    var desc = {};\n    Object['ke' + 'ys'](descriptor).forEach(function (key) {\n      desc[key] = descriptor[key];\n    });\n    desc.enumerable = !!desc.enumerable;\n    desc.configurable = !!desc.configurable;\n\n    if ('value' in desc || desc.initializer) {\n      desc.writable = true;\n    }\n\n    desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n      return decorator(target, property, desc) || desc;\n    }, desc);\n\n    if (context && desc.initializer !== void 0) {\n      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n      desc.initializer = undefined;\n    }\n\n    if (desc.initializer === void 0) {\n      Object['define' + 'Property'](target, property, desc);\n      desc = null;\n    }\n\n    return desc;\n  }\n\n  var _dec, _dec2, _dec3, _class, _desc, _value, _class2; // Cache original 'Date' class. User may set window.Date = NanoDate;\n\n\n  if (typeof window === 'undefined') {\n    /* istanbul ignore next */\n    var BaseDate = Date;\n  } else {\n    var BaseDate = window.Date;\n  }\n\n  var ISO_8601_FULL = /^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(\\.\\d+)?(([+-]\\d\\d:\\d\\d)|Z)?$/i;\n  var MILLI_TO_NANO_DIFF = 1000000;\n  var DIGETS_IN_NANO = 19;\n  var DIGETS_IN_MILLI = 13;\n  var MINIMUM_DIGETS = DIGETS_IN_NANO - DIGETS_IN_MILLI;\n  var YEAR = 'year';\n  var MONTH = 'month';\n  var DAY = 'day';\n  var HOUR = 'hour';\n  var MINUTE = 'minute';\n  var SECOND = 'second';\n  var MILLI = 'milli';\n  var MICRO = 'micro';\n  var NANO = 'nano';\n  var DAYS = {\n    0: 31,\n    1: 28,\n    2: 31,\n    3: 30,\n    4: 31,\n    5: 30,\n    6: 31,\n    7: 31,\n    8: 30,\n    9: 31,\n    10: 30,\n    11: 31\n  };\n  var DAYS_LEAP_YEAR = {\n    0: 31,\n    1: 29,\n    2: 31,\n    3: 30,\n    4: 31,\n    5: 30,\n    6: 31,\n    7: 31,\n    8: 30,\n    9: 31,\n    10: 30,\n    11: 31\n  };\n\n  function pad(num) {\n    return addZeros(num, num < 100 ? num < 10 ? 2 : 1 : 0, true);\n  }\n\n  function padEndTo(num, toLen) {\n    return addZeros(num, 9 - ('' + num).length);\n  }\n\n  function addZeros(str) {\n    var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var front = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (count === 0) {\n      return str;\n    }\n\n    return addZeros('' + (front ? '0' : '') + str + (!front ? '0' : ''), count - 1, front);\n  }\n\n  function toNano(num) {\n    var str = '' + num;\n\n    if (str.length <= DIGETS_IN_NANO) {\n      if (str.indexOf('.') > -1) {\n        str = num.toFixed(3);\n        return new _bignumber2.default(str.replace('.', '') + '000');\n      }\n\n      return new _bignumber2.default(str);\n    }\n\n    return new _bignumber2.default(str.slice(0, DIGETS_IN_NANO));\n  }\n\n  function onlyDigits(num) {\n    return /^(-)?\\d+$/.test('' + num);\n  }\n\n  function leapYear(yearBase) {\n    var year = yearBase.toNumber();\n    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n  }\n\n  function daysForYear(year) {\n    return leapYear(year) ? 366 : 365;\n  }\n\n  function daysForMonth(year, month) {\n    var days = leapYear(year) ? DAYS_LEAP_YEAR : DAYS;\n    return days[month.toNumber()];\n  }\n\n  function handleNotAnInteger(items, funcName, names) {\n    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var item = items[index];\n    var name = names[index];\n\n    if (typeof item !== 'number' || !onlyDigits(item)) {\n      throw new Error('Parameter ' + name + ' value for ' + funcName + ' has to be an integer.');\n    } else if (names.length > index && notUndefined(items[index + 1])) {\n      handleNotAnInteger(items, funcName, names, index + 1);\n    }\n  }\n\n  function notUndefined(item) {\n    return typeof item !== 'undefined';\n  }\n\n  function buildSetFunction(scope, name, argumentNames, getMethod, valueKey) {\n    var moreVarsFunc = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function () {};\n    var utc = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n\n    function setFunction() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      handleNotAnInteger(args, name, argumentNames);\n      var currentValue = getMethod();\n\n      if (currentValue !== args[0]) {\n        if (currentValue < args[0]) {\n          var v = scope._getValue.call(scope, scope, valueKey, args[0] - currentValue, utc);\n\n          scope._full = scope._full.plus(v).truncated();\n        } else {\n          var _v = scope._getValue.call(scope, scope, valueKey, currentValue - args[0], utc);\n\n          scope._full = scope._full.minus(_v).truncated();\n        }\n\n        if (args.length === 1 || args.length > 1 && !notUndefined(args[1])) {\n          scope._setupFunctions.call(scope);\n        }\n      }\n\n      if (args.length > 1 && notUndefined(args[1])) {\n        args.shift();\n        moreVarsFunc.apply(scope, args);\n      }\n\n      return getMethod();\n    }\n\n    Object.defineProperty(setFunction, 'name', {\n      value: name,\n      writable: false\n    });\n    return setFunction.bind(scope);\n  }\n\n  var passThroughMethods = ['getFullYear', 'getYear', 'getMonth', 'getDate', 'getDay', 'getHours', 'getMinutes', 'getSeconds', 'getMilliseconds', 'getUTCFullYear', 'getUTCYear', 'getUTCMonth', 'getUTCDate', 'getUTCDay', 'getUTCHours', 'getUTCMinutes', 'getUTCSeconds', 'getUTCMilliseconds', 'toDateString', 'toLocaleDateString', 'toLocaleString', 'toTimeString', 'toLocaleTimeString', 'toISOString', 'getTimezoneOffset'];\n  var NanoDate = (_dec = (0, _coreDecorators.decorate)((0, _memoizerific2.default)(250)), _dec2 = (0, _coreDecorators.decorate)((0, _memoizerific2.default)(100)), _dec3 = (0, _coreDecorators.deprecate)('Use toUTCString() instead'), (0, _coreDecorators.autobind)(_class = (_class2 = function () {\n    function NanoDate(a, b, c, d, e, f, g, h) {\n      _classCallCheck(this, NanoDate);\n\n      if (typeof a === 'string') {\n        this._full = onlyDigits(a) ? toNano(a) : toNano(new BaseDate(a).valueOf() * MILLI_TO_NANO_DIFF);\n      } else if (arguments.length === 0) {\n        this._full = toNano(new BaseDate().valueOf() * MILLI_TO_NANO_DIFF);\n      } else if (arguments.length === 1) {\n        if (a instanceof NanoDate) {\n          this._full = a._full;\n        } else if (a instanceof BaseDate) {\n          this._full = toNano(a.valueOf() * MILLI_TO_NANO_DIFF);\n        } else if (typeof a === 'number') {\n          var multi = MILLI_TO_NANO_DIFF;\n\n          if (('' + a).indexOf('.') > -1) {\n            multi = 1;\n          }\n\n          this._full = toNano(a * multi);\n        } else {\n          throw Error('Input not of any type that can be converted to a date');\n        }\n      } else {\n        var date = void 0;\n\n        if (typeof a === 'boolean') {\n          date = BaseDate.UTC(b, c || 0, d || 0, e || 0, f || 0, g || 0, h || 0);\n        } else {\n          date = new BaseDate(a, b, c || 0, d || 0, e || 0, f || 0, g || 0);\n        }\n\n        this._full = toNano(date.valueOf() * MILLI_TO_NANO_DIFF);\n      }\n\n      this._setupFunctions();\n\n      if (typeof a === 'string' && ISO_8601_FULL.test(a) && a.indexOf('.') > -1) {\n        var match = a.match(ISO_8601_FULL);\n\n        if (typeof match[1] !== 'undefined') {\n          var padded = padEndTo(match[1].replace('.', ''), 9);\n          var nanos = parseInt(padded, 10); // set milliseconds\n\n          if (nanos > 0) {\n            this.setMilliseconds(Math.floor(nanos / MILLI_TO_NANO_DIFF));\n            nanos = nanos % MILLI_TO_NANO_DIFF;\n          } // set microseconds\n\n\n          if (nanos > 0) {\n            this.setMicroseconds(Math.floor(nanos / 1000));\n            nanos = nanos % 1000;\n          } // set nanoseconds\n\n\n          if (nanos > 0) {\n            this.setNanoseconds(Math.floor(nanos));\n          }\n        }\n      }\n    }\n\n    _createClass(NanoDate, [{\n      key: '_setupFunctions',\n      value: function _setupFunctions() {\n        var _this = this;\n\n        this._date = new BaseDate(this.valueOf());\n        passThroughMethods.forEach(function (name) {\n          _this[name] = function () {\n            var _date;\n\n            return (_date = _this._date)[name].apply(_date, arguments);\n          };\n        });\n\n        this._buildSetFunctions();\n      }\n    }, {\n      key: '_getDaysBetween',\n      value: function _getDaysBetween(a, b, func) {\n        if (a.eq(b)) {\n          return new _bignumber2.default(0);\n        }\n\n        var days = new _bignumber2.default(0);\n        var diff = a.lt(b) ? 1 : -1;\n        var start = new _bignumber2.default(a);\n\n        while (!start.eq(b)) {\n          var val = func(start);\n          days = days.plus(val);\n          start = start.plus(diff);\n        }\n\n        return days.times(diff);\n      }\n    }, {\n      key: '_getFullYear',\n      value: function _getFullYear(utc) {\n        return utc ? this.getUTCFullYear() : this.getFullYear();\n      }\n    }, {\n      key: '_getDate',\n      value: function _getDate(utc) {\n        return utc ? this.getUTCDate() : this.getDate();\n      }\n    }, {\n      key: '_getMonth',\n      value: function _getMonth(utc) {\n        return utc ? this.getUTCMonth() : this.getMonth();\n      }\n    }, {\n      key: '_getDays',\n      value: function _getDays(unit) {\n        var utc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var currentYear = new _bignumber2.default(this._getFullYear(utc));\n        var base = new _bignumber2.default(unit);\n        var res = new _bignumber2.default(this._getDate(utc)).minus(1);\n\n        if (unit >= 12) {\n          var years = base.dividedToIntegerBy(12);\n          var start = new _bignumber2.default(currentYear);\n          var end = start.plus(years);\n          res = this._getDaysBetween(start, end, daysForYear);\n          base = base.plus(years.times(12).times(base.lessThan(0) ? 1 : -1));\n        }\n\n        var month = new _bignumber2.default(this._getMonth(utc));\n        var diff = month.plus(base);\n\n        if (diff.greaterThan(11)) {\n          diff = month.minus(base);\n        } // console.log('days between', res.toNumber(), diff.toNumber(), month.toNumber());\n\n\n        if (diff.lessThan(month)) {\n          return res.plus(this._getDaysBetween(diff, month, daysForMonth.bind(null, currentYear)));\n        }\n\n        return res.plus(this._getDaysBetween(month, diff, daysForMonth.bind(null, currentYear)));\n      }\n    }, {\n      key: '_getValue',\n      value: function _getValue(scope, type, unit) {\n        var utc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        var numUnit = new _bignumber2.default(unit);\n\n        switch (type) {\n          case YEAR:\n            return scope._getValue(scope, MONTH, numUnit.times(12), utc);\n\n          case MONTH:\n            return scope._getValue(scope, DAY, scope._getDays(numUnit, utc), utc);\n\n          case DAY:\n            return scope._getValue(scope, HOUR, numUnit.times(24), utc);\n\n          case HOUR:\n            return scope._getValue(scope, MINUTE, numUnit.times(60), utc);\n\n          case MINUTE:\n            return scope._getValue(scope, SECOND, numUnit.times(60), utc);\n\n          case SECOND:\n            return scope._getValue(scope, MILLI, numUnit.times(1000), utc);\n\n          case MILLI:\n            return scope._getValue(scope, MICRO, numUnit.times(1000), utc);\n\n          case MICRO:\n            return scope._getValue(scope, NANO, numUnit.times(1000), utc);\n\n          case NANO:\n          default:\n            return numUnit;\n        }\n      }\n    }, {\n      key: 'getTime',\n      value: function getTime() {\n        return this._full.toString();\n      }\n    }, {\n      key: 'valueOf',\n      value: function valueOf() {\n        return this._full.dividedBy(MILLI_TO_NANO_DIFF).truncated().toNumber();\n      }\n    }, {\n      key: 'valueOfWithMicro',\n      value: function valueOfWithMicro() {\n        return parseFloat(this.valueOf() + '.' + pad(this.getMicroseconds()), 10);\n      }\n    }, {\n      key: 'valueOfWithNano',\n      value: function valueOfWithNano() {\n        return '' + this.valueOfWithMicro().toFixed(3) + pad(this.getNanoseconds());\n      }\n    }, {\n      key: 'getMicroseconds',\n      value: function getMicroseconds() {\n        return this._full.minus(this.valueOf() * MILLI_TO_NANO_DIFF).dividedBy(1000).truncated().toNumber();\n      }\n    }, {\n      key: 'getUTCMicroseconds',\n      value: function getUTCMicroseconds() {\n        return this.getMicroseconds();\n      }\n    }, {\n      key: 'getNanoseconds',\n      value: function getNanoseconds() {\n        return this._full.minus(this.valueOf() * MILLI_TO_NANO_DIFF).minus(this.getMicroseconds() * 1000).truncated().toNumber();\n      }\n    }, {\n      key: 'getUTCNanoseconds',\n      value: function getUTCNanoseconds() {\n        return this.getNanoseconds();\n      }\n    }, {\n      key: '_buildSetFunctions',\n      value: function _buildSetFunctions() {\n        var build = buildSetFunction.bind(this, this);\n        this.setUTCNanoseconds = this.setNanoseconds = build('setNanoseconds', ['nanosecond'], this.getUTCNanoseconds, NANO);\n        this.setUTCMicroseconds = this.setMicroseconds = build('setMicoseconds', ['microsecond', 'nanosecond'], this.getUTCMicroseconds, MICRO, this.setUTCNanoseconds);\n        this.setUTCMilliseconds = this.setMilliseconds = build('setMilliseconds', ['millisecond', 'microsecond', 'nanosecond'], this.getUTCMilliseconds, MILLI, this.setUTCMicroseconds);\n        this.setUTCSeconds = build('setUTCSeconds', ['second', 'millisecond', 'microsecond', 'nanosecond'], this.getUTCSeconds, SECOND, this.setUTCMilliseconds, true);\n        this.setSeconds = build('setSeconds', ['second', 'millisecond', 'microsecond', 'nanosecond'], this.getSeconds, SECOND, this.setMilliseconds);\n        this.setUTCMinutes = build('setUTCMinutes', ['minute', 'second', 'millisecond', 'microsecond', 'nanosecond'], this.getUTCMinutes, MINUTE, this.setUTCSeconds, true);\n        this.setMinutes = build('setMinutes', ['minute', 'second', 'millisecond', 'microsecond', 'nanosecond'], this.getMinutes, MINUTE, this.setSeconds);\n        this.setUTCHours = build('setUTCHours', ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'], this.getUTCHours, HOUR, this.setUTCMinutes, true);\n        this.setHours = build('setHours', ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'], this.getHours, HOUR, this.setMinutes);\n        this.setUTCDate = build('setUTCDate', ['day'], this.getUTCDate, DAY, function () {}, true);\n        this.setDate = build('setDate', ['day'], this.getDate, DAY);\n        this.setUTCMonth = build('setUTCMonth', ['month', 'day'], this.getUTCMonth, MONTH, this.setUTCDate, true);\n        this.setMonth = build('setMonth', ['month', 'day'], this.getMonth, MONTH, this.setDate);\n        this.setUTCFullYear = build('setUTCFullYear', ['year', 'month', 'day'], this.getUTCFullYear, YEAR, this.setUTCMonth, true);\n        this.setFullYear = build('setFullYear', ['year', 'month', 'day'], this.getFullYear, YEAR, this.setMonth);\n      }\n    }, {\n      key: 'setTime',\n      value: function setTime(time) {\n        this._full = toNano(time);\n\n        this._setupFunctions();\n\n        return time;\n      }\n    }, {\n      key: 'setUTCTime',\n      value: function setUTCTime(time) {\n        return this.setTime(time);\n      }\n    }, {\n      key: '_toString',\n      value: function _toString(funcName) {\n        var split = this._date[funcName]().split(' GMT');\n\n        var milli = this.getMilliseconds();\n        var micro = this.getMicroseconds();\n        var nano = this.getNanoseconds();\n        split[0] += '.' + pad(milli) + pad(micro) + pad(nano);\n        return split.join(' GMT');\n      }\n    }, {\n      key: 'toString',\n      value: function toString() {\n        return this._toString('toString');\n      }\n    }, {\n      key: 'toUTCString',\n      value: function toUTCString() {\n        return this._toString('toUTCString');\n      }\n    }, {\n      key: 'toISOStringFull',\n      value: function toISOStringFull() {\n        var micro = this.getMicroseconds();\n        var nano = this.getNanoseconds();\n        return this._date.toISOString().replace('Z', '' + pad(micro) + pad(nano) + 'Z');\n      }\n    }, {\n      key: 'toGMTString',\n      value: function toGMTString() {\n        return this.toUTCString();\n      }\n    }], [{\n      key: 'now',\n      value: function now() {\n        return new NanoDate().valueOf();\n      }\n    }, {\n      key: 'parse',\n      value: function parse() {\n        return BaseDate.parse.apply(BaseDate, arguments);\n      }\n    }, {\n      key: 'UTC',\n      value: function UTC() {\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        return new (Function.prototype.bind.apply(NanoDate, [null].concat([true], args)))();\n      }\n    }]);\n\n    return NanoDate;\n  }(), (_applyDecoratedDescriptor(_class2.prototype, '_getDaysBetween', [_dec], Object.getOwnPropertyDescriptor(_class2.prototype, '_getDaysBetween'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, '_getValue', [_dec2], Object.getOwnPropertyDescriptor(_class2.prototype, '_getValue'), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, 'toGMTString', [_dec3], Object.getOwnPropertyDescriptor(_class2.prototype, 'toGMTString'), _class2.prototype)), _class2)) || _class);\n  exports.default = NanoDate;\n});","map":null,"metadata":{},"sourceType":"script"}