{"ast":null,"code":"//another idea: buffer 2* the max, but only call write with half of that,\n//this could manage cases where the read ahead is latent. Hmm, we probably\n//shouldn't guess at that here, just handle write latency.\n//how would we measure this anyway?\nvar Looper = require('looper');\n\nfunction append(array, item) {\n  (array = array || []).push(item);\n  return array;\n}\n\nmodule.exports = function (write, reduce, max, cb) {\n  reduce = reduce || append;\n\n  var ended, _cb, _read;\n\n  function reader(read) {\n    var queue = null,\n        writing = false,\n        length = 0;\n    _read = read;\n    if (ended) return read(ended.abort ? true : ended, function (err) {\n      cb(err);\n      _cb && _cb();\n    });\n    var reading = false;\n    var more = Looper(function () {\n      if (reading || ended) return;\n      reading = true;\n      read(null, function (err, data) {\n        reading = false;\n\n        (function (end, data) {\n          if (ended) return;\n          ended = end;\n\n          if (!ended) {\n            queue = reduce(queue, data);\n            length = queue && queue.length || 0;\n            if (queue != null) flush();\n            if (length < max) more();\n          } else if (!writing) cb(ended === true ? null : ended);\n        })(err, data);\n      });\n    });\n\n    function flush() {\n      if (writing) return;\n      var _queue = queue;\n      queue = null;\n      writing = true;\n      length = 0;\n      write(_queue, function (err) {\n        writing = false;\n        if (ended === true && !length) cb(err);else if (ended && ended !== true) {\n          cb(ended);\n          _cb && _cb();\n        } else if (err) read(ended = err.abort ? true : err, cb); //abort upstream.\n        else if (length) flush();else more();\n      });\n    }\n\n    reader.abort = function (__cb) {\n      _cb = function _cb(end) {\n        __cb && __cb();\n      };\n\n      var err = new Error('aborted');\n      err.abort = true;\n      read(ended = err, function (end) {\n        end = end === true ? null : end;\n\n        if (!writing) {\n          cb && cb(end);\n          _cb && _cb(end);\n        }\n      });\n    };\n\n    more();\n  }\n\n  reader.abort = function (cb) {\n    ended = new Error('aborted before connecting');\n\n    _cb = function _cb(err) {\n      cb && cb();\n    };\n  };\n\n  return reader;\n};","map":null,"metadata":{},"sourceType":"script"}