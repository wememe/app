{"ast":null,"code":"/**\n *  Conversion Utilities\n *\n */\nvar defineProperty = require('./properties.js').defineProperty;\n\nvar errors = require('./errors');\n\nfunction addSlice(array) {\n  if (array.slice) {\n    return array;\n  }\n\n  array.slice = function () {\n    var args = Array.prototype.slice.call(arguments);\n    return new Uint8Array(Array.prototype.slice.apply(array, args));\n  };\n\n  return array;\n}\n\nfunction isArrayish(value) {\n  if (!value || parseInt(value.length) != value.length || typeof value === 'string') {\n    return false;\n  }\n\n  for (var i = 0; i < value.length; i++) {\n    var v = value[i];\n\n    if (v < 0 || v >= 256 || parseInt(v) != v) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction arrayify(value) {\n  if (value == null) {\n    errors.throwError('cannot convert null value to array', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: value\n    });\n  }\n\n  if (value && value.toHexString) {\n    value = value.toHexString();\n  }\n\n  if (isHexString(value)) {\n    value = value.substring(2);\n\n    if (value.length % 2) {\n      value = '0' + value;\n    }\n\n    var result = [];\n\n    for (var i = 0; i < value.length; i += 2) {\n      result.push(parseInt(value.substr(i, 2), 16));\n    }\n\n    return addSlice(new Uint8Array(result));\n  } else if (typeof value === 'string') {\n    if (value.match(/^[0-9a-fA-F]*$/)) {\n      errors.throwError('hex string must have 0x prefix', errors.INVALID_ARGUMENT, {\n        arg: 'value',\n        value: value\n      });\n    }\n\n    errors.throwError('invalid hexidecimal string', errors.INVALID_ARGUMENT, {\n      arg: 'value',\n      value: value\n    });\n  }\n\n  if (isArrayish(value)) {\n    return addSlice(new Uint8Array(value));\n  }\n\n  errors.throwError('invalid arrayify value', {\n    arg: 'value',\n    value: value,\n    type: typeof value\n  });\n}\n\nfunction concat(objects) {\n  var arrays = [];\n  var length = 0;\n\n  for (var i = 0; i < objects.length; i++) {\n    var object = arrayify(objects[i]);\n    arrays.push(object);\n    length += object.length;\n  }\n\n  var result = new Uint8Array(length);\n  var offset = 0;\n\n  for (var i = 0; i < arrays.length; i++) {\n    result.set(arrays[i], offset);\n    offset += arrays[i].length;\n  }\n\n  return addSlice(result);\n}\n\nfunction stripZeros(value) {\n  value = arrayify(value);\n\n  if (value.length === 0) {\n    return value;\n  } // Find the first non-zero entry\n\n\n  var start = 0;\n\n  while (value[start] === 0) {\n    start++;\n  } // If we started with zeros, strip them\n\n\n  if (start) {\n    value = value.slice(start);\n  }\n\n  return value;\n}\n\nfunction padZeros(value, length) {\n  value = arrayify(value);\n\n  if (length < value.length) {\n    throw new Error('cannot pad');\n  }\n\n  var result = new Uint8Array(length);\n  result.set(value, length - value.length);\n  return addSlice(result);\n}\n\nfunction isHexString(value, length) {\n  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n\n  return true;\n}\n\nvar HexCharacters = '0123456789abcdef';\n\nfunction hexlify(value) {\n  if (value && value.toHexString) {\n    return value.toHexString();\n  }\n\n  if (typeof value === 'number') {\n    if (value < 0) {\n      errors.throwError('cannot hexlify negative value', errors.INVALID_ARG, {\n        arg: 'value',\n        value: value\n      });\n    }\n\n    var hex = '';\n\n    while (value) {\n      hex = HexCharacters[value & 0x0f] + hex;\n      value = parseInt(value / 16);\n    }\n\n    if (hex.length) {\n      if (hex.length % 2) {\n        hex = '0' + hex;\n      }\n\n      return '0x' + hex;\n    }\n\n    return '0x00';\n  }\n\n  if (isHexString(value)) {\n    if (value.length % 2) {\n      value = '0x0' + value.substring(2);\n    }\n\n    return value;\n  }\n\n  if (isArrayish(value)) {\n    var result = [];\n\n    for (var i = 0; i < value.length; i++) {\n      var v = value[i];\n      result.push(HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f]);\n    }\n\n    return '0x' + result.join('');\n  }\n\n  errors.throwError('invalid hexlify value', {\n    arg: 'value',\n    value: value\n  });\n}\n\nfunction hexStripZeros(value) {\n  while (value.length > 3 && value.substring(0, 3) === '0x0') {\n    value = '0x' + value.substring(3);\n  }\n\n  return value;\n}\n\nfunction hexZeroPad(value, length) {\n  while (value.length < 2 * length + 2) {\n    value = '0x0' + value.substring(2);\n  }\n\n  return value;\n}\n/* @TODO: Add something like this to make slicing code easier to understand\nfunction hexSlice(hex, start, end) {\n    hex = hexlify(hex);\n    return '0x' + hex.substring(2 + start * 2, 2 + end * 2);\n}\n*/\n\n\nfunction splitSignature(signature) {\n  signature = arrayify(signature);\n\n  if (signature.length !== 65) {\n    throw new Error('invalid signature');\n  }\n\n  var v = signature[64];\n\n  if (v !== 27 && v !== 28) {\n    v = 27 + v % 2;\n  }\n\n  return {\n    r: hexlify(signature.slice(0, 32)),\n    s: hexlify(signature.slice(32, 64)),\n    v: v\n  };\n}\n\nmodule.exports = {\n  arrayify: arrayify,\n  isArrayish: isArrayish,\n  concat: concat,\n  padZeros: padZeros,\n  stripZeros: stripZeros,\n  splitSignature: splitSignature,\n  hexlify: hexlify,\n  isHexString: isHexString,\n  hexStripZeros: hexStripZeros,\n  hexZeroPad: hexZeroPad\n};","map":null,"metadata":{},"sourceType":"script"}