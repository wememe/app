{"ast":null,"code":"'use strict';\n\nvar waterfall = require('async/waterfall');\n\nvar each = require('async/each');\n\nvar asyncify = require('async/asyncify');\n\nvar RLP = require('rlp');\n\nvar EthBlockHead = require('ethereumjs-block/header');\n\nvar multihash = require('multihashing-async');\n\nvar cidFromHash = require('../util/cidFromHash');\n\nvar ethBlockResolver = require('../eth-block').resolver;\n\nvar createResolver = require('../util/createResolver');\n\nvar ethBlockListResolver = createResolver('eth-block-list', undefined, mapFromEthObj);\nvar util = ethBlockListResolver.util;\nutil.serialize = asyncify(function (ethBlockList) {\n  var rawOmmers = ethBlockList.map(function (ethBlock) {\n    return ethBlock.raw;\n  });\n  return RLP.encode(rawOmmers);\n});\nutil.deserialize = asyncify(function (serialized) {\n  var rawOmmers = RLP.decode(serialized);\n  return rawOmmers.map(function (rawBlock) {\n    return new EthBlockHead(rawBlock);\n  });\n});\n\nutil.cid = function (blockList, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  var hashAlg = options.hashAlg || 'keccak-256';\n  var version = typeof options.version === 'undefined' ? 1 : options.version;\n  waterfall([function (cb) {\n    return util.serialize(blockList, cb);\n  }, function (data, cb) {\n    return multihash.digest(data, hashAlg, cb);\n  }, asyncify(function (mhash) {\n    return cidFromHash('eth-block-list', mhash, options);\n  })], callback);\n};\n\nmodule.exports = ethBlockListResolver;\n\nfunction mapFromEthObj(ethBlockList, options, callback) {\n  var paths = []; // external links (none)\n  // external links as data (none)\n  // helpers\n\n  paths.push({\n    path: 'count',\n    value: ethBlockList.length\n  }); // internal data\n  // add paths for each block\n\n  each(ethBlockList, function (ethBlock, next) {\n    var index = ethBlockList.indexOf(ethBlock);\n    var blockPath = index.toString(); // block root\n\n    paths.push({\n      path: blockPath,\n      value: ethBlock\n    }); // block children\n\n    ethBlockResolver._mapFromEthObject(ethBlock, {}, function (err, subpaths) {\n      if (err) return next(err); // append blockPath to each subpath\n\n      subpaths.forEach(function (path) {\n        return path.path = blockPath + '/' + path.path;\n      });\n      paths = paths.concat(subpaths);\n      next();\n    });\n  }, function (err) {\n    if (err) return callback(err);\n    callback(null, paths);\n  });\n}","map":null,"metadata":{},"sourceType":"script"}