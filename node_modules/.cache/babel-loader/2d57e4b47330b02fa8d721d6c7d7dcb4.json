{"ast":null,"code":"'use strict';\n\nvar multiaddr = require('multiaddr');\n\nvar PeerInfo = require('peer-info');\n\nvar PeerId = require('peer-id');\n\nvar proto = require('../protocol');\n\nmodule.exports = function (swarm) {\n  /**\n   * Get b58 string from multiaddr or peerinfo\n   *\n   * @param {Multiaddr|PeerInfo} peer\n   * @return {*}\n   */\n  function getB58String(peer) {\n    var b58Id = null;\n\n    if (multiaddr.isMultiaddr(peer)) {\n      var relayMa = multiaddr(peer);\n      b58Id = relayMa.getPeerId();\n    } else if (PeerInfo.isPeerInfo(peer)) {\n      b58Id = peer.id.toB58String();\n    }\n\n    return b58Id;\n  }\n  /**\n   * Helper to make a peer info from a multiaddrs\n   *\n   * @param {Multiaddr|PeerInfo|PeerId} ma\n   * @param {Swarm} swarm\n   * @return {PeerInfo}\n   * @private\n   */\n  // TODO: this is ripped off of libp2p, should probably be a generally available util function\n\n\n  function peerInfoFromMa(peer) {\n    var p; // PeerInfo\n\n    if (PeerInfo.isPeerInfo(peer)) {\n      p = peer; // Multiaddr instance (not string)\n    } else if (multiaddr.isMultiaddr(peer)) {\n      var peerIdB58Str = peer.getPeerId();\n\n      try {\n        p = swarm._peerBook.get(peerIdB58Str);\n      } catch (err) {\n        p = new PeerInfo(PeerId.createFromB58String(peerIdB58Str));\n      }\n\n      p.multiaddrs.add(peer); // PeerId\n    } else if (PeerId.isPeerId(peer)) {\n      var _peerIdB58Str = peer.toB58String();\n\n      p = swarm._peerBook.has(_peerIdB58Str) ? swarm._peerBook.get(_peerIdB58Str) : peer;\n    }\n\n    return p;\n  }\n  /**\n   * Checks if peer has an existing connection\n   *\n   * @param {String} peerId\n   * @param {Swarm} swarm\n   * @return {Boolean}\n   */\n\n\n  function isPeerConnected(peerId) {\n    return swarm.muxedConns[peerId] || swarm.conns[peerId];\n  }\n  /**\n   * Write a response\n   *\n   * @param {StreamHandler} streamHandler\n   * @param {CircuitRelay.Status} status\n   * @param {Function} cb\n   * @returns {*}\n   */\n\n\n  function writeResponse(streamHandler, status, cb) {\n    cb = cb || function () {};\n\n    streamHandler.write(proto.CircuitRelay.encode({\n      type: proto.CircuitRelay.Type.STATUS,\n      code: status\n    }));\n    return cb();\n  }\n  /**\n   * Validate incomming HOP/STOP message\n   *\n   * @param {CircuitRelay} msg\n   * @param {StreamHandler} streamHandler\n   * @param {CircuitRelay.Type} type\n   * @returns {*}\n   * @param {Function} cb\n   */\n\n\n  function validateAddrs(msg, streamHandler, type, cb) {\n    try {\n      msg.dstPeer.addrs.forEach(function (addr) {\n        return multiaddr(addr);\n      });\n    } catch (err) {\n      writeResponse(streamHandler, type === proto.CircuitRelay.Type.HOP ? proto.CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID : proto.CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID);\n      return cb(err);\n    }\n\n    try {\n      msg.srcPeer.addrs.forEach(function (addr) {\n        return multiaddr(addr);\n      });\n    } catch (err) {\n      writeResponse(streamHandler, type === proto.CircuitRelay.Type.HOP ? proto.CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID : proto.CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID);\n      return cb(err);\n    }\n\n    return cb(null);\n  }\n\n  function peerIdFromId(id) {\n    if (typeof id === 'string') {\n      return PeerId.createFromB58String(id);\n    }\n\n    return PeerId.createFromBytes(id);\n  }\n\n  return {\n    getB58String: getB58String,\n    peerInfoFromMa: peerInfoFromMa,\n    isPeerConnected: isPeerConnected,\n    validateAddrs: validateAddrs,\n    writeResponse: writeResponse,\n    peerIdFromId: peerIdFromId\n  };\n};","map":null,"metadata":{},"sourceType":"script"}