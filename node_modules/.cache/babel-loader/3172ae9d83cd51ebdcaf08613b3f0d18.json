{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar base_provider_1 = require(\"./base-provider\");\n\nvar errors = __importStar(require(\"../errors\")); // Returns:\n//  - true is all networks match\n//  - false if any network is null\n//  - throws if any 2 networks do not match\n\n\nfunction checkNetworks(networks) {\n  var result = true;\n  var check = null;\n  networks.forEach(function (network) {\n    // Null\n    if (network == null) {\n      result = false;\n      return;\n    } // Have nothing to compre to yet\n\n\n    if (check == null) {\n      check = network;\n      return;\n    } // Matches!\n\n\n    if (check.name === network.name && check.chainId === network.chainId && (check.ensAddress === network.ensAddress || check.ensAddress == null && network.ensAddress == null)) {\n      return;\n    }\n\n    errors.throwError('provider mismatch', errors.INVALID_ARGUMENT, {\n      arg: 'networks',\n      value: networks\n    });\n  });\n  return result;\n}\n\nvar FallbackProvider =\n/** @class */\nfunction (_super) {\n  __extends(FallbackProvider, _super);\n\n  function FallbackProvider(providers) {\n    var _this = this;\n\n    if (providers.length === 0) {\n      throw new Error('no providers');\n    } // All networks are ready, we can know the network for certain\n\n\n    var ready = checkNetworks(providers.map(function (p) {\n      return p.network;\n    }));\n\n    if (ready) {\n      _this = _super.call(this, providers[0].network) || this;\n    } else {\n      // The network won't be known until all child providers know\n      var ready_1 = Promise.all(providers.map(function (p) {\n        return p.getNetwork();\n      })).then(function (networks) {\n        if (!checkNetworks(networks)) {\n          errors.throwError('getNetwork returned null', errors.UNKNOWN_ERROR, {});\n        }\n\n        return networks[0];\n      });\n      _this = _super.call(this, ready_1) || this;\n    }\n\n    errors.checkNew(_this, FallbackProvider); // Preserve a copy, so we don't get mutated\n\n    _this._providers = providers.slice(0);\n    return _this;\n  }\n\n  Object.defineProperty(FallbackProvider.prototype, \"providers\", {\n    get: function get() {\n      // Return a copy, so we don't get mutated\n      return this._providers.slice(0);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  FallbackProvider.prototype.perform = function (method, params) {\n    // Creates a copy of the providers array\n    var providers = this.providers;\n    return new Promise(function (resolve, reject) {\n      var firstError = null;\n\n      function next() {\n        if (!providers.length) {\n          reject(firstError);\n          return;\n        }\n\n        var provider = providers.shift();\n        provider.perform(method, params).then(function (result) {\n          return resolve(result);\n        }).catch(function (error) {\n          if (!firstError) {\n            firstError = error;\n          }\n\n          setTimeout(next, 0);\n        });\n      }\n\n      next();\n    });\n  };\n\n  return FallbackProvider;\n}(base_provider_1.BaseProvider);\n\nexports.FallbackProvider = FallbackProvider;","map":null,"metadata":{},"sourceType":"script"}