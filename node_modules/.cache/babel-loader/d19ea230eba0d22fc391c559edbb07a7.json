{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar MuPort = require('muport-core');\n\nvar bip39 = require('bip39');\n\nvar localstorage = require('store');\n\nvar IPFS = require('ipfs');\n\nvar OrbitDB = require('orbit-db');\n\nvar Pubsub = require('orbit-db-pubsub'); // const OrbitDBCacheProxy = require('orbit-db-cache-postmsg-proxy').Client\n// const { createProxyClient } = require('ipfs-postmsg-proxy')\n\n\nvar graphQLRequest = require('graphql-request').request;\n\nvar PublicStore = require('./publicStore');\n\nvar PrivateStore = require('./privateStore');\n\nvar Verified = require('./verified');\n\nvar OrbitdbKeyAdapter = require('./orbitdbKeyAdapter');\n\nvar utils = require('./utils/index');\n\nvar verifier = require('./utils/verifier');\n\nvar ADDRESS_SERVER_URL = 'https://beta.3box.io/address-server';\nvar PINNING_NODE = '/dnsaddr/ipfs.3box.io/tcp/443/wss/ipfs/QmZvxEpiVNjmNbEKyQGvFzAY1BwmGuuvdUTmcTstQPhyVC';\nvar PINNING_ROOM = '3box-pinning'; // const IFRAME_STORE_VERSION = '0.0.3'\n// const IFRAME_STORE_URL = `https://iframe.3box.io/${IFRAME_STORE_VERSION}/iframe.html`\n\nvar IPFS_OPTIONS = {\n  EXPERIMENTAL: {\n    pubsub: true\n  },\n  preload: {\n    enabled: false\n  },\n  config: {\n    Bootstrap: []\n  }\n};\nvar GRAPHQL_SERVER_URL = 'https://aic67onptg.execute-api.us-west-2.amazonaws.com/develop/graphql';\nvar PROFILE_SERVER_URL = 'https://ipfs.3box.io';\nvar globalIPFS, globalOrbitDB; // , ipfsProxy, cacheProxy, iframeLoadedPromise\n\n/*\nif (typeof window !== 'undefined' && typeof document !== 'undefined') {\n  const iframe = document.createElement('iframe')\n  iframe.src = IFRAME_STORE_URL\n  iframe.style = 'width:0; height:0; border:0; border:none !important'\n\n  iframeLoadedPromise = new Promise((resolve, reject) => {\n    iframe.onload = () => { resolve() }\n  })\n\n  document.body.appendChild(iframe)\n  // Create proxy clients that talks to the iframe\n  const postMessage = iframe.contentWindow.postMessage.bind(iframe.contentWindow)\n  ipfsProxy = createProxyClient({ postMessage })\n  cacheProxy = OrbitDBCacheProxy({ postMessage })\n} */\n\nvar Box =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Please use the **openBox** method to instantiate a 3Box\n   */\n  function Box(muportDID, ethereumProvider) {\n    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0, _classCallCheck2.default)(this, Box);\n    this._muportDID = muportDID;\n    this._web3provider = ethereumProvider;\n    this._serverUrl = opts.addressServer || ADDRESS_SERVER_URL;\n\n    this._onSyncDoneCB = function () {};\n    /**\n     * @property {KeyValueStore} public         access the profile store of the users 3Box\n     */\n\n\n    this.public = null;\n    /**\n     * @property {KeyValueStore} private        access the private store of the users 3Box\n     */\n\n    this.private = null;\n    /**\n     * @property {Verified} verified       check and create verifications\n     */\n\n    this.verified = new Verified(this);\n  }\n\n  (0, _createClass2.default)(Box, [{\n    key: \"_load\",\n    value: function () {\n      var _load2 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee2() {\n        var _this = this;\n\n        var opts,\n            did,\n            didFingerprint,\n            rootStoreName,\n            keystore,\n            cache,\n            rootStoreAddress,\n            onNewPeer,\n            _ref,\n            _ref2,\n            pubStoreAddress,\n            privStoreAddress,\n            syncPromises,\n            hasResponse,\n            onMessageRes,\n            _args2 = arguments;\n\n        return _regenerator.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                opts = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};\n                did = this._muportDID.getDid();\n                didFingerprint = utils.sha256Multihash(did);\n                rootStoreName = didFingerprint + '.root';\n                this.pinningNode = opts.pinningNode || PINNING_NODE;\n                _context2.next = 7;\n                return initIPFS(opts.ipfs, opts.iframeStore, opts.ipfsOptions);\n\n              case 7:\n                this._ipfs = _context2.sent;\n\n                this._ipfs.swarm.connect(this.pinningNode, function () {});\n\n                keystore = new OrbitdbKeyAdapter(this._muportDID);\n                cache = null; // (opts.iframeStore && !!cacheProxy) ? cacheProxy : null\n\n                this._orbitdb = new OrbitDB(this._ipfs, opts.orbitPath, {\n                  keystore: keystore,\n                  cache: cache\n                });\n                globalIPFS = this._ipfs;\n                globalOrbitDB = this._orbitdb;\n                _context2.next = 16;\n                return this._orbitdb.feed(rootStoreName);\n\n              case 16:\n                this._rootStore = _context2.sent;\n                rootStoreAddress = this._rootStore.address.toString();\n                _context2.t0 = Pubsub;\n                _context2.t1 = this._ipfs;\n                _context2.next = 22;\n                return this._ipfs.id();\n\n              case 22:\n                _context2.t2 = _context2.sent.id;\n                this._pubsub = new _context2.t0(_context2.t1, _context2.t2);\n\n                onNewPeer = function onNewPeer(topic, peer) {\n                  if (peer === _this.pinningNode.split('/').pop()) {\n                    _this._pubsub.publish(PINNING_ROOM, {\n                      type: 'PIN_DB',\n                      odbAddress: rootStoreAddress\n                    });\n                  }\n                };\n\n                this.public = new PublicStore(this._orbitdb, didFingerprint + '.public', this._linkProfile.bind(this), this._ensurePinningNodeConnected.bind(this));\n                this.private = new PrivateStore(this._muportDID, this._orbitdb, didFingerprint + '.private', this._ensurePinningNodeConnected.bind(this));\n                _context2.next = 29;\n                return Promise.all([this.public._load(), this.private._load()]);\n\n              case 29:\n                _ref = _context2.sent;\n                _ref2 = (0, _slicedToArray2.default)(_ref, 2);\n                pubStoreAddress = _ref2[0];\n                privStoreAddress = _ref2[1];\n                syncPromises = [];\n                hasResponse = {};\n\n                onMessageRes =\n                /*#__PURE__*/\n                function () {\n                  var _ref3 = (0, _asyncToGenerator2.default)(\n                  /*#__PURE__*/\n                  _regenerator.default.mark(function _callee(topic, data) {\n                    var promises;\n                    return _regenerator.default.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            if (!(data.type === 'HAS_ENTRIES')) {\n                              _context.next = 11;\n                              break;\n                            }\n\n                            if (data.odbAddress === privStoreAddress && !hasResponse[privStoreAddress]) {\n                              syncPromises.push(_this.private._sync(data.numEntries));\n                              hasResponse[privStoreAddress] = true;\n                            }\n\n                            if (data.odbAddress === pubStoreAddress && !hasResponse[pubStoreAddress]) {\n                              syncPromises.push(_this.public._sync(data.numEntries));\n                              hasResponse[pubStoreAddress] = true;\n                            }\n\n                            if (!(syncPromises.length === 2)) {\n                              _context.next = 11;\n                              break;\n                            }\n\n                            promises = syncPromises;\n                            syncPromises = [];\n                            _context.next = 8;\n                            return Promise.all(promises);\n\n                          case 8:\n                            _context.next = 10;\n                            return _this._ensureDIDPublished();\n\n                          case 10:\n                            _this._onSyncDoneCB();\n\n                          // this._pubsub.unsubscribe(PINNING_ROOM)\n\n                          case 11:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee, this);\n                  }));\n\n                  return function onMessageRes(_x2, _x3) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }();\n\n                this._pubsub.subscribe(PINNING_ROOM, onMessageRes, onNewPeer);\n\n                this._createRootStore(rootStoreAddress, privStoreAddress, pubStoreAddress, this.pinningNode);\n\n              case 38:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function _load() {\n        return _load2.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"_createRootStore\",\n    value: function () {\n      var _createRootStore2 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee3(rootStoreAddress, privOdbAddress, pubOdbAddress) {\n        var entries;\n        return _regenerator.default.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._rootStore.load();\n\n              case 2:\n                _context3.next = 4;\n                return this._rootStore.iterator({\n                  limit: -1\n                }).collect();\n\n              case 4:\n                entries = _context3.sent;\n\n                if (entries.find(function (e) {\n                  return e.payload.value.odbAddress === pubOdbAddress;\n                })) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                _context3.next = 8;\n                return this._rootStore.add({\n                  odbAddress: pubOdbAddress\n                });\n\n              case 8:\n                if (entries.find(function (e) {\n                  return e.payload.value.odbAddress === privOdbAddress;\n                })) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                _context3.next = 11;\n                return this._rootStore.add({\n                  odbAddress: privOdbAddress\n                });\n\n              case 11:\n                this._publishRootStore(rootStoreAddress);\n\n              case 12:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      return function _createRootStore(_x4, _x5, _x6) {\n        return _createRootStore2.apply(this, arguments);\n      };\n    }()\n    /**\n     * Get the public profile of a given address\n     *\n     * @param     {String}    address                 An ethereum address\n     * @param     {Object}    opts                    Optional parameters\n     * @param     {String}    opts.addressServer      URL of the Address Server\n     * @param     {Object}    opts.ipfs               A js-ipfs ipfs object\n     * @param     {String}    opts.orbitPath          A custom path for orbitdb storage\n     * @param     {Boolean}   opts.iframeStore        Use iframe for storage, allows shared store across domains. Default true when run in browser.\n     * @param     {Boolean}   opts.useCacheService    Use 3Box API and Cache Service to fetch profile instead of OrbitDB. Default true.\n     * @return    {Object}                            a json object with the profile for the given address\n     */\n\n  }, {\n    key: \"onSyncDone\",\n\n    /**\n     * Sets the callback function that will be called once when the db is fully synced.\n     *\n     * @param     {Function}      syncDone        The function that will be called\n     */\n    value: function onSyncDone(syncDone) {\n      this._onSyncDoneCB = syncDone;\n    }\n  }, {\n    key: \"_publishRootStore\",\n    value: function () {\n      var _publishRootStore2 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee4(rootStoreAddress) {\n        var addressToken;\n        return _regenerator.default.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this._muportDID.signJWT({\n                  rootStoreAddress: rootStoreAddress\n                });\n\n              case 2:\n                addressToken = _context4.sent;\n                _context4.prev = 3;\n                _context4.next = 6;\n                return utils.fetchJson(this._serverUrl + '/odbAddress', {\n                  address_token: addressToken\n                });\n\n              case 6:\n                _context4.next = 11;\n                break;\n\n              case 8:\n                _context4.prev = 8;\n                _context4.t0 = _context4[\"catch\"](3);\n                throw new Error(_context4.t0);\n\n              case 11:\n                return _context4.abrupt(\"return\", true);\n\n              case 12:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[3, 8]]);\n      }));\n\n      return function _publishRootStore(_x7) {\n        return _publishRootStore2.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"_linkProfile\",\n    value: function () {\n      var _linkProfile2 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee5() {\n        var address, did, linkData, consent;\n        return _regenerator.default.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                address = this._muportDID.getDidDocument().managementKey;\n\n                if (localstorage.get('linkConsent_' + address)) {\n                  _context5.next = 22;\n                  break;\n                }\n\n                did = this._muportDID.getDid();\n                _context5.next = 5;\n                return this.public.get('ethereum_proof');\n\n              case 5:\n                linkData = _context5.sent;\n\n                if (linkData) {\n                  _context5.next = 13;\n                  break;\n                }\n\n                _context5.next = 9;\n                return utils.getLinkConsent(address, did, this._web3provider);\n\n              case 9:\n                consent = _context5.sent;\n                linkData = {\n                  consent_msg: consent.msg,\n                  consent_signature: consent.sig,\n                  linked_did: did\n                };\n                _context5.next = 13;\n                return this.public.set('ethereum_proof', linkData);\n\n              case 13:\n                _context5.prev = 13;\n                _context5.next = 16;\n                return utils.fetchJson(this._serverUrl + '/link', linkData);\n\n              case 16:\n                localstorage.set('linkConsent_' + address, true);\n                _context5.next = 22;\n                break;\n\n              case 19:\n                _context5.prev = 19;\n                _context5.t0 = _context5[\"catch\"](13);\n                console.error(_context5.t0);\n\n              case 22:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[13, 19]]);\n      }));\n\n      return function _linkProfile() {\n        return _linkProfile2.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"_ensureDIDPublished\",\n    value: function () {\n      var _ensureDIDPublished2 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee6() {\n        return _regenerator.default.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.public.get('proof_did');\n\n              case 2:\n                if (_context6.sent) {\n                  _context6.next = 9;\n                  break;\n                }\n\n                _context6.t0 = this.public;\n                _context6.next = 6;\n                return this._muportDID.signJWT();\n\n              case 6:\n                _context6.t1 = _context6.sent;\n                _context6.next = 9;\n                return _context6.t0.set.call(_context6.t0, 'proof_did', _context6.t1);\n\n              case 9:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      return function _ensureDIDPublished() {\n        return _ensureDIDPublished2.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"_ensurePinningNodeConnected\",\n    value: function () {\n      var _ensurePinningNodeConnected2 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee7(odbAddress) {\n        var _this2 = this;\n\n        var roomPeers, rootStoreAddress;\n        return _regenerator.default.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this._ipfs.pubsub.peers(odbAddress);\n\n              case 2:\n                roomPeers = _context7.sent;\n\n                if (!roomPeers.find(function (p) {\n                  return p === _this2.pinningNode.split('/').pop();\n                })) {\n                  this._ipfs.swarm.connect(this.pinningNode, function () {});\n\n                  rootStoreAddress = this._rootStore.address.toString();\n\n                  this._pubsub.publish(PINNING_ROOM, {\n                    type: 'PIN_DB',\n                    odbAddress: rootStoreAddress\n                  });\n                }\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      return function _ensurePinningNodeConnected(_x8) {\n        return _ensurePinningNodeConnected2.apply(this, arguments);\n      };\n    }()\n    /**\n     * Closes the 3box instance without clearing the local cache.\n     * Should be called after you are done using the 3Box instance,\n     * but without logging the user out.\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee8() {\n        return _regenerator.default.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this._orbitdb.stop();\n\n              case 2:\n                _context8.next = 4;\n                return this._pubsub.disconnect();\n\n              case 4:\n                // await this._ipfs.stop()\n                globalOrbitDB = null;\n                globalIPFS = null;\n\n              case 6:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      return function close() {\n        return _close.apply(this, arguments);\n      };\n    }()\n    /**\n     * Closes the 3box instance and clears local cache. If you call this,\n     * users will need to sign a consent message to log in the next time\n     * you call openBox.\n     */\n\n  }, {\n    key: \"logout\",\n    value: function () {\n      var _logout = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee9() {\n        var address;\n        return _regenerator.default.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.close();\n\n              case 2:\n                address = this._muportDID.getDidDocument().managementKey;\n                localstorage.remove('serializedMuDID_' + address);\n                localstorage.remove('linkConsent_' + address);\n\n              case 5:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      return function logout() {\n        return _logout.apply(this, arguments);\n      };\n    }()\n    /**\n     * Check if the given address is logged in\n     *\n     * @param     {String}    address                 An ethereum address\n     * @return    {Boolean}                           true if the user is logged in\n     */\n\n  }], [{\n    key: \"getProfile\",\n    value: function () {\n      var _getProfile = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee10(address) {\n        var opts,\n            normalizedAddress,\n            profile,\n            profileServerUrl,\n            _args10 = arguments;\n        return _regenerator.default.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                opts = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};\n                normalizedAddress = address.toLowerCase();\n                opts = Object.assign({\n                  useCacheService: true\n                }, opts);\n\n                if (!opts.useCacheService) {\n                  _context10.next = 10;\n                  break;\n                }\n\n                profileServerUrl = opts.profileServer || PROFILE_SERVER_URL;\n                _context10.next = 7;\n                return getProfileAPI(normalizedAddress, profileServerUrl);\n\n              case 7:\n                profile = _context10.sent;\n                _context10.next = 13;\n                break;\n\n              case 10:\n                _context10.next = 12;\n                return this._getProfileOrbit(normalizedAddress, opts);\n\n              case 12:\n                profile = _context10.sent;\n\n              case 13:\n                return _context10.abrupt(\"return\", profile);\n\n              case 14:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      return function getProfile(_x9) {\n        return _getProfile.apply(this, arguments);\n      };\n    }()\n    /**\n     * Get a list of public profiles for given addresses. This relies on 3Box profile API.\n     *\n     * @param     {Array}     address                 An array of ethereum addresses\n     * @param     {Object}    opts                    Optional parameters\n     * @param     {String}    opts.profileServer      URL of Profile API server\n     * @return    {Object}                            a json object with each key an address and value the profile\n     */\n\n  }, {\n    key: \"getProfiles\",\n    value: function () {\n      var _getProfiles = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee11(addressArray) {\n        var opts,\n            profileServerUrl,\n            req,\n            _args11 = arguments;\n        return _regenerator.default.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                opts = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : {};\n                profileServerUrl = opts.profileServer || PROFILE_SERVER_URL;\n                req = {\n                  addressList: addressArray\n                };\n                return _context11.abrupt(\"return\", utils.fetchJson(profileServerUrl + '/profileList', req));\n\n              case 4:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      return function getProfiles(_x10) {\n        return _getProfiles.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"_getProfileOrbit\",\n    value: function () {\n      var _getProfileOrbit2 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee13(address) {\n        var opts,\n            serverUrl,\n            rootStoreAddress,\n            usingGlobalIPFS,\n            usingGlobalOrbitDB,\n            ipfs,\n            orbitdb,\n            cache,\n            pinningNode,\n            publicStore,\n            rootStore,\n            readyPromise,\n            profileEntry,\n            profile,\n            closeAll,\n            _args13 = arguments;\n        return _regenerator.default.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                opts = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : {}; // opts = Object.assign({ iframeStore: true }, opts)\n\n                serverUrl = opts.addressServer || ADDRESS_SERVER_URL;\n                _context13.next = 4;\n                return getRootStoreAddress(serverUrl, address.toLowerCase());\n\n              case 4:\n                rootStoreAddress = _context13.sent;\n                usingGlobalIPFS = false;\n                usingGlobalOrbitDB = false;\n\n                if (!globalIPFS) {\n                  _context13.next = 12;\n                  break;\n                }\n\n                ipfs = globalIPFS;\n                usingGlobalIPFS = true;\n                _context13.next = 15;\n                break;\n\n              case 12:\n                _context13.next = 14;\n                return initIPFS(opts.ipfs, opts.iframeStore, opts.ipfsOptions);\n\n              case 14:\n                ipfs = _context13.sent;\n\n              case 15:\n                if (globalOrbitDB) {\n                  orbitdb = globalOrbitDB;\n                  usingGlobalIPFS = true;\n                } else {\n                  cache = null; // (opts.iframeStore && !!cacheProxy) ? cacheProxy : null\n\n                  orbitdb = new OrbitDB(ipfs, opts.orbitPath, {\n                    cache: cache\n                  });\n                }\n\n                pinningNode = opts.pinningNode || PINNING_NODE;\n                ipfs.swarm.connect(pinningNode, function () {});\n                publicStore = new PublicStore(orbitdb);\n\n                if (!rootStoreAddress) {\n                  _context13.next = 41;\n                  break;\n                }\n\n                _context13.next = 22;\n                return orbitdb.open(rootStoreAddress);\n\n              case 22:\n                rootStore = _context13.sent;\n                readyPromise = new Promise(function (resolve, reject) {\n                  rootStore.events.on('ready', resolve);\n                });\n                rootStore.load();\n                _context13.next = 27;\n                return readyPromise;\n\n              case 27:\n                if (rootStore.iterator({\n                  limit: -1\n                }).collect().length) {\n                  _context13.next = 30;\n                  break;\n                }\n\n                _context13.next = 30;\n                return new Promise(function (resolve, reject) {\n                  rootStore.events.on('replicate.progress', function (_x, _y, _z, num, max) {\n                    if (num === max) {\n                      rootStore.events.on('replicated', resolve);\n                    }\n                  });\n                });\n\n              case 30:\n                profileEntry = rootStore.iterator({\n                  limit: -1\n                }).collect().find(function (entry) {\n                  return entry.payload.value.odbAddress.split('.')[1] === 'public';\n                });\n                _context13.next = 33;\n                return publicStore._load(profileEntry.payload.value.odbAddress);\n\n              case 33:\n                _context13.next = 35;\n                return publicStore._sync();\n\n              case 35:\n                profile = publicStore.all();\n\n                closeAll =\n                /*#__PURE__*/\n                function () {\n                  var _ref4 = (0, _asyncToGenerator2.default)(\n                  /*#__PURE__*/\n                  _regenerator.default.mark(function _callee12() {\n                    return _regenerator.default.wrap(function _callee12$(_context12) {\n                      while (1) {\n                        switch (_context12.prev = _context12.next) {\n                          case 0:\n                            _context12.next = 2;\n                            return rootStore.close();\n\n                          case 2:\n                            _context12.next = 4;\n                            return publicStore.close();\n\n                          case 4:\n                            if (usingGlobalOrbitDB) {\n                              _context12.next = 7;\n                              break;\n                            }\n\n                            _context12.next = 7;\n                            return orbitdb.stop();\n\n                          case 7:\n                            if (!usingGlobalIPFS) {}\n\n                          // await ipfs.stop()\n\n                          case 8:\n                          case \"end\":\n                            return _context12.stop();\n                        }\n                      }\n                    }, _callee12, this);\n                  }));\n\n                  return function closeAll() {\n                    return _ref4.apply(this, arguments);\n                  };\n                }(); // close but don't wait for it\n\n\n                closeAll();\n                return _context13.abrupt(\"return\", profile);\n\n              case 41:\n                return _context13.abrupt(\"return\", null);\n\n              case 42:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      return function _getProfileOrbit(_x11) {\n        return _getProfileOrbit2.apply(this, arguments);\n      };\n    }()\n    /**\n     * GraphQL for 3Box profile API\n     *\n     * @param     {Object}    query               A graphQL query object.\n     * @param     {Object}    opts                Optional parameters\n     * @param     {String}    opts.graphqlServer  URL of graphQL 3Box profile service\n     * @return    {Object}                        a json object with each key an address and value the profile\n     */\n\n  }, {\n    key: \"profileGraphQL\",\n    value: function () {\n      var _profileGraphQL = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee14(query) {\n        var opts,\n            _args14 = arguments;\n        return _regenerator.default.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                opts = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : {};\n                return _context14.abrupt(\"return\", graphQLRequest(opts.graphqlServer || GRAPHQL_SERVER_URL, query));\n\n              case 2:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      return function profileGraphQL(_x12) {\n        return _profileGraphQL.apply(this, arguments);\n      };\n    }()\n    /**\n     * Verifies the proofs of social accounts that is present in the profile.\n     *\n     * @param     {Object}            profile                 A user profile object\n     * @return    {Object}                                    An object containing the accounts that have been verified\n     */\n\n  }, {\n    key: \"getVerifiedAccounts\",\n    value: function () {\n      var _getVerifiedAccounts = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee15(profile) {\n        var verifs, did;\n        return _regenerator.default.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                verifs = {};\n                _context15.next = 3;\n                return verifier.verifyDID(profile.proof_did);\n\n              case 3:\n                did = _context15.sent;\n\n                if (!profile.proof_github) {\n                  _context15.next = 14;\n                  break;\n                }\n\n                _context15.prev = 5;\n                _context15.next = 8;\n                return verifier.verifyGithub(did, profile.proof_github);\n\n              case 8:\n                verifs.github = _context15.sent;\n                _context15.next = 14;\n                break;\n\n              case 11:\n                _context15.prev = 11;\n                _context15.t0 = _context15[\"catch\"](5);\n                console.error('Invalid github verification:', _context15.t0.message);\n\n              case 14:\n                if (!profile.proof_twitter) {\n                  _context15.next = 24;\n                  break;\n                }\n\n                _context15.prev = 15;\n                _context15.next = 18;\n                return verifier.verifyTwitter(did, profile.proof_twitter);\n\n              case 18:\n                verifs.twitter = _context15.sent;\n                _context15.next = 24;\n                break;\n\n              case 21:\n                _context15.prev = 21;\n                _context15.t1 = _context15[\"catch\"](15);\n                console.error('Invalid twitter verification:', _context15.t1.message);\n\n              case 24:\n                return _context15.abrupt(\"return\", verifs);\n\n              case 25:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this, [[5, 11], [15, 21]]);\n      }));\n\n      return function getVerifiedAccounts(_x13) {\n        return _getVerifiedAccounts.apply(this, arguments);\n      };\n    }()\n    /**\n     * Opens the user space associated with the given address\n     *\n     * @param     {String}            address                 An ethereum address\n     * @param     {ethereumProvider}  ethereumProvider        An ethereum provider\n     * @param     {Object}            opts                    Optional parameters\n     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box\n     * @param     {String}            opts.pinningNode        A string with an ipfs multi-address to a 3box pinning node\n     * @param     {Object}            opts.ipfs               A js-ipfs ipfs object\n     * @param     {String}            opts.orbitPath          A custom path for orbitdb storage\n     * @param     {String}            opts.addressServer      URL of the Address Server\n     * @param     {Boolean}           opts.iframeStore        Use iframe for storage, allows shared store across domains. Default true when run in browser.\n     * @return    {Box}                                       the 3Box instance for the given address\n     */\n\n  }, {\n    key: \"openBox\",\n    value: function () {\n      var _openBox = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee16(address, ethereumProvider, opts) {\n        var normalizedAddress, muportDID, serializedMuDID, sig, entropy, mnemonic, box;\n        return _regenerator.default.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                // opts = Object.assign({ iframeStore: true }, opts)\n                normalizedAddress = address.toLowerCase();\n                serializedMuDID = localstorage.get('serializedMuDID_' + normalizedAddress);\n\n                if (!serializedMuDID) {\n                  _context16.next = 7;\n                  break;\n                }\n\n                muportDID = new MuPort(serializedMuDID);\n                if (opts.consentCallback) opts.consentCallback(false);\n                _context16.next = 17;\n                break;\n\n              case 7:\n                _context16.next = 9;\n                return utils.openBoxConsent(normalizedAddress, ethereumProvider);\n\n              case 9:\n                sig = _context16.sent;\n                if (opts.consentCallback) opts.consentCallback(true);\n                entropy = utils.sha256(sig.slice(2));\n                mnemonic = bip39.entropyToMnemonic(entropy);\n                _context16.next = 15;\n                return MuPort.newIdentity(null, null, {\n                  externalMgmtKey: normalizedAddress,\n                  mnemonic: mnemonic\n                });\n\n              case 15:\n                muportDID = _context16.sent;\n                localstorage.set('serializedMuDID_' + normalizedAddress, muportDID.serializeState());\n\n              case 17:\n                box = new Box(muportDID, ethereumProvider, opts);\n                _context16.next = 20;\n                return box._load(opts);\n\n              case 20:\n                return _context16.abrupt(\"return\", box);\n\n              case 21:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      return function openBox(_x14, _x15, _x16) {\n        return _openBox.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"isLoggedIn\",\n    value: function isLoggedIn(address) {\n      return Boolean(localstorage.get('serializedMuDID_' + address.toLowerCase()));\n    }\n  }]);\n  return Box;\n}();\n\nfunction initIPFS(_x17, _x18, _x19) {\n  return _initIPFS.apply(this, arguments);\n}\n\nfunction _initIPFS() {\n  _initIPFS = (0, _asyncToGenerator2.default)(\n  /*#__PURE__*/\n  _regenerator.default.mark(function _callee17(ipfs, iframeStore, ipfsOptions) {\n    return _regenerator.default.wrap(function _callee17$(_context17) {\n      while (1) {\n        switch (_context17.prev = _context17.next) {\n          case 0:\n            // if (!ipfs && !ipfsProxy) throw new Error('No IPFS object configured and no default available for environment')\n            if (!!ipfs && iframeStore) console.log('Warning: iframeStore true, orbit db cache in iframe, but the given ipfs object is being used, and may not be running in same iframe.');\n\n            if (!ipfs) {\n              _context17.next = 5;\n              break;\n            }\n\n            return _context17.abrupt(\"return\", ipfs);\n\n          case 5:\n            return _context17.abrupt(\"return\", new Promise(function (resolve, reject) {\n              ipfs = new IPFS(ipfsOptions || IPFS_OPTIONS);\n              ipfs.on('error', function (error) {\n                console.error(error);\n                reject(error);\n              });\n              ipfs.on('ready', function () {\n                return resolve(ipfs);\n              });\n            }));\n\n          case 6:\n          case \"end\":\n            return _context17.stop();\n        }\n      }\n    }, _callee17, this);\n  }));\n  return _initIPFS.apply(this, arguments);\n}\n\nfunction getRootStoreAddress(_x20, _x21) {\n  return _getRootStoreAddress.apply(this, arguments);\n}\n\nfunction _getRootStoreAddress() {\n  _getRootStoreAddress = (0, _asyncToGenerator2.default)(\n  /*#__PURE__*/\n  _regenerator.default.mark(function _callee18(serverUrl, identifier) {\n    var res;\n    return _regenerator.default.wrap(function _callee18$(_context18) {\n      while (1) {\n        switch (_context18.prev = _context18.next) {\n          case 0:\n            _context18.next = 2;\n            return utils.fetchJson(serverUrl + '/odbAddress/' + identifier);\n\n          case 2:\n            res = _context18.sent;\n\n            if (!(res.status === 'success')) {\n              _context18.next = 7;\n              break;\n            }\n\n            return _context18.abrupt(\"return\", res.data.rootStoreAddress);\n\n          case 7:\n            throw new Error(res.message);\n\n          case 8:\n          case \"end\":\n            return _context18.stop();\n        }\n      }\n    }, _callee18, this);\n  }));\n  return _getRootStoreAddress.apply(this, arguments);\n}\n\nfunction getProfileAPI(_x22, _x23) {\n  return _getProfileAPI.apply(this, arguments);\n}\n\nfunction _getProfileAPI() {\n  _getProfileAPI = (0, _asyncToGenerator2.default)(\n  /*#__PURE__*/\n  _regenerator.default.mark(function _callee20(rootStoreAddress, serverUrl) {\n    return _regenerator.default.wrap(function _callee20$(_context20) {\n      while (1) {\n        switch (_context20.prev = _context20.next) {\n          case 0:\n            return _context20.abrupt(\"return\", new Promise(\n            /*#__PURE__*/\n            function () {\n              var _ref5 = (0, _asyncToGenerator2.default)(\n              /*#__PURE__*/\n              _regenerator.default.mark(function _callee19(resolve, reject) {\n                var res;\n                return _regenerator.default.wrap(function _callee19$(_context19) {\n                  while (1) {\n                    switch (_context19.prev = _context19.next) {\n                      case 0:\n                        _context19.prev = 0;\n                        _context19.next = 3;\n                        return utils.fetchJson(serverUrl + '/profile?address=' + encodeURIComponent(rootStoreAddress));\n\n                      case 3:\n                        res = _context19.sent;\n                        resolve(res);\n                        _context19.next = 10;\n                        break;\n\n                      case 7:\n                        _context19.prev = 7;\n                        _context19.t0 = _context19[\"catch\"](0);\n                        reject(_context19.t0);\n\n                      case 10:\n                      case \"end\":\n                        return _context19.stop();\n                    }\n                  }\n                }, _callee19, this, [[0, 7]]);\n              }));\n\n              return function (_x24, _x25) {\n                return _ref5.apply(this, arguments);\n              };\n            }()));\n\n          case 1:\n          case \"end\":\n            return _context20.stop();\n        }\n      }\n    }, _callee20, this);\n  }));\n  return _getProfileAPI.apply(this, arguments);\n}\n\nmodule.exports = Box;","map":null,"metadata":{},"sourceType":"script"}