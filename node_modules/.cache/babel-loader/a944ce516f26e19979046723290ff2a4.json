{"ast":null,"code":"'use strict'; // returns a function with the signature fn(length, callback)\n// will pass a buffer of `length` bytes to the callback, unless source ends while\n// reading in which case the buffer may be less than `length` bytes long\n\nvar bufferPullStreamSource = function bufferPullStreamSource(source) {\n  var next = Buffer.alloc(0);\n\n  var read = function read(length, callback) {\n    source(null, function (error, buffer) {\n      if (error) {\n        if (error === true) {\n          // the source stream ended, return what we've got\n          return callback(null, next);\n        } // an actual error occurred\n\n\n        return callback(error);\n      }\n\n      next = Buffer.concat([next, buffer]); // haven't read enough bytes yet\n\n      if (next.length < length) {\n        return read(length, callback);\n      } // got enough bytes, prepare to send the requested amount\n\n\n      var slice = next.slice(0, length); // store any extra bytes for the next invocation\n\n      next = next.slice(length); // return the bytes\n\n      callback(null, slice);\n    });\n  };\n\n  return read;\n};\n\nmodule.exports = bufferPullStreamSource;","map":null,"metadata":{},"sourceType":"script"}