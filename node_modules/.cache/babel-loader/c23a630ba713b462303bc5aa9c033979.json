{"ast":null,"code":"'use strict';\n\nvar inherits = require('inherits');\n\nvar XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;\n\nvar networks = require('./networks.json');\n\nvar utils = function () {\n  var convert = require('../utils/convert');\n\n  var utf8 = require('../utils/utf8');\n\n  return {\n    defineProperty: require('../utils/properties').defineProperty,\n    getAddress: require('../utils/address').getAddress,\n    getContractAddress: require('../utils/contract-address').getContractAddress,\n    bigNumberify: require('../utils/bignumber').bigNumberify,\n    arrayify: convert.arrayify,\n    hexlify: convert.hexlify,\n    isHexString: convert.isHexString,\n    concat: convert.concat,\n    hexStripZeros: convert.hexStripZeros,\n    stripZeros: convert.stripZeros,\n    base64: require('../utils/base64'),\n    namehash: require('../utils/namehash'),\n    toUtf8String: utf8.toUtf8String,\n    toUtf8Bytes: utf8.toUtf8Bytes,\n    RLP: require('../utils/rlp')\n  };\n}();\n\nvar errors = require('../utils/errors');\n\nfunction copyObject(obj) {\n  var result = {};\n\n  for (var key in obj) {\n    result[key] = obj[key];\n  }\n\n  return result;\n}\n\nfunction check(format, object) {\n  var result = {};\n\n  for (var key in format) {\n    try {\n      var value = format[key](object[key]);\n\n      if (value !== undefined) {\n        result[key] = value;\n      }\n    } catch (error) {\n      error.checkKey = key;\n      error.checkValue = object[key];\n      throw error;\n    }\n  }\n\n  return result;\n}\n\nfunction allowNull(check, nullValue) {\n  return function (value) {\n    if (value == null) {\n      return nullValue;\n    }\n\n    return check(value);\n  };\n}\n\nfunction allowFalsish(check, replaceValue) {\n  return function (value) {\n    if (!value) {\n      return replaceValue;\n    }\n\n    return check(value);\n  };\n}\n\nfunction arrayOf(check) {\n  return function (array) {\n    if (!Array.isArray(array)) {\n      throw new Error('not an array');\n    }\n\n    var result = [];\n    array.forEach(function (value) {\n      result.push(check(value));\n    });\n    return result;\n  };\n}\n\nfunction checkHash(hash) {\n  if (!utils.isHexString(hash) || hash.length !== 66) {\n    throw new Error('invalid hash - ' + hash);\n  }\n\n  return hash;\n}\n\nfunction checkNumber(number) {\n  return utils.bigNumberify(number).toNumber();\n}\n\nfunction checkDifficulty(number) {\n  var value = utils.bigNumberify(number);\n\n  try {\n    value = value.toNumber();\n  } catch (error) {\n    value = null;\n  }\n\n  return value;\n}\n\nfunction checkBoolean(value) {\n  if (typeof value === 'boolean') {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    if (value === 'true') {\n      return true;\n    }\n\n    if (value === 'false') {\n      return false;\n    }\n  }\n\n  throw new Error('invaid boolean - ' + value);\n}\n\nfunction checkUint256(uint256) {\n  if (!utils.isHexString(uint256)) {\n    throw new Error('invalid uint256');\n  }\n\n  while (uint256.length < 66) {\n    uint256 = '0x0' + uint256.substring(2);\n  }\n\n  return uint256;\n}\n\nfunction checkString(string) {\n  if (typeof string !== 'string') {\n    throw new Error('invalid string');\n  }\n\n  return string;\n}\n\nfunction checkBlockTag(blockTag) {\n  if (blockTag == null) {\n    return 'latest';\n  }\n\n  if (blockTag === 'earliest') {\n    return '0x0';\n  }\n\n  if (blockTag === 'latest' || blockTag === 'pending') {\n    return blockTag;\n  }\n\n  if (typeof blockTag === 'number') {\n    return utils.hexStripZeros(utils.hexlify(blockTag));\n  }\n\n  if (utils.isHexString(blockTag)) {\n    return utils.hexStripZeros(blockTag);\n  }\n\n  throw new Error('invalid blockTag');\n}\n\nvar formatBlock = {\n  hash: checkHash,\n  parentHash: checkHash,\n  number: checkNumber,\n  timestamp: checkNumber,\n  nonce: allowNull(utils.hexlify),\n  difficulty: checkDifficulty,\n  gasLimit: utils.bigNumberify,\n  gasUsed: utils.bigNumberify,\n  miner: utils.getAddress,\n  extraData: utils.hexlify,\n  //transactions: allowNull(arrayOf(checkTransaction)),\n  transactions: allowNull(arrayOf(checkHash)) //transactionRoot: checkHash,\n  //stateRoot: checkHash,\n  //sha3Uncles: checkHash,\n  //logsBloom: utils.hexlify,\n\n};\n\nfunction checkBlock(block) {\n  if (block.author != null && block.miner == null) {\n    block.miner = block.author;\n  }\n\n  return check(formatBlock, block);\n}\n\nvar formatTransaction = {\n  hash: checkHash,\n  blockHash: allowNull(checkHash, null),\n  blockNumber: allowNull(checkNumber, null),\n  transactionIndex: allowNull(checkNumber, null),\n  from: utils.getAddress,\n  gasPrice: utils.bigNumberify,\n  gasLimit: utils.bigNumberify,\n  to: allowNull(utils.getAddress, null),\n  value: utils.bigNumberify,\n  nonce: checkNumber,\n  data: utils.hexlify,\n  r: allowNull(checkUint256),\n  s: allowNull(checkUint256),\n  v: allowNull(checkNumber),\n  creates: allowNull(utils.getAddress, null),\n  raw: allowNull(utils.hexlify)\n};\n\nfunction checkTransaction(transaction) {\n  // Rename gas to gasLimit\n  if (transaction.gas != null && transaction.gasLimit == null) {\n    transaction.gasLimit = transaction.gas;\n  } // Some clients (TestRPC) do strange things like return 0x0 for the\n  // 0 address; correct this to be a real address\n\n\n  if (transaction.to && utils.bigNumberify(transaction.to).isZero()) {\n    transaction.to = '0x0000000000000000000000000000000000000000';\n  } // Rename input to data\n\n\n  if (transaction.input != null && transaction.data == null) {\n    transaction.data = transaction.input;\n  } // If to and creates are empty, populate the creates from the transaction\n\n\n  if (transaction.to == null && transaction.creates == null) {\n    transaction.creates = utils.getContractAddress(transaction);\n  }\n\n  if (!transaction.raw) {\n    // Very loose providers (e.g. TestRPC) don't provide a signature or raw\n    if (transaction.v && transaction.r && transaction.s) {\n      var raw = [utils.stripZeros(utils.hexlify(transaction.nonce)), utils.stripZeros(utils.hexlify(transaction.gasPrice)), utils.stripZeros(utils.hexlify(transaction.gasLimit)), transaction.to || \"0x\", utils.stripZeros(utils.hexlify(transaction.value || '0x')), utils.hexlify(transaction.data || '0x'), utils.stripZeros(utils.hexlify(transaction.v || '0x')), utils.stripZeros(utils.hexlify(transaction.r)), utils.stripZeros(utils.hexlify(transaction.s))];\n      transaction.raw = utils.RLP.encode(raw);\n    }\n  }\n\n  var result = check(formatTransaction, transaction);\n  var networkId = transaction.networkId;\n\n  if (utils.isHexString(networkId)) {\n    networkId = utils.bigNumberify(networkId).toNumber();\n  }\n\n  if (typeof networkId !== 'number' && result.v != null) {\n    networkId = (result.v - 35) / 2;\n\n    if (networkId < 0) {\n      networkId = 0;\n    }\n\n    networkId = parseInt(networkId);\n  }\n\n  if (typeof networkId !== 'number') {\n    networkId = 0;\n  }\n\n  result.networkId = networkId; // 0x0000... should actually be null\n\n  if (result.blockHash && result.blockHash.replace(/0/g, '') === 'x') {\n    result.blockHash = null;\n  }\n\n  return result;\n}\n\nvar formatTransactionRequest = {\n  from: allowNull(utils.getAddress),\n  nonce: allowNull(checkNumber),\n  gasLimit: allowNull(utils.bigNumberify),\n  gasPrice: allowNull(utils.bigNumberify),\n  to: allowNull(utils.getAddress),\n  value: allowNull(utils.bigNumberify),\n  data: allowNull(utils.hexlify)\n};\n\nfunction checkTransactionRequest(transaction) {\n  return check(formatTransactionRequest, transaction);\n}\n\nvar formatTransactionReceiptLog = {\n  transactionLogIndex: allowNull(checkNumber),\n  transactionIndex: checkNumber,\n  blockNumber: checkNumber,\n  transactionHash: checkHash,\n  address: utils.getAddress,\n  topics: arrayOf(checkHash),\n  data: utils.hexlify,\n  logIndex: checkNumber,\n  blockHash: checkHash\n};\n\nfunction checkTransactionReceiptLog(log) {\n  return check(formatTransactionReceiptLog, log);\n}\n\nvar formatTransactionReceipt = {\n  contractAddress: allowNull(utils.getAddress, null),\n  transactionIndex: checkNumber,\n  root: allowNull(checkHash),\n  gasUsed: utils.bigNumberify,\n  logsBloom: allowNull(utils.hexlify),\n  blockHash: checkHash,\n  transactionHash: checkHash,\n  logs: arrayOf(checkTransactionReceiptLog),\n  blockNumber: checkNumber,\n  cumulativeGasUsed: utils.bigNumberify,\n  status: allowNull(checkNumber)\n};\n\nfunction checkTransactionReceipt(transactionReceipt) {\n  var status = transactionReceipt.status;\n  var root = transactionReceipt.root;\n  var result = check(formatTransactionReceipt, transactionReceipt);\n  result.logs.forEach(function (entry, index) {\n    if (entry.transactionLogIndex == null) {\n      entry.transactionLogIndex = index;\n    }\n  });\n\n  if (transactionReceipt.status != null) {\n    result.byzantium = true;\n  }\n\n  return result;\n}\n\nfunction checkTopics(topics) {\n  if (Array.isArray(topics)) {\n    topics.forEach(function (topic) {\n      checkTopics(topic);\n    });\n  } else if (topics != null) {\n    checkHash(topics);\n  }\n\n  return topics;\n}\n\nvar formatFilter = {\n  fromBlock: allowNull(checkBlockTag, undefined),\n  toBlock: allowNull(checkBlockTag, undefined),\n  address: allowNull(utils.getAddress, undefined),\n  topics: allowNull(checkTopics, undefined)\n};\n\nfunction checkFilter(filter) {\n  return check(formatFilter, filter);\n}\n\nvar formatLog = {\n  blockNumber: allowNull(checkNumber),\n  blockHash: allowNull(checkHash),\n  transactionIndex: checkNumber,\n  removed: allowNull(checkBoolean),\n  address: utils.getAddress,\n  data: allowFalsish(utils.hexlify, '0x'),\n  topics: arrayOf(checkHash),\n  transactionHash: checkHash,\n  logIndex: checkNumber\n};\n\nfunction checkLog(log) {\n  return check(formatLog, log);\n}\n\nfunction Provider(network) {\n  if (!(this instanceof Provider)) {\n    throw new Error('missing new');\n  }\n\n  network = Provider.getNetwork(network); // Check the ensAddress (if any)\n\n  var ensAddress = null;\n\n  if (network.ensAddress) {\n    ensAddress = utils.getAddress(network.ensAddress);\n  } // Setup our network properties\n\n\n  utils.defineProperty(this, 'chainId', network.chainId);\n  utils.defineProperty(this, 'ensAddress', ensAddress);\n  utils.defineProperty(this, 'name', network.name);\n  var events = {};\n  utils.defineProperty(this, '_events', events); // We use this to track recent emitted events; for example, if we emit a \"block\" of 100\n  // and we get a `getBlock(100)` request which would result in null, we should retry\n  // until we get a response. This provides devs with a consistent view. Similarly for\n  // transaction hashes.\n\n  utils.defineProperty(this, '_emitted', {\n    block: -1\n  });\n  var self = this;\n  var lastBlockNumber = null;\n  var balances = {};\n\n  function doPoll() {\n    self.getBlockNumber().then(function (blockNumber) {\n      // If the block hasn't changed, meh.\n      if (blockNumber === lastBlockNumber) {\n        return;\n      }\n\n      if (lastBlockNumber === null) {\n        lastBlockNumber = blockNumber - 1;\n      } // Notify all listener for each block that has passed\n\n\n      for (var i = lastBlockNumber + 1; i <= blockNumber; i++) {\n        if (self._emitted.block < i) {\n          self._emitted.block = i; // Evict any transaction hashes or block hashes over 12 blocks\n          // old, since they should not return null anyways\n\n          Object.keys(self._emitted).forEach(function (key) {\n            if (key === 'block') {\n              return;\n            }\n\n            if (self._emitted[key] > i + 12) {\n              delete self._emitted[key];\n            }\n          });\n        }\n\n        self.emit('block', i);\n      } // Sweep balances and remove addresses we no longer have events for\n\n\n      var newBalances = {}; // Find all transaction hashes we are waiting on\n\n      Object.keys(events).forEach(function (eventName) {\n        var event = parseEventString(eventName);\n\n        if (event.type === 'transaction') {\n          self.getTransaction(event.hash).then(function (transaction) {\n            if (!transaction || transaction.blockNumber == null) {\n              return null;\n            }\n\n            self._emitted['t:' + transaction.hash.toLowerCase()] = transaction.blockNumber;\n            self.emit(event.hash, transaction);\n            return null;\n          }).catch(function (error) {});\n        } else if (event.type === 'address') {\n          if (balances[event.address]) {\n            newBalances[event.address] = balances[event.address];\n          }\n\n          self.getBalance(event.address, 'latest').then(function (balance) {\n            var lastBalance = balances[event.address];\n\n            if (lastBalance && balance.eq(lastBalance)) {\n              return null;\n            }\n\n            balances[event.address] = balance;\n            self.emit(event.address, balance);\n            return null;\n          }).catch(function (error) {});\n        } else if (event.type === 'topic') {\n          self.getLogs({\n            fromBlock: lastBlockNumber + 1,\n            toBlock: blockNumber,\n            topics: event.topic\n          }).then(function (logs) {\n            if (logs.length === 0) {\n              return null;\n            }\n\n            logs.forEach(function (log) {\n              self._emitted['b:' + log.blockHash.toLowerCase()] = log.blockNumber;\n              self._emitted['t:' + log.transactionHash.toLowerCase()] = log.blockNumber;\n              self.emit(event.topic, log);\n            });\n            return null;\n          }).catch(function (error) {});\n        }\n      });\n      lastBlockNumber = blockNumber;\n      balances = newBalances;\n      return null;\n    }).catch(function () {});\n    self.doPoll();\n  }\n\n  utils.defineProperty(this, 'resetEventsBlock', function (blockNumber) {\n    lastBlockNumber = blockNumber;\n    self.doPoll();\n  });\n  var pollingInterval = 4000;\n  var poller = null;\n  Object.defineProperty(this, 'polling', {\n    get: function get() {\n      return poller != null;\n    },\n    set: function set(value) {\n      setTimeout(function () {\n        if (value && !poller) {\n          poller = setInterval(doPoll, pollingInterval);\n        } else if (!value && poller) {\n          clearInterval(poller);\n          poller = null;\n        }\n      }, 0);\n    }\n  });\n  Object.defineProperty(this, 'pollingInterval', {\n    get: function get() {\n      return pollingInterval;\n    },\n    set: function set(value) {\n      if (typeof value !== 'number' || value <= 0 || parseInt(value) != value) {\n        throw new Error('invalid polling interval');\n      }\n\n      pollingInterval = value;\n\n      if (poller) {\n        clearInterval(poller);\n        poller = setInterval(doPoll, pollingInterval);\n      }\n    }\n  }); // @TODO: Add .poller which must be an event emitter with a 'start', 'stop' and 'block' event;\n  //        this will be used once we move to the WebSocket or other alternatives to polling\n}\n\nfunction inheritable(parent) {\n  return function (child) {\n    inherits(child, parent);\n    utils.defineProperty(child, 'inherits', inheritable(child));\n  };\n}\n\nutils.defineProperty(Provider, 'inherits', inheritable(Provider));\n/*\nfunction(child) {\n    inherits(child, Provider);\n    child.inherits = function(grandchild) {\n        inherits(grandchild, child)\n    }\n});\n*/\n\nutils.defineProperty(Provider, 'getNetwork', function (network) {\n  if (typeof network === 'string') {\n    network = networks[network];\n\n    if (!network) {\n      throw new Error('unknown network');\n    }\n  } else if (network == null) {\n    network = networks['homestead'];\n  }\n\n  if (typeof network.chainId !== 'number') {\n    throw new Error('invalid chainId');\n  }\n\n  return network;\n});\nutils.defineProperty(Provider, 'networks', networks);\nutils.defineProperty(Provider, 'fetchJSON', function (url, json, processFunc) {\n  var headers = [];\n\n  if (typeof url === 'object' && url.url != null && url.user != null && url.password != null) {\n    if (url.url.substring(0, 6) !== 'https:' && url.forceInsecure !== true) {\n      errors.throwError('basic authentication requires a secure https url', errors.INVALID_ARGUMENT, {\n        arg: 'url',\n        url: url.url,\n        user: url.user,\n        password: '[REDACTED]'\n      });\n    }\n\n    var authorization = url.user + ':' + url.password;\n    headers.push({\n      key: 'Authorization',\n      value: 'Basic ' + utils.base64.encode(utils.toUtf8Bytes(authorization))\n    });\n    url = url.url;\n  }\n\n  return new Promise(function (resolve, reject) {\n    var request = new XMLHttpRequest();\n\n    if (json) {\n      request.open('POST', url, true);\n      headers.push({\n        key: 'Content-Type',\n        value: 'application/json'\n      });\n    } else {\n      request.open('GET', url, true);\n    }\n\n    headers.forEach(function (header) {\n      request.setRequestHeader(header.key, header.value);\n    });\n\n    request.onreadystatechange = function () {\n      if (request.readyState !== 4) {\n        return;\n      }\n\n      try {\n        var result = JSON.parse(request.responseText);\n      } catch (error) {\n        var jsonError = new Error('invalid json response');\n        jsonError.orginialError = error;\n        jsonError.responseText = request.responseText;\n        jsonError.url = url;\n        reject(jsonError);\n        return;\n      }\n\n      if (processFunc) {\n        try {\n          result = processFunc(result);\n        } catch (error) {\n          error.url = url;\n          error.body = json;\n          error.responseText = request.responseText;\n          reject(error);\n          return;\n        }\n      }\n\n      if (request.status != 200) {\n        var error = new Error('invalid response - ' + request.status);\n        error.statusCode = request.statusCode;\n        reject(error);\n        return;\n      }\n\n      resolve(result);\n    };\n\n    request.onerror = function (error) {\n      reject(error);\n    };\n\n    try {\n      if (json) {\n        request.send(json);\n      } else {\n        request.send();\n      }\n    } catch (error) {\n      var connectionError = new Error('connection error');\n      connectionError.error = error;\n      reject(connectionError);\n    }\n  });\n});\nutils.defineProperty(Provider.prototype, 'waitForTransaction', function (transactionHash, timeout) {\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    var timer = null;\n\n    function complete(transaction) {\n      if (timer) {\n        clearTimeout(timer);\n      }\n\n      resolve(transaction);\n    }\n\n    self.once(transactionHash, complete);\n\n    if (typeof timeout === 'number' && timeout > 0) {\n      timer = setTimeout(function () {\n        self.removeListener(transactionHash, complete);\n        reject(new Error('timeout'));\n      }, timeout);\n    }\n  });\n});\nutils.defineProperty(Provider.prototype, 'getBlockNumber', function () {\n  try {\n    return this.perform('getBlockNumber').then(function (result) {\n      var value = parseInt(result);\n\n      if (value != result) {\n        throw new Error('invalid response - getBlockNumber');\n      }\n\n      return value;\n    });\n  } catch (error) {\n    return Promise.reject(error);\n  }\n});\nutils.defineProperty(Provider.prototype, 'getGasPrice', function () {\n  try {\n    return this.perform('getGasPrice').then(function (result) {\n      return utils.bigNumberify(result);\n    });\n  } catch (error) {\n    return Promise.reject(error);\n  }\n});\nutils.defineProperty(Provider.prototype, 'getBalance', function (addressOrName, blockTag) {\n  var self = this;\n  return this.resolveName(addressOrName).then(function (address) {\n    var params = {\n      address: address,\n      blockTag: checkBlockTag(blockTag)\n    };\n    return self.perform('getBalance', params).then(function (result) {\n      return utils.bigNumberify(result);\n    });\n  });\n});\nutils.defineProperty(Provider.prototype, 'getTransactionCount', function (addressOrName, blockTag) {\n  var self = this;\n  return this.resolveName(addressOrName).then(function (address) {\n    var params = {\n      address: address,\n      blockTag: checkBlockTag(blockTag)\n    };\n    return self.perform('getTransactionCount', params).then(function (result) {\n      var value = parseInt(result);\n\n      if (value != result) {\n        throw new Error('invalid response - getTransactionCount');\n      }\n\n      return value;\n    });\n  });\n});\nutils.defineProperty(Provider.prototype, 'getCode', function (addressOrName, blockTag) {\n  var self = this;\n  return this.resolveName(addressOrName).then(function (address) {\n    var params = {\n      address: address,\n      blockTag: checkBlockTag(blockTag)\n    };\n    return self.perform('getCode', params).then(function (result) {\n      return utils.hexlify(result);\n    });\n  });\n});\nutils.defineProperty(Provider.prototype, 'getStorageAt', function (addressOrName, position, blockTag) {\n  var self = this;\n  return this.resolveName(addressOrName).then(function (address) {\n    var params = {\n      address: address,\n      blockTag: checkBlockTag(blockTag),\n      position: utils.hexStripZeros(utils.hexlify(position))\n    };\n    return self.perform('getStorageAt', params).then(function (result) {\n      return utils.hexlify(result);\n    });\n  });\n});\nutils.defineProperty(Provider.prototype, 'sendTransaction', function (signedTransaction) {\n  try {\n    var params = {\n      signedTransaction: utils.hexlify(signedTransaction)\n    };\n    return this.perform('sendTransaction', params).then(function (result) {\n      result = utils.hexlify(result);\n\n      if (result.length !== 66) {\n        throw new Error('invalid response - sendTransaction');\n      }\n\n      return result;\n    });\n  } catch (error) {\n    return Promise.reject(error);\n  }\n});\nutils.defineProperty(Provider.prototype, 'call', function (transaction) {\n  var self = this;\n  return this._resolveNames(transaction, ['to', 'from']).then(function (transaction) {\n    var params = {\n      transaction: checkTransactionRequest(transaction)\n    };\n    return self.perform('call', params).then(function (result) {\n      return utils.hexlify(result);\n    });\n  });\n});\nutils.defineProperty(Provider.prototype, 'estimateGas', function (transaction) {\n  var self = this;\n  return this._resolveNames(transaction, ['to', 'from']).then(function (transaction) {\n    var params = {\n      transaction: checkTransactionRequest(transaction)\n    };\n    return self.perform('estimateGas', params).then(function (result) {\n      return utils.bigNumberify(result);\n    });\n  });\n});\n\nfunction stallPromise(allowNullFunc, executeFunc) {\n  return new Promise(function (resolve, reject) {\n    var attempt = 0;\n\n    function check() {\n      executeFunc().then(function (result) {\n        // If we have a result, or are allowed null then we're done\n        if (result || allowNullFunc()) {\n          resolve(result); // Otherwise, exponential back-off (up to 10s) our next request\n        } else {\n          attempt++;\n          var timeout = 500 + 250 * parseInt(Math.random() * (1 << attempt));\n\n          if (timeout > 10000) {\n            timeout = 10000;\n          }\n\n          setTimeout(check, timeout);\n        }\n\n        return null;\n      }, function (error) {\n        reject(error);\n      }).catch(function (error) {\n        reject(error);\n      });\n    }\n\n    check();\n  });\n}\n\nutils.defineProperty(Provider.prototype, 'getBlock', function (blockHashOrBlockTag) {\n  var self = this;\n\n  try {\n    var blockHash = utils.hexlify(blockHashOrBlockTag);\n\n    if (blockHash.length === 66) {\n      return stallPromise(function () {\n        return self._emitted['b:' + blockHash.toLowerCase()] == null;\n      }, function () {\n        return self.perform('getBlock', {\n          blockHash: blockHash\n        }).then(function (block) {\n          if (block == null) {\n            return null;\n          }\n\n          return checkBlock(block);\n        });\n      });\n    }\n  } catch (error) {}\n\n  try {\n    var blockTag = checkBlockTag(blockHashOrBlockTag);\n    return stallPromise(function () {\n      if (utils.isHexString(blockTag)) {\n        var blockNumber = parseInt(blockTag.substring(2), 16);\n        return blockNumber > self._emitted.block;\n      }\n\n      return true;\n    }, function () {\n      return self.perform('getBlock', {\n        blockTag: blockTag\n      }).then(function (block) {\n        if (block == null) {\n          return null;\n        }\n\n        return checkBlock(block);\n      });\n    });\n  } catch (error) {}\n\n  return Promise.reject(new Error('invalid block hash or block tag'));\n});\nutils.defineProperty(Provider.prototype, 'getTransaction', function (transactionHash) {\n  var self = this;\n\n  try {\n    var params = {\n      transactionHash: checkHash(transactionHash)\n    };\n    return stallPromise(function () {\n      return self._emitted['t:' + transactionHash.toLowerCase()] == null;\n    }, function () {\n      return self.perform('getTransaction', params).then(function (result) {\n        if (result != null) {\n          result = checkTransaction(result);\n        }\n\n        return result;\n      });\n    });\n  } catch (error) {\n    return Promise.reject(error);\n  }\n});\nutils.defineProperty(Provider.prototype, 'getTransactionReceipt', function (transactionHash) {\n  var self = this;\n\n  try {\n    var params = {\n      transactionHash: checkHash(transactionHash)\n    };\n    return stallPromise(function () {\n      return self._emitted['t:' + transactionHash.toLowerCase()] == null;\n    }, function () {\n      return self.perform('getTransactionReceipt', params).then(function (result) {\n        if (result != null) {\n          result = checkTransactionReceipt(result);\n        }\n\n        return result;\n      });\n    });\n  } catch (error) {\n    return Promise.reject(error);\n  }\n});\nutils.defineProperty(Provider.prototype, 'getLogs', function (filter) {\n  var self = this;\n  return this._resolveNames(filter, ['address']).then(function (filter) {\n    var params = {\n      filter: checkFilter(filter)\n    };\n    return self.perform('getLogs', params).then(function (result) {\n      return arrayOf(checkLog)(result);\n    });\n  });\n});\nutils.defineProperty(Provider.prototype, 'getEtherPrice', function () {\n  try {\n    return this.perform('getEtherPrice', {}).then(function (result) {\n      // @TODO: Check valid float\n      return result;\n    });\n  } catch (error) {\n    return Promise.reject(error);\n  }\n});\nutils.defineProperty(Provider.prototype, '_resolveNames', function (object, keys) {\n  var promises = [];\n  var result = copyObject(object);\n  keys.forEach(function (key) {\n    if (result[key] === undefined) {\n      return;\n    }\n\n    promises.push(this.resolveName(result[key]).then(function (address) {\n      result[key] = address;\n      return null;\n    }));\n  }, this);\n  return Promise.all(promises).then(function () {\n    return result;\n  });\n});\nutils.defineProperty(Provider.prototype, '_getResolver', function (name) {\n  var nodeHash = utils.namehash(name); // keccak256('resolver(bytes32)')\n\n  var data = '0x0178b8bf' + nodeHash.substring(2);\n  var transaction = {\n    to: this.ensAddress,\n    data: data\n  }; // Get the resolver from the blockchain\n\n  return this.call(transaction).then(function (data) {\n    // extract the address from the data\n    if (data.length != 66) {\n      return null;\n    }\n\n    return utils.getAddress('0x' + data.substring(26));\n  });\n});\nutils.defineProperty(Provider.prototype, 'resolveName', function (name) {\n  // If it is already an address, nothing to resolve\n  try {\n    return Promise.resolve(utils.getAddress(name));\n  } catch (error) {}\n\n  if (!this.ensAddress) {\n    throw new Error('network does not have ENS deployed');\n  }\n\n  var self = this;\n  var nodeHash = utils.namehash(name); // Get the addr from the resovler\n\n  return this._getResolver(name).then(function (resolverAddress) {\n    // keccak256('addr(bytes32)')\n    var data = '0x3b3b57de' + nodeHash.substring(2);\n    var transaction = {\n      to: resolverAddress,\n      data: data\n    };\n    return self.call(transaction); // extract the address from the data\n  }).then(function (data) {\n    if (data.length != 66) {\n      return null;\n    }\n\n    var address = utils.getAddress('0x' + data.substring(26));\n\n    if (address === '0x0000000000000000000000000000000000000000') {\n      return null;\n    }\n\n    return address;\n  });\n});\nutils.defineProperty(Provider.prototype, 'lookupAddress', function (address) {\n  if (!this.ensAddress) {\n    throw new Error('network does not have ENS deployed');\n  }\n\n  address = utils.getAddress(address);\n  var name = address.substring(2) + '.addr.reverse';\n  var nodehash = utils.namehash(name);\n  var self = this;\n  return this._getResolver(name).then(function (resolverAddress) {\n    if (!resolverAddress) {\n      return null;\n    } // keccak('name(bytes32)')\n\n\n    var data = '0x691f3431' + nodehash.substring(2);\n    var transaction = {\n      to: resolverAddress,\n      data: data\n    };\n    return self.call(transaction);\n  }).then(function (data) {\n    // Strip off the \"0x\"\n    data = data.substring(2); // Strip off the dynamic string pointer (0x20)\n\n    if (data.length < 64) {\n      return null;\n    }\n\n    data = data.substring(64);\n\n    if (data.length < 64) {\n      return null;\n    }\n\n    var length = utils.bigNumberify('0x' + data.substring(0, 64)).toNumber();\n    data = data.substring(64);\n\n    if (2 * length > data.length) {\n      return null;\n    }\n\n    var name = utils.toUtf8String('0x' + data.substring(0, 2 * length)); // Make sure the reverse record matches the foward record\n\n    return self.resolveName(name).then(function (addr) {\n      if (addr != address) {\n        return null;\n      }\n\n      return name;\n    });\n  });\n});\nutils.defineProperty(Provider.prototype, 'doPoll', function () {});\nutils.defineProperty(Provider.prototype, 'perform', function (method, params) {\n  return Promise.reject(new Error('not implemented - ' + method));\n});\n\nfunction recurse(object, convertFunc) {\n  if (Array.isArray(object)) {\n    var result = [];\n    object.forEach(function (object) {\n      result.push(recurse(object, convertFunc));\n    });\n    return result;\n  }\n\n  return convertFunc(object);\n}\n\nfunction getEventString(object) {\n  try {\n    return 'address:' + utils.getAddress(object);\n  } catch (error) {}\n\n  if (object === 'block') {\n    return 'block';\n  } else if (object === 'pending') {\n    return 'pending';\n  } else if (utils.isHexString(object)) {\n    if (object.length === 66) {\n      return 'tx:' + object;\n    }\n  } else if (Array.isArray(object)) {\n    object = recurse(object, function (object) {\n      if (object == null) {\n        object = '0x';\n      }\n\n      return object;\n    });\n\n    try {\n      return 'topic:' + utils.RLP.encode(object);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  throw new Error('invalid event - ' + object);\n}\n\nfunction parseEventString(string) {\n  if (string.substring(0, 3) === 'tx:') {\n    return {\n      type: 'transaction',\n      hash: string.substring(3)\n    };\n  } else if (string === 'block') {\n    return {\n      type: 'block'\n    };\n  } else if (string === 'pending') {\n    return {\n      type: 'pending'\n    };\n  } else if (string.substring(0, 8) === 'address:') {\n    return {\n      type: 'address',\n      address: string.substring(8)\n    };\n  } else if (string.substring(0, 6) === 'topic:') {\n    try {\n      var object = utils.RLP.decode(string.substring(6));\n      object = recurse(object, function (object) {\n        if (object === '0x') {\n          object = null;\n        }\n\n        return object;\n      });\n      return {\n        type: 'topic',\n        topic: object\n      };\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  throw new Error('invalid event string');\n}\n\nutils.defineProperty(Provider.prototype, '_startPending', function () {\n  console.log('WARNING: this provider does not support pending events');\n});\nutils.defineProperty(Provider.prototype, '_stopPending', function () {});\nutils.defineProperty(Provider.prototype, 'on', function (eventName, listener) {\n  var key = getEventString(eventName);\n\n  if (!this._events[key]) {\n    this._events[key] = [];\n  }\n\n  this._events[key].push({\n    eventName: eventName,\n    listener: listener,\n    type: 'on'\n  });\n\n  if (key === 'pending') {\n    this._startPending();\n  }\n\n  this.polling = true;\n});\nutils.defineProperty(Provider.prototype, 'once', function (eventName, listener) {\n  var key = getEventString(eventName);\n\n  if (!this._events[key]) {\n    this._events[key] = [];\n  }\n\n  this._events[key].push({\n    eventName: eventName,\n    listener: listener,\n    type: 'once'\n  });\n\n  if (key === 'pending') {\n    this._startPending();\n  }\n\n  this.polling = true;\n});\nutils.defineProperty(Provider.prototype, 'emit', function (eventName) {\n  var key = getEventString(eventName);\n  var args = Array.prototype.slice.call(arguments, 1);\n  var listeners = this._events[key];\n\n  if (!listeners) {\n    return;\n  }\n\n  for (var i = 0; i < listeners.length; i++) {\n    var listener = listeners[i];\n\n    if (listener.type === 'once') {\n      listeners.splice(i, 1);\n      i--;\n    }\n\n    try {\n      listener.listener.apply(this, args);\n    } catch (error) {\n      console.log('Event Listener Error: ' + error.message);\n    }\n  }\n\n  if (listeners.length === 0) {\n    delete this._events[key];\n\n    if (key === 'pending') {\n      this._stopPending();\n    }\n  }\n\n  if (this.listenerCount() === 0) {\n    this.polling = false;\n  }\n});\nutils.defineProperty(Provider.prototype, 'listenerCount', function (eventName) {\n  if (!eventName) {\n    var result = 0;\n\n    for (var key in this._events) {\n      result += this._events[key].length;\n    }\n\n    return result;\n  }\n\n  var listeners = this._events[getEventString(eventName)];\n\n  if (!listeners) {\n    return 0;\n  }\n\n  return listeners.length;\n});\nutils.defineProperty(Provider.prototype, 'listeners', function (eventName) {\n  var listeners = this._events[getEventString(eventName)];\n\n  if (!listeners) {\n    return 0;\n  }\n\n  var result = [];\n\n  for (var i = 0; i < listeners.length; i++) {\n    result.push(listeners[i].listener);\n  }\n\n  return result;\n});\nutils.defineProperty(Provider.prototype, 'removeAllListeners', function (eventName) {\n  delete this._events[getEventString(eventName)];\n\n  if (this.listenerCount() === 0) {\n    this.polling = false;\n  }\n});\nutils.defineProperty(Provider.prototype, 'removeListener', function (eventName, listener) {\n  var eventNameString = getEventString(eventName);\n  var listeners = this._events[eventNameString];\n\n  if (!listeners) {\n    return 0;\n  }\n\n  for (var i = 0; i < listeners.length; i++) {\n    if (listeners[i].listener === listener) {\n      listeners.splice(i, 1);\n      break;\n    }\n  }\n\n  if (listeners.length === 0) {\n    this.removeAllListeners(eventName);\n  }\n});\nutils.defineProperty(Provider, '_formatters', {\n  checkTransactionResponse: checkTransaction\n});\nmodule.exports = Provider;","map":null,"metadata":{},"sourceType":"script"}