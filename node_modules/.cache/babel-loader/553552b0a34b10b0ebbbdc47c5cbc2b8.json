{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('events');\n\nvar Stat = require('./stat');\n\nvar OldPeers = require('./old-peers');\n\nvar defaultOptions = {\n  computeThrottleMaxQueueSize: 1000,\n  computeThrottleTimeout: 2000,\n  movingAverageIntervals: [60 * 1000, // 1 minute\n  5 * 60 * 1000, // 5 minutes\n  15 * 60 * 1000 // 15 minutes\n  ],\n  maxOldPeersRetention: 50\n};\nvar initialCounters = ['dataReceived', 'dataSent'];\nvar directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n  /**\n   * Binds to message events on the given `observer` to generate stats\n   * based on the Peer, Protocol and Transport used for the message. Stat\n   * events will be emitted via the `update` event.\n   *\n   * @param {Observer} observer\n   * @param {any} _options\n   * @returns {Stats}\n   */\n\n};\n\nmodule.exports = function (observer, _options) {\n  var options = Object.assign({}, defaultOptions, _options);\n  var globalStats = new Stat(initialCounters, options);\n  var stats = Object.assign(new EventEmitter(), {\n    stop: stop,\n    global: globalStats,\n    peers: function peers() {\n      return Array.from(peerStats.keys());\n    },\n    forPeer: function forPeer(peerId) {\n      return peerStats.get(peerId) || oldPeers.get(peerId);\n    },\n    transports: function transports() {\n      return Array.from(transportStats.keys());\n    },\n    forTransport: function forTransport(transport) {\n      return transportStats.get(transport);\n    },\n    protocols: function protocols() {\n      return Array.from(protocolStats.keys());\n    },\n    forProtocol: function forProtocol(protocol) {\n      return protocolStats.get(protocol);\n    }\n  });\n  globalStats.on('update', propagateChange);\n  var oldPeers = OldPeers(options.maxOldPeersRetention);\n  var peerStats = new Map();\n  var transportStats = new Map();\n  var protocolStats = new Map();\n  observer.on('message', function (peerId, transportTag, protocolTag, direction, bufferLength) {\n    var event = directionToEvent[direction];\n\n    if (transportTag) {\n      // because it has a transport tag, this message is at the global level, so we account this\n      // traffic as global.\n      globalStats.push(event, bufferLength); // peer stats\n\n      var peer = peerStats.get(peerId);\n\n      if (!peer) {\n        peer = oldPeers.get(peerId);\n\n        if (peer) {\n          oldPeers.delete(peerId);\n        } else {\n          peer = new Stat(initialCounters, options);\n        }\n\n        peer.on('update', propagateChange);\n        peer.start();\n        peerStats.set(peerId, peer);\n      }\n\n      peer.push(event, bufferLength);\n    } // transport stats\n\n\n    if (transportTag) {\n      var transport = transportStats.get(transportTag);\n\n      if (!transport) {\n        transport = new Stat(initialCounters, options);\n        transport.on('update', propagateChange);\n        transportStats.set(transportTag, transport);\n      }\n\n      transport.push(event, bufferLength);\n    } // protocol stats\n\n\n    if (protocolTag) {\n      var protocol = protocolStats.get(protocolTag);\n\n      if (!protocol) {\n        protocol = new Stat(initialCounters, options);\n        protocol.on('update', propagateChange);\n        protocolStats.set(protocolTag, protocol);\n      }\n\n      protocol.push(event, bufferLength);\n    }\n  });\n  observer.on('peer:closed', function (peerId) {\n    var peer = peerStats.get(peerId);\n\n    if (peer) {\n      peer.removeListener('update', propagateChange);\n      peer.stop();\n      peerStats.delete(peerId);\n      oldPeers.set(peerId, peer);\n    }\n  });\n  return stats;\n\n  function stop() {\n    globalStats.stop();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = peerStats.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var peerStat = _step.value;\n        peerStat.stop();\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = transportStats.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var transportStat = _step2.value;\n        transportStat.stop();\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n\n  function propagateChange() {\n    stats.emit('update');\n  }\n};","map":null,"metadata":{},"sourceType":"script"}