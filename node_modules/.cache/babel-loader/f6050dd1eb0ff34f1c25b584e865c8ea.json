{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 5] */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar sanitize = require('sanitize-filename');\n\nvar mergeOptions = require('merge-options');\n\nvar crypto = require('libp2p-crypto');\n\nvar DS = require('interface-datastore');\n\nvar collect = require('pull-stream/sinks/collect');\n\nvar pull = require('pull-stream/pull');\n\nvar CMS = require('./cms');\n\nvar keyPrefix = '/pkcs8/';\nvar infoPrefix = '/info/'; // NIST SP 800-132\n\nvar NIST = {\n  minKeyLength: 112 / 8,\n  minSaltLength: 128 / 8,\n  minIterationCount: 1000\n};\nvar defaultOptions = {\n  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n  dek: {\n    keyLength: 512 / 8,\n    iterationCount: 10000,\n    salt: 'you should override this value with a crypto secure random number',\n    hash: 'sha2-512'\n  }\n};\n\nfunction validateKeyName(name) {\n  if (!name) return false;\n  if (typeof name !== 'string') return false;\n  return name === sanitize(name.trim());\n}\n/**\n * Returns an error to the caller, after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n *\n * @param {function(Error)} callback - The caller\n * @param {string | Error} err - The error\n * @returns {undefined}\n * @private\n */\n\n\nfunction _error(callback, err) {\n  var min = 200;\n  var max = 1000;\n  var delay = Math.random() * (max - min) + min;\n  if (typeof err === 'string') err = new Error(err);\n  setTimeout(callback, delay, err, null);\n}\n/**\n * Converts a key name into a datastore name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\n\n\nfunction DsName(name) {\n  return new DS.Key(keyPrefix + name);\n}\n/**\n * Converts a key name into a datastore info name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\n\n\nfunction DsInfoName(name) {\n  return new DS.Key(infoPrefix + name);\n}\n/**\n * Information about a key.\n *\n * @typedef {Object} KeyInfo\n *\n * @property {string} id - The universally unique key id.\n * @property {string} name - The local key name.\n */\n\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\n\n\nvar Keychain =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates a new instance of a key chain.\n   *\n   * @param {DS} store - where the key are.\n   * @param {object} options - ???\n   */\n  function Keychain(store, options) {\n    _classCallCheck(this, Keychain);\n\n    if (!store) {\n      throw new Error('store is required');\n    }\n\n    this.store = store;\n    var opts = mergeOptions(defaultOptions, options); // Enforce NIST SP 800-132\n\n    if (!opts.passPhrase || opts.passPhrase.length < 20) {\n      throw new Error('passPhrase must be least 20 characters');\n    }\n\n    if (opts.dek.keyLength < NIST.minKeyLength) {\n      throw new Error(\"dek.keyLength must be least \".concat(NIST.minKeyLength, \" bytes\"));\n    }\n\n    if (opts.dek.salt.length < NIST.minSaltLength) {\n      throw new Error(\"dek.saltLength must be least \".concat(NIST.minSaltLength, \" bytes\"));\n    }\n\n    if (opts.dek.iterationCount < NIST.minIterationCount) {\n      throw new Error(\"dek.iterationCount must be least \".concat(NIST.minIterationCount));\n    } // Create the derived encrypting key\n\n\n    var dek = crypto.pbkdf2(opts.passPhrase, opts.dek.salt, opts.dek.iterationCount, opts.dek.keyLength, opts.dek.hash);\n    Object.defineProperty(this, '_', {\n      value: function value() {\n        return dek;\n      }\n    });\n  }\n  /**\n   * Gets an object that can encrypt/decrypt protected data\n   * using the Cryptographic Message Syntax (CMS).\n   *\n   * CMS describes an encapsulation syntax for data protection. It\n   * is used to digitally sign, digest, authenticate, or encrypt\n   * arbitrary message content.\n   *\n   * @returns {CMS}\n   */\n\n\n  _createClass(Keychain, [{\n    key: \"createKey\",\n\n    /**\n     * Create a new key.\n     *\n     * @param {string} name - The local key name; cannot already exist.\n     * @param {string} type - One of the key types; 'rsa'.\n     * @param {int} size - The key size in bits.\n     * @param {function(Error, KeyInfo)} callback\n     * @returns {undefined}\n     */\n    value: function createKey(name, type, size, callback) {\n      var _this = this;\n\n      var self = this;\n\n      if (!validateKeyName(name) || name === 'self') {\n        return _error(callback, \"Invalid key name '\".concat(name, \"'\"));\n      }\n\n      if (typeof type !== 'string') {\n        return _error(callback, \"Invalid key type '\".concat(type, \"'\"));\n      }\n\n      if (!Number.isSafeInteger(size)) {\n        return _error(callback, \"Invalid key size '\".concat(size, \"'\"));\n      }\n\n      var dsname = DsName(name);\n      self.store.has(dsname, function (err, exists) {\n        if (err) return _error(callback, err);\n        if (exists) return _error(callback, \"Key '\".concat(name, \"' already exists\"));\n\n        switch (type.toLowerCase()) {\n          case 'rsa':\n            if (size < 2048) {\n              return _error(callback, \"Invalid RSA key size \".concat(size));\n            }\n\n            break;\n\n          default:\n            break;\n        }\n\n        crypto.keys.generateKeyPair(type, size, function (err, keypair) {\n          if (err) return _error(callback, err);\n          keypair.id(function (err, kid) {\n            if (err) return _error(callback, err);\n            keypair.export(_this._(), function (err, pem) {\n              if (err) return _error(callback, err);\n              var keyInfo = {\n                name: name,\n                id: kid\n              };\n              var batch = self.store.batch();\n              batch.put(dsname, pem);\n              batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n              batch.commit(function (err) {\n                if (err) return _error(callback, err);\n                callback(null, keyInfo);\n              });\n            });\n          });\n        });\n      });\n    }\n    /**\n     * List all the keys.\n     *\n     * @param {function(Error, KeyInfo[])} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"listKeys\",\n    value: function listKeys(callback) {\n      var self = this;\n      var query = {\n        prefix: infoPrefix\n      };\n      pull(self.store.query(query), collect(function (err, res) {\n        if (err) return _error(callback, err);\n        var info = res.map(function (r) {\n          return JSON.parse(r.value);\n        });\n        callback(null, info);\n      }));\n    }\n    /**\n     * Find a key by it's id.\n     *\n     * @param {string} id - The universally unique key identifier.\n     * @param {function(Error, KeyInfo)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"findKeyById\",\n    value: function findKeyById(id, callback) {\n      this.listKeys(function (err, keys) {\n        if (err) return _error(callback, err);\n        var key = keys.find(function (k) {\n          return k.id === id;\n        });\n        callback(null, key);\n      });\n    }\n    /**\n     * Find a key by it's name.\n     *\n     * @param {string} name - The local key name.\n     * @param {function(Error, KeyInfo)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"findKeyByName\",\n    value: function findKeyByName(name, callback) {\n      if (!validateKeyName(name)) {\n        return _error(callback, \"Invalid key name '\".concat(name, \"'\"));\n      }\n\n      var dsname = DsInfoName(name);\n      this.store.get(dsname, function (err, res) {\n        if (err) {\n          return _error(callback, \"Key '\".concat(name, \"' does not exist. \").concat(err.message));\n        }\n\n        callback(null, JSON.parse(res.toString()));\n      });\n    }\n    /**\n     * Remove an existing key.\n     *\n     * @param {string} name - The local key name; must already exist.\n     * @param {function(Error, KeyInfo)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"removeKey\",\n    value: function removeKey(name, callback) {\n      var self = this;\n\n      if (!validateKeyName(name) || name === 'self') {\n        return _error(callback, \"Invalid key name '\".concat(name, \"'\"));\n      }\n\n      var dsname = DsName(name);\n      self.findKeyByName(name, function (err, keyinfo) {\n        if (err) return _error(callback, err);\n        var batch = self.store.batch();\n        batch.delete(dsname);\n        batch.delete(DsInfoName(name));\n        batch.commit(function (err) {\n          if (err) return _error(callback, err);\n          callback(null, keyinfo);\n        });\n      });\n    }\n    /**\n     * Rename a key\n     *\n     * @param {string} oldName - The old local key name; must already exist.\n     * @param {string} newName - The new local key name; must not already exist.\n     * @param {function(Error, KeyInfo)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"renameKey\",\n    value: function renameKey(oldName, newName, callback) {\n      var self = this;\n\n      if (!validateKeyName(oldName) || oldName === 'self') {\n        return _error(callback, \"Invalid old key name '\".concat(oldName, \"'\"));\n      }\n\n      if (!validateKeyName(newName) || newName === 'self') {\n        return _error(callback, \"Invalid new key name '\".concat(newName, \"'\"));\n      }\n\n      var oldDsname = DsName(oldName);\n      var newDsname = DsName(newName);\n      var oldInfoName = DsInfoName(oldName);\n      var newInfoName = DsInfoName(newName);\n      this.store.get(oldDsname, function (err, res) {\n        if (err) {\n          return _error(callback, \"Key '\".concat(oldName, \"' does not exist. \").concat(err.message));\n        }\n\n        var pem = res.toString();\n        self.store.has(newDsname, function (err, exists) {\n          if (err) return _error(callback, err);\n          if (exists) return _error(callback, \"Key '\".concat(newName, \"' already exists\"));\n          self.store.get(oldInfoName, function (err, res) {\n            if (err) return _error(callback, err);\n            var keyInfo = JSON.parse(res.toString());\n            keyInfo.name = newName;\n            var batch = self.store.batch();\n            batch.put(newDsname, pem);\n            batch.put(newInfoName, JSON.stringify(keyInfo));\n            batch.delete(oldDsname);\n            batch.delete(oldInfoName);\n            batch.commit(function (err) {\n              if (err) return _error(callback, err);\n              callback(null, keyInfo);\n            });\n          });\n        });\n      });\n    }\n    /**\n     * Export an existing key as a PEM encrypted PKCS #8 string\n     *\n     * @param {string} name - The local key name; must already exist.\n     * @param {string} password - The password\n     * @param {function(Error, string)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"exportKey\",\n    value: function exportKey(name, password, callback) {\n      var _this2 = this;\n\n      if (!validateKeyName(name)) {\n        return _error(callback, \"Invalid key name '\".concat(name, \"'\"));\n      }\n\n      if (!password) {\n        return _error(callback, 'Password is required');\n      }\n\n      var dsname = DsName(name);\n      this.store.get(dsname, function (err, res) {\n        if (err) {\n          return _error(callback, \"Key '\".concat(name, \"' does not exist. \").concat(err.message));\n        }\n\n        var pem = res.toString();\n        crypto.keys.import(pem, _this2._(), function (err, privateKey) {\n          if (err) return _error(callback, err);\n          privateKey.export(password, callback);\n        });\n      });\n    }\n    /**\n     * Import a new key from a PEM encoded PKCS #8 string\n     *\n     * @param {string} name - The local key name; must not already exist.\n     * @param {string} pem - The PEM encoded PKCS #8 string\n     * @param {string} password - The password.\n     * @param {function(Error, KeyInfo)} callback\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"importKey\",\n    value: function importKey(name, pem, password, callback) {\n      var _this3 = this;\n\n      var self = this;\n\n      if (!validateKeyName(name) || name === 'self') {\n        return _error(callback, \"Invalid key name '\".concat(name, \"'\"));\n      }\n\n      if (!pem) {\n        return _error(callback, 'PEM encoded key is required');\n      }\n\n      var dsname = DsName(name);\n      self.store.has(dsname, function (err, exists) {\n        if (err) return _error(callback, err);\n        if (exists) return _error(callback, \"Key '\".concat(name, \"' already exists\"));\n        crypto.keys.import(pem, password, function (err, privateKey) {\n          if (err) return _error(callback, 'Cannot read the key, most likely the password is wrong');\n          privateKey.id(function (err, kid) {\n            if (err) return _error(callback, err);\n            privateKey.export(_this3._(), function (err, pem) {\n              if (err) return _error(callback, err);\n              var keyInfo = {\n                name: name,\n                id: kid\n              };\n              var batch = self.store.batch();\n              batch.put(dsname, pem);\n              batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n              batch.commit(function (err) {\n                if (err) return _error(callback, err);\n                callback(null, keyInfo);\n              });\n            });\n          });\n        });\n      });\n    }\n  }, {\n    key: \"importPeer\",\n    value: function importPeer(name, peer, callback) {\n      var _this4 = this;\n\n      var self = this;\n\n      if (!validateKeyName(name)) {\n        return _error(callback, \"Invalid key name '\".concat(name, \"'\"));\n      }\n\n      if (!peer || !peer.privKey) {\n        return _error(callback, 'Peer.privKey is required');\n      }\n\n      var privateKey = peer.privKey;\n      var dsname = DsName(name);\n      self.store.has(dsname, function (err, exists) {\n        if (err) return _error(callback, err);\n        if (exists) return _error(callback, \"Key '\".concat(name, \"' already exists\"));\n        privateKey.id(function (err, kid) {\n          if (err) return _error(callback, err);\n          privateKey.export(_this4._(), function (err, pem) {\n            if (err) return _error(callback, err);\n            var keyInfo = {\n              name: name,\n              id: kid\n            };\n            var batch = self.store.batch();\n            batch.put(dsname, pem);\n            batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n            batch.commit(function (err) {\n              if (err) return _error(callback, err);\n              callback(null, keyInfo);\n            });\n          });\n        });\n      });\n    }\n    /**\n     * Gets the private key as PEM encoded PKCS #8 string.\n     *\n     * @param {string} name\n     * @param {function(Error, string)} callback\n     * @returns {undefined}\n     * @private\n     */\n\n  }, {\n    key: \"_getPrivateKey\",\n    value: function _getPrivateKey(name, callback) {\n      if (!validateKeyName(name)) {\n        return _error(callback, \"Invalid key name '\".concat(name, \"'\"));\n      }\n\n      this.store.get(DsName(name), function (err, res) {\n        if (err) {\n          return _error(callback, \"Key '\".concat(name, \"' does not exist. \").concat(err.message));\n        }\n\n        callback(null, res.toString());\n      });\n    }\n  }, {\n    key: \"cms\",\n    get: function get() {\n      return new CMS(this);\n    }\n    /**\n     * Generates the options for a keychain.  A random salt is produced.\n     *\n     * @returns {object}\n     */\n\n  }], [{\n    key: \"generateOptions\",\n    value: function generateOptions() {\n      var options = Object.assign({}, defaultOptions);\n      var saltLength = Math.ceil(NIST.minSaltLength / 3) * 3; // no base64 padding\n\n      options.dek.salt = crypto.randomBytes(saltLength).toString('base64');\n      return options;\n    }\n    /**\n     * Gets an object that can encrypt/decrypt protected data.\n     * The default options for a keychain.\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: \"options\",\n    get: function get() {\n      return defaultOptions;\n    }\n  }]);\n\n  return Keychain;\n}();\n\nmodule.exports = Keychain;","map":null,"metadata":{},"sourceType":"script"}