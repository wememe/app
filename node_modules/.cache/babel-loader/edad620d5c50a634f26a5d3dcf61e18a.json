{"ast":null,"code":"var Common = require('ethereumjs-common');\n\nvar utils = require('ethereumjs-util');\n\nvar BN = utils.BN;\n/**\n * An object that repersents the block header\n * @constructor\n * @param {Array} data raw data, deserialized\n * @param {Array} opts Options\n * @param {String|Number} opts.chain The chain for the block header [default: 'mainnet']\n * @param {String} opts.hardfork Hardfork for the block header [default: null, block number-based behaviour]\n * @param {Object} opts.common Alternatively pass a Common instance instead of setting chain/hardfork directly\n * @prop {Buffer} parentHash the blocks' parent's hash\n * @prop {Buffer} uncleHash sha3(rlp_encode(uncle_list))\n * @prop {Buffer} coinbase the miner address\n * @prop {Buffer} stateRoot The root of a Merkle Patricia tree\n * @prop {Buffer} transactionTrie the root of a Trie containing the transactions\n * @prop {Buffer} receiptTrie the root of a Trie containing the transaction Reciept\n * @prop {Buffer} bloom\n * @prop {Buffer} difficulty\n * @prop {Buffer} number the block's height\n * @prop {Buffer} gasLimit\n * @prop {Buffer} gasUsed\n * @prop {Buffer} timestamp\n * @prop {Buffer} extraData\n * @prop {Array.<Buffer>} raw an array of buffers containing the raw blocks.\n */\n\nvar BlockHeader = module.exports = function (data, opts) {\n  opts = opts || {};\n\n  if (opts.common) {\n    if (opts.chain) {\n      throw new Error('Instantiation with both opts.common and opts.chain parameter not allowed!');\n    }\n\n    this._common = opts.common;\n  } else {\n    var chain = opts.chain ? opts.chain : 'mainnet';\n    var hardfork = opts.hardfork ? opts.hardfork : null;\n    this._common = new Common(chain, hardfork);\n  }\n\n  var fields = [{\n    name: 'parentHash',\n    length: 32,\n    default: utils.zeros(32)\n  }, {\n    name: 'uncleHash',\n    default: utils.SHA3_RLP_ARRAY\n  }, {\n    name: 'coinbase',\n    length: 20,\n    default: utils.zeros(20)\n  }, {\n    name: 'stateRoot',\n    length: 32,\n    default: utils.zeros(32)\n  }, {\n    name: 'transactionsTrie',\n    length: 32,\n    default: utils.SHA3_RLP\n  }, {\n    name: 'receiptTrie',\n    length: 32,\n    default: utils.SHA3_RLP\n  }, {\n    name: 'bloom',\n    default: utils.zeros(256)\n  }, {\n    name: 'difficulty',\n    default: new Buffer([])\n  }, {\n    name: 'number',\n    // TODO: params.homeSteadForkNumber.v left for legacy reasons, replace on future release\n    default: utils.intToBuffer(1150000)\n  }, {\n    name: 'gasLimit',\n    default: new Buffer('ffffffffffffff', 'hex')\n  }, {\n    name: 'gasUsed',\n    empty: true,\n    default: new Buffer([])\n  }, {\n    name: 'timestamp',\n    default: new Buffer([])\n  }, {\n    name: 'extraData',\n    allowZero: true,\n    empty: true,\n    default: new Buffer([])\n  }, {\n    name: 'mixHash',\n    default: utils.zeros(32) // length: 32\n\n  }, {\n    name: 'nonce',\n    default: utils.zeros(8) // sha3(42)\n\n  }];\n  utils.defineProperties(this, fields, data);\n};\n/**\n * Returns the canoncical difficulty of the block\n * @method canonicalDifficulty\n * @param {Block} parentBlock the parent `Block` of the this header\n * @return {BN}\n */\n\n\nBlockHeader.prototype.canonicalDifficulty = function (parentBlock) {\n  var hardfork = this._common.hardfork() || this._common.activeHardfork(utils.bufferToInt(this.number));\n\n  var blockTs = new BN(this.timestamp);\n  var parentTs = new BN(parentBlock.header.timestamp);\n  var parentDif = new BN(parentBlock.header.difficulty);\n  var minimumDifficulty = new BN(this._common.param('pow', 'minimumDifficulty', hardfork));\n  var offset = parentDif.div(new BN(this._common.param('pow', 'difficultyBoundDivisor', hardfork)));\n  var num = new BN(this.number);\n  var a;\n  var cutoff;\n  var dif;\n\n  if (this._common.hardforkGteHardfork(hardfork, 'byzantium')) {\n    // max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) // 9), -99) (EIP100)\n    var uncleAddend = parentBlock.header.uncleHash.equals(utils.SHA3_RLP_ARRAY) ? 1 : 2;\n    a = blockTs.sub(parentTs).idivn(9).ineg().iaddn(uncleAddend);\n    cutoff = new BN(-99); // MAX(cutoff, a)\n\n    if (cutoff.cmp(a) === 1) {\n      a = cutoff;\n    }\n\n    dif = parentDif.add(offset.mul(a));\n  }\n\n  if (this._common.hardforkGteHardfork(hardfork, 'constantinople')) {\n    // Constantinople difficulty bomb delay (EIP1234)\n    num.isubn(5000000);\n\n    if (num.ltn(0)) {\n      num = new BN(0);\n    }\n  } else if (this._common.hardforkGteHardfork(hardfork, 'byzantium')) {\n    // Byzantium difficulty bomb delay (EIP649)\n    num.isubn(3000000);\n\n    if (num.ltn(0)) {\n      num = new BN(0);\n    }\n  } else if (this._common.hardforkGteHardfork(hardfork, 'homestead')) {\n    // 1 - (block_timestamp - parent_timestamp) // 10\n    a = blockTs.sub(parentTs).idivn(10).ineg().iaddn(1);\n    cutoff = new BN(-99); // MAX(cutoff, a)\n\n    if (cutoff.cmp(a) === 1) {\n      a = cutoff;\n    }\n\n    dif = parentDif.add(offset.mul(a));\n  } else {\n    // pre-homestead\n    if (parentTs.addn(this._common.param('pow', 'durationLimit', hardfork)).cmp(blockTs) === 1) {\n      dif = offset.add(parentDif);\n    } else {\n      dif = parentDif.sub(offset);\n    }\n  }\n\n  var exp = num.idivn(100000).isubn(2);\n\n  if (!exp.isNeg()) {\n    dif.iadd(new BN(2).pow(exp));\n  }\n\n  if (dif.cmp(minimumDifficulty) === -1) {\n    dif = minimumDifficulty;\n  }\n\n  return dif;\n};\n/**\n * checks that the block's `difficuly` matches the canonical difficulty\n * @method validateDifficulty\n * @param {Block} parentBlock this block's parent\n * @return {Boolean}\n */\n\n\nBlockHeader.prototype.validateDifficulty = function (parentBlock) {\n  var dif = this.canonicalDifficulty(parentBlock);\n  return dif.cmp(new BN(this.difficulty)) === 0;\n};\n/**\n * Validates the gasLimit\n * @method validateGasLimit\n * @param {Block} parentBlock this block's parent\n * @returns {Boolean}\n */\n\n\nBlockHeader.prototype.validateGasLimit = function (parentBlock) {\n  var pGasLimit = new BN(parentBlock.header.gasLimit);\n  var gasLimit = new BN(this.gasLimit);\n  var hardfork = this._common.hardfork() ? this._common.hardfork() : this._common.activeHardfork(this.number);\n  var a = pGasLimit.div(new BN(this._common.param('gasConfig', 'gasLimitBoundDivisor', hardfork)));\n  var maxGasLimit = pGasLimit.add(a);\n  var minGasLimit = pGasLimit.sub(a);\n  return gasLimit.lt(maxGasLimit) && gasLimit.gt(minGasLimit) && gasLimit.gte(this._common.param('gasConfig', 'minGasLimit', hardfork));\n};\n/**\n * Validates the entire block header\n * @method validate\n * @param {Blockchain} blockChain the blockchain that this block is validating against\n * @param {Bignum} [height] if this is an uncle header, this is the height of the block that is including it\n * @param {Function} cb the callback function. The callback is given an `error` if the block is invalid\n */\n\n\nBlockHeader.prototype.validate = function (blockchain, height, cb) {\n  var self = this;\n\n  if (arguments.length === 2) {\n    cb = height;\n    height = false;\n  }\n\n  if (this.isGenesis()) {\n    return cb();\n  } // find the blocks parent\n\n\n  blockchain.getBlock(self.parentHash, function (err, parentBlock) {\n    if (err) {\n      return cb('could not find parent block');\n    }\n\n    self.parentBlock = parentBlock;\n    var number = new BN(self.number);\n\n    if (number.cmp(new BN(parentBlock.header.number).iaddn(1)) !== 0) {\n      return cb('invalid number');\n    }\n\n    if (height) {\n      var dif = height.sub(new BN(parentBlock.header.number));\n\n      if (!(dif.cmpn(8) === -1 && dif.cmpn(1) === 1)) {\n        return cb('uncle block has a parent that is too old or to young');\n      }\n    }\n\n    if (!self.validateDifficulty(parentBlock)) {\n      return cb('invalid Difficulty');\n    }\n\n    if (!self.validateGasLimit(parentBlock)) {\n      return cb('invalid gas limit');\n    }\n\n    if (utils.bufferToInt(parentBlock.header.number) + 1 !== utils.bufferToInt(self.number)) {\n      return cb('invalid heigth');\n    }\n\n    if (utils.bufferToInt(self.timestamp) <= utils.bufferToInt(parentBlock.header.timestamp)) {\n      return cb('invalid timestamp');\n    }\n\n    var hardfork = self._common.hardfork() ? self._common.hardfork() : self._common.activeHardfork(height);\n\n    if (self.extraData.length > self._common.param('vm', 'maxExtraDataSize', hardfork)) {\n      return cb('invalid amount of extra data');\n    }\n\n    cb();\n  });\n};\n/**\n * Returns the sha3 hash of the blockheader\n * @method hash\n * @return {Buffer}\n */\n\n\nBlockHeader.prototype.hash = function () {\n  return utils.rlphash(this.raw);\n};\n/**\n * checks if the blockheader is a genesis header\n * @method isGenesis\n * @return {Boolean}\n */\n\n\nBlockHeader.prototype.isGenesis = function () {\n  return this.number.toString('hex') === '';\n};\n/**\n * turns the header into the canonical genesis block header\n * @method setGenesisParams\n */\n\n\nBlockHeader.prototype.setGenesisParams = function () {\n  this.timestamp = this._common.genesis().timestamp;\n  this.gasLimit = this._common.genesis().gasLimit;\n  this.difficulty = this._common.genesis().difficulty;\n  this.extraData = this._common.genesis().extraData;\n  this.nonce = this._common.genesis().nonce;\n  this.stateRoot = this._common.genesis().stateRoot;\n  this.number = new Buffer([]);\n};","map":null,"metadata":{},"sourceType":"script"}