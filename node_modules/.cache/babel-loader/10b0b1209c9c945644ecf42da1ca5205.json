{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar waterfall = require('async/waterfall');\n\nvar parallel = require('async/parallel');\n\nvar series = require('async/series');\n\nvar UnixFs = require('ipfs-unixfs');\n\nvar _require = require('./utils'),\n    traverseTo = _require.traverseTo,\n    addLink = _require.addLink,\n    updateTree = _require.updateTree,\n    updateMfsRoot = _require.updateMfsRoot,\n    toSourcesAndDestination = _require.toSourcesAndDestination;\n\nvar stat = require('./stat');\n\nvar log = require('debug')('ipfs:mfs:cp');\n\nvar defaultOptions = {\n  parents: false,\n  flush: true,\n  format: 'dag-pb',\n  hashAlg: 'sha2-256'\n};\n\nmodule.exports = function (ipfs) {\n  return function mfsCp() {\n    var args = Array.from(arguments);\n\n    var _toSourcesAndDestinat = toSourcesAndDestination(args, defaultOptions),\n        sources = _toSourcesAndDestinat.sources,\n        destination = _toSourcesAndDestinat.destination,\n        options = _toSourcesAndDestinat.options,\n        callback = _toSourcesAndDestinat.callback;\n\n    if (!sources.length) {\n      return callback(new Error('Please supply at least one source'));\n    }\n\n    if (!destination) {\n      return callback(new Error('Please supply a destination'));\n    }\n\n    options.parents = options.p || options.parents;\n    traverseTo(ipfs, destination.path, {}, function (error, result) {\n      if (error) {\n        if (sources.length === 1) {\n          log('Only one source, copying to a file');\n          return copyToFile(ipfs, sources.pop(), destination, options, callback);\n        } else {\n          log('Multiple sources, copying to a directory');\n          return copyToDirectory(ipfs, sources, destination, options, callback);\n        }\n      }\n\n      var meta = UnixFs.unmarshal(result.node.data);\n\n      if (meta.type === 'directory') {\n        return copyToDirectory(ipfs, sources, destination, options, callback);\n      }\n\n      callback(new Error('directory already has entry by that name'));\n    });\n  };\n};\n\nvar copyToFile = function copyToFile(ipfs, source, destination, options, callback) {\n  waterfall([function (cb) {\n    parallel([function (next) {\n      return stat(ipfs)(source.path, options, next);\n    }, function (next) {\n      return stat(ipfs)(destination.path, options, function (error) {\n        if (!error) {\n          return next(new Error('directory already has entry by that name'));\n        }\n\n        next();\n      });\n    }, function (next) {\n      return traverseTo(ipfs, destination.dir, options, next);\n    }], cb);\n  }, function (_ref, cb) {\n    var _ref2 = _slicedToArray(_ref, 3),\n        sourceStats = _ref2[0],\n        _ = _ref2[1],\n        dest = _ref2[2];\n\n    waterfall([function (next) {\n      return addLink(ipfs, {\n        parent: dest.node,\n        child: {\n          size: sourceStats.cumulativeSize,\n          hash: sourceStats.hash\n        },\n        name: destination.name\n      }, next);\n    }, function (newParent, next) {\n      dest.node = newParent;\n      updateTree(ipfs, dest, next);\n    }, function (newRoot, cb) {\n      return updateMfsRoot(ipfs, newRoot.node.multihash, cb);\n    }], cb);\n  }], function (error) {\n    return callback(error);\n  });\n};\n\nvar copyToDirectory = function copyToDirectory(ipfs, sources, destination, options, callback) {\n  waterfall([function (cb) {\n    series([// stat in parallel\n    function (done) {\n      return parallel(sources.map(function (source) {\n        return function (next) {\n          return stat(ipfs)(source.path, options, next);\n        };\n      }), done);\n    }, // this could end up changing the root mfs node so do it after parallel\n    function (done) {\n      return traverseTo(ipfs, destination.path, Object.assign({}, options, {\n        createLastComponent: true\n      }), done);\n    }], cb);\n  }, function (results, cb) {\n    var dest = results.pop();\n    var sourceStats = results[0];\n    waterfall([// ensure targets do not exist\n    function (next) {\n      parallel(sources.map(function (source) {\n        return function (cb) {\n          stat(ipfs)(\"\".concat(destination.path, \"/\").concat(source.name), options, function (error) {\n            if (!error) {\n              return cb(new Error('directory already has entry by that name'));\n            }\n\n            cb();\n          });\n        };\n      }), function (error) {\n        return next(error);\n      });\n    }, // add links to target directory\n    function (next) {\n      waterfall([function (done) {\n        return done(null, dest.node);\n      }].concat(sourceStats.map(function (sourceStat, index) {\n        return function (dest, done) {\n          return addLink(ipfs, {\n            parent: dest,\n            child: {\n              size: sourceStat.cumulativeSize,\n              hash: sourceStat.hash\n            },\n            name: sources[index].name\n          }, done);\n        };\n      })), next);\n    }, // update mfs tree\n    function (newParent, next) {\n      dest.node = newParent;\n      updateTree(ipfs, dest, next);\n    }, // save new root CID\n    function (newRoot, cb) {\n      return updateMfsRoot(ipfs, newRoot.node.multihash, cb);\n    }], cb);\n  }], function (error) {\n    return callback(error);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}