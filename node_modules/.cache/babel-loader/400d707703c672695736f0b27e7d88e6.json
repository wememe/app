{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar constants_1 = require(\"./constants\");\n\nvar errors = __importStar(require(\"./errors\"));\n\nvar abi_coder_1 = require(\"./utils/abi-coder\");\n\nvar address_1 = require(\"./utils/address\");\n\nvar bignumber_1 = require(\"./utils/bignumber\");\n\nvar bytes_1 = require(\"./utils/bytes\");\n\nvar interface_1 = require(\"./utils/interface\");\n\nvar properties_1 = require(\"./utils/properties\"); ///////////////////////////////\n// Imported Abstracts\n\n\nvar abstract_provider_1 = require(\"./providers/abstract-provider\");\n\nvar abstract_signer_1 = require(\"./abstract-signer\"); ///////////////////////////////\n\n\nvar VoidSigner =\n/** @class */\nfunction (_super) {\n  __extends(VoidSigner, _super);\n\n  function VoidSigner(address, provider) {\n    var _this = _super.call(this) || this;\n\n    properties_1.defineReadOnly(_this, 'address', address);\n    properties_1.defineReadOnly(_this, 'provider', provider);\n    return _this;\n  }\n\n  VoidSigner.prototype.getAddress = function () {\n    return Promise.resolve(this.address);\n  };\n\n  VoidSigner.prototype._fail = function (message, operation) {\n    return Promise.resolve().then(function () {\n      errors.throwError(message, errors.UNSUPPORTED_OPERATION, {\n        operation: operation\n      });\n    });\n  };\n\n  VoidSigner.prototype.signMessage = function (message) {\n    return this._fail('VoidSigner cannot sign messages', 'signMessage');\n  };\n\n  VoidSigner.prototype.sendTransaction = function (transaction) {\n    return this._fail('VoidSigner cannot sign transactions', 'sendTransaction');\n  };\n\n  VoidSigner.prototype.connect = function (provider) {\n    return new VoidSigner(this.address, provider);\n  };\n\n  return VoidSigner;\n}(abstract_signer_1.Signer);\n\nexports.VoidSigner = VoidSigner;\nvar allowedTransactionKeys = {\n  chainId: true,\n  data: true,\n  from: true,\n  gasLimit: true,\n  gasPrice: true,\n  nonce: true,\n  to: true,\n  value: true\n}; // Recursively replaces ENS names with promises to resolve the name and\n// stalls until all promises have returned\n// @TODO: Expand this to resolve any promises too\n\nfunction resolveAddresses(provider, value, paramType) {\n  if (Array.isArray(paramType)) {\n    var promises_1 = [];\n    paramType.forEach(function (paramType, index) {\n      var v = null;\n\n      if (Array.isArray(value)) {\n        v = value[index];\n      } else {\n        v = value[paramType.name];\n      }\n\n      promises_1.push(resolveAddresses(provider, v, paramType));\n    });\n    return Promise.all(promises_1);\n  }\n\n  if (paramType.type === 'address') {\n    return provider.resolveName(value);\n  }\n\n  if (paramType.type === 'tuple') {\n    return resolveAddresses(provider, value, paramType.components);\n  } // Strips one level of array indexing off the end to recuse into\n\n\n  var isArrayMatch = paramType.type.match(/(.*)(\\[[0-9]*\\]$)/);\n\n  if (isArrayMatch) {\n    if (!Array.isArray(value)) {\n      throw new Error('invalid value for array');\n    }\n\n    var promises = [];\n    var subParamType = {\n      components: paramType.components,\n      type: isArrayMatch[1]\n    };\n    value.forEach(function (v) {\n      promises.push(resolveAddresses(provider, v, subParamType));\n    });\n    return Promise.all(promises);\n  }\n\n  return Promise.resolve(value);\n}\n\nfunction runMethod(contract, functionName, estimateOnly) {\n  var method = contract.interface.functions[functionName];\n  return function () {\n    var params = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      params[_i] = arguments[_i];\n    }\n\n    var tx = {};\n    var blockTag = null; // If 1 extra parameter was passed in, it contains overrides\n\n    if (params.length === method.inputs.length + 1 && typeof params[params.length - 1] === 'object') {\n      tx = properties_1.shallowCopy(params.pop());\n\n      if (tx.blockTag != null) {\n        blockTag = tx.blockTag;\n      }\n\n      delete tx.blockTag; // Check for unexpected keys (e.g. using \"gas\" instead of \"gasLimit\")\n\n      for (var key in tx) {\n        if (!allowedTransactionKeys[key]) {\n          throw new Error('unknown transaction override ' + key);\n        }\n      }\n    }\n\n    if (params.length != method.inputs.length) {\n      throw new Error('incorrect number of arguments');\n    } // Check overrides make sense\n\n\n    ['data', 'to'].forEach(function (key) {\n      if (tx[key] != null) {\n        errors.throwError('cannot override ' + key, errors.UNSUPPORTED_OPERATION, {\n          operation: key\n        });\n      }\n    }); // Send to the contract address (after checking the contract is deployed)\n\n    tx.to = contract.deployed().then(function () {\n      return contract.addressPromise;\n    });\n    return resolveAddresses(contract.provider, params, method.inputs).then(function (params) {\n      tx.data = method.encode(params);\n\n      if (method.type === 'call') {\n        // Call (constant functions) always cost 0 ether\n        if (estimateOnly) {\n          return Promise.resolve(constants_1.Zero);\n        }\n\n        if (!contract.provider) {\n          errors.throwError('call (constant functions) require a provider or a signer with a provider', errors.UNSUPPORTED_OPERATION, {\n            operation: 'call'\n          });\n        } // Check overrides make sense\n\n\n        ['gasLimit', 'gasPrice', 'value'].forEach(function (key) {\n          if (tx[key] != null) {\n            throw new Error('call cannot override ' + key);\n          }\n        });\n\n        if (tx.from == null && contract.signer) {\n          tx.from = contract.signer.getAddress();\n        }\n\n        return contract.provider.call(tx, blockTag).then(function (value) {\n          if (bytes_1.hexDataLength(value) % 32 === 4 && bytes_1.hexDataSlice(value, 0, 4) === '0x08c379a0') {\n            var reason = abi_coder_1.defaultAbiCoder.decode(['string'], bytes_1.hexDataSlice(value, 4));\n            errors.throwError('call revert exception', errors.CALL_EXCEPTION, {\n              address: contract.address,\n              args: params,\n              method: method.signature,\n              errorSignature: 'Error(string)',\n              errorArgs: [reason],\n              reason: reason,\n              transaction: tx\n            });\n          }\n\n          try {\n            var result = method.decode(value);\n\n            if (method.outputs.length === 1) {\n              result = result[0];\n            }\n\n            return result;\n          } catch (error) {\n            if (value === '0x' && method.outputs.length > 0) {\n              errors.throwError('call exception', errors.CALL_EXCEPTION, {\n                address: contract.address,\n                method: method.signature,\n                args: params\n              });\n            }\n\n            throw error;\n          }\n        });\n      } else if (method.type === 'transaction') {\n        // Only computing the transaction estimate\n        if (estimateOnly) {\n          if (!contract.provider) {\n            errors.throwError('estimate gas require a provider or a signer with a provider', errors.UNSUPPORTED_OPERATION, {\n              operation: 'estimateGas'\n            });\n          }\n\n          if (tx.from == null && contract.signer) {\n            tx.from = contract.signer.getAddress();\n          }\n\n          return contract.provider.estimateGas(tx);\n        }\n\n        if (tx.gasLimit == null && method.gas != null) {\n          tx.gasLimit = bignumber_1.bigNumberify(method.gas).add(21000);\n        }\n\n        if (!contract.signer) {\n          errors.throwError('sending a transaction require a signer', errors.UNSUPPORTED_OPERATION, {\n            operation: 'sendTransaction'\n          });\n        } // Make sure they aren't overriding something they shouldn't\n\n\n        if (tx.from != null) {\n          errors.throwError('cannot override from in a transaction', errors.UNSUPPORTED_OPERATION, {\n            operation: 'sendTransaction'\n          });\n        }\n\n        return contract.signer.sendTransaction(tx).then(function (tx) {\n          var wait = tx.wait.bind(tx);\n\n          tx.wait = function (confirmations) {\n            return wait(confirmations).then(function (receipt) {\n              receipt.events = receipt.logs.map(function (log) {\n                var event = properties_1.deepCopy(log);\n                var parsed = contract.interface.parseLog(log);\n\n                if (parsed) {\n                  event.args = parsed.values;\n                  event.decode = parsed.decode;\n                  event.event = parsed.name;\n                  event.eventSignature = parsed.signature;\n                }\n\n                event.removeListener = function () {\n                  return contract.provider;\n                };\n\n                event.getBlock = function () {\n                  return contract.provider.getBlock(receipt.blockHash);\n                };\n\n                event.getTransaction = function () {\n                  return contract.provider.getTransaction(receipt.transactionHash);\n                };\n\n                event.getTransactionReceipt = function () {\n                  return Promise.resolve(receipt);\n                };\n\n                return event;\n              });\n              return receipt;\n            });\n          };\n\n          return tx;\n        });\n      }\n\n      throw new Error('invalid type - ' + method.type);\n      return null;\n    });\n  };\n}\n\nfunction getEventTag(filter) {\n  if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n    return '*';\n  }\n\n  return (filter.address || '*') + '@' + (filter.topics ? filter.topics.join(':') : '');\n}\n\nvar Contract =\n/** @class */\nfunction () {\n  // https://github.com/Microsoft/TypeScript/issues/5453\n  // Once this issue is resolved (there are open PR) we can do this nicer\n  // by making addressOrName default to null for 2 operand calls. :)\n  function Contract(addressOrName, contractInterface, signerOrProvider) {\n    var _this = this;\n\n    errors.checkNew(this, Contract); // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n    //address = getAddress(address);\n\n    if (interface_1.Interface.isInterface(contractInterface)) {\n      properties_1.defineReadOnly(this, 'interface', contractInterface);\n    } else {\n      properties_1.defineReadOnly(this, 'interface', new interface_1.Interface(contractInterface));\n    }\n\n    if (abstract_signer_1.Signer.isSigner(signerOrProvider)) {\n      properties_1.defineReadOnly(this, 'provider', signerOrProvider.provider);\n      properties_1.defineReadOnly(this, 'signer', signerOrProvider);\n    } else if (abstract_provider_1.Provider.isProvider(signerOrProvider)) {\n      properties_1.defineReadOnly(this, 'provider', signerOrProvider);\n      properties_1.defineReadOnly(this, 'signer', null);\n    } else {\n      errors.throwError('invalid signer or provider', errors.INVALID_ARGUMENT, {\n        arg: 'signerOrProvider',\n        value: signerOrProvider\n      });\n    }\n\n    properties_1.defineReadOnly(this, 'estimate', {});\n    properties_1.defineReadOnly(this, 'functions', {});\n    properties_1.defineReadOnly(this, 'filters', {});\n    Object.keys(this.interface.events).forEach(function (eventName) {\n      var event = _this.interface.events[eventName];\n      properties_1.defineReadOnly(_this.filters, eventName, function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return {\n          address: _this.address,\n          topics: event.encodeTopics(args)\n        };\n      });\n    });\n    this._events = [];\n    properties_1.defineReadOnly(this, 'address', addressOrName);\n\n    if (this.provider) {\n      properties_1.defineReadOnly(this, 'addressPromise', this.provider.resolveName(addressOrName).then(function (address) {\n        if (address == null) {\n          throw new Error('name not found');\n        }\n\n        return address;\n      }).catch(function (error) {\n        throw error;\n      }));\n    } else {\n      try {\n        properties_1.defineReadOnly(this, 'addressPromise', Promise.resolve(address_1.getAddress(addressOrName)));\n      } catch (error) {\n        // Without a provider, we cannot use ENS names\n        errors.throwError('provider is required to use non-address contract address', errors.INVALID_ARGUMENT, {\n          argument: 'addressOrName',\n          value: addressOrName\n        });\n      }\n    }\n\n    Object.keys(this.interface.functions).forEach(function (name) {\n      var run = runMethod(_this, name, false);\n\n      if (_this[name] == null) {\n        properties_1.defineReadOnly(_this, name, run);\n      } else {\n        errors.warn('WARNING: Multiple definitions for ' + name);\n      }\n\n      if (_this.functions[name] == null) {\n        properties_1.defineReadOnly(_this.functions, name, run);\n        properties_1.defineReadOnly(_this.estimate, name, runMethod(_this, name, true));\n      }\n    });\n  } // @TODO: Allow timeout?\n\n\n  Contract.prototype.deployed = function () {\n    var _this = this;\n\n    if (!this._deployed) {\n      // If we were just deployed, we know the transaction we should occur in\n      if (this.deployTransaction) {\n        this._deployed = this.deployTransaction.wait().then(function () {\n          return _this;\n        });\n      } else {\n        // @TODO: Once we allow a timeout to be passed in, we will wait\n        // up to that many blocks for getCode\n        // Otherwise, poll for our code to be deployed\n        this._deployed = this.provider.getCode(this.address).then(function (code) {\n          if (code === '0x') {\n            errors.throwError('contract not deployed', errors.UNSUPPORTED_OPERATION, {\n              contractAddress: _this.address,\n              operation: 'getDeployed'\n            });\n          }\n\n          return _this;\n        });\n      }\n    }\n\n    return this._deployed;\n  }; // @TODO:\n  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n  // @TODO:\n  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n\n\n  Contract.prototype.fallback = function (overrides) {\n    var _this = this;\n\n    if (!this.signer) {\n      errors.throwError('sending a transaction require a signer', errors.UNSUPPORTED_OPERATION, {\n        operation: 'sendTransaction(fallback)'\n      });\n    }\n\n    var tx = properties_1.shallowCopy(overrides || {});\n    ['from', 'to'].forEach(function (key) {\n      if (tx[key] == null) {\n        return;\n      }\n\n      errors.throwError('cannot override ' + key, errors.UNSUPPORTED_OPERATION, {\n        operation: key\n      });\n    });\n    tx.to = this.addressPromise;\n    return this.deployed().then(function () {\n      return _this.signer.sendTransaction(tx);\n    });\n  }; // Reconnect to a different signer or provider\n\n\n  Contract.prototype.connect = function (signerOrProvider) {\n    if (typeof signerOrProvider === 'string') {\n      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);\n    }\n\n    var contract = new Contract(this.address, this.interface, signerOrProvider);\n\n    if (this.deployTransaction) {\n      properties_1.defineReadOnly(contract, 'deployTransaction', this.deployTransaction);\n    }\n\n    return contract;\n  }; // Re-attach to a different on=chain instance of this contract\n\n\n  Contract.prototype.attach = function (addressOrName) {\n    return new Contract(addressOrName, this.interface, this.signer || this.provider);\n  };\n\n  Contract.isIndexed = function (value) {\n    return interface_1.Interface.isIndexed(value);\n  };\n\n  Contract.prototype._getEventFilter = function (eventName) {\n    var _this = this;\n\n    if (typeof eventName === 'string') {\n      // Listen for any event\n      if (eventName === '*') {\n        return {\n          prepareEvent: function prepareEvent(e) {\n            var parsed = _this.interface.parseLog(e);\n\n            if (parsed) {\n              e.args = parsed.values;\n              e.decode = parsed.decode;\n              e.event = parsed.name;\n              e.eventSignature = parsed.signature;\n            }\n\n            return [e];\n          },\n          eventTag: '*',\n          filter: {\n            address: this.address\n          }\n        };\n      } // Normalize the eventName\n\n\n      if (eventName.indexOf('(') !== -1) {\n        eventName = abi_coder_1.formatSignature(abi_coder_1.parseSignature('event ' + eventName));\n      }\n\n      var event_1 = this.interface.events[eventName];\n\n      if (!event_1) {\n        errors.throwError('unknown event - ' + eventName, errors.INVALID_ARGUMENT, {\n          argumnet: 'eventName',\n          value: eventName\n        });\n      }\n\n      var filter_1 = {\n        address: this.address,\n        topics: [event_1.topic]\n      };\n      return {\n        prepareEvent: function prepareEvent(e) {\n          var args = event_1.decode(e.data, e.topics);\n          e.args = args;\n          var result = Array.prototype.slice.call(args);\n          result.push(e);\n          return result;\n        },\n        event: event_1,\n        eventTag: getEventTag(filter_1),\n        filter: filter_1\n      };\n    }\n\n    var filter = {\n      address: this.address\n    }; // Find the matching event in the ABI; if none, we still allow filtering\n    // since it may be a filter for an otherwise unknown event\n\n    var event = null;\n\n    if (eventName.topics && eventName.topics[0]) {\n      filter.topics = eventName.topics;\n\n      for (var name_1 in this.interface.events) {\n        if (name_1.indexOf('(') === -1) {\n          continue;\n        }\n\n        var e = this.interface.events[name_1];\n\n        if (e.topic === eventName.topics[0].toLowerCase()) {\n          event = e;\n          break;\n        }\n      }\n    }\n\n    return {\n      prepareEvent: function prepareEvent(e) {\n        if (!event) {\n          return [e];\n        }\n\n        var args = event.decode(e.data, e.topics);\n        e.args = args;\n        var result = Array.prototype.slice.call(args);\n        result.push(e);\n        return result;\n      },\n      event: event,\n      eventTag: getEventTag(filter),\n      filter: filter\n    };\n  };\n\n  Contract.prototype._addEventListener = function (eventFilter, listener, once) {\n    var _this = this;\n\n    if (!this.provider) {\n      errors.throwError('events require a provider or a signer with a provider', errors.UNSUPPORTED_OPERATION, {\n        operation: 'once'\n      });\n    }\n\n    var wrappedListener = function wrappedListener(log) {\n      var event = properties_1.deepCopy(log);\n      var args = eventFilter.prepareEvent(event);\n\n      if (eventFilter.event) {\n        event.decode = eventFilter.event.decode;\n        event.event = eventFilter.event.name;\n        event.eventSignature = eventFilter.event.signature;\n      }\n\n      event.removeListener = function () {\n        _this.removeListener(eventFilter.filter, listener);\n      };\n\n      event.getBlock = function () {\n        return _this.provider.getBlock(log.blockHash);\n      };\n\n      event.getTransaction = function () {\n        return _this.provider.getTransaction(log.transactionHash);\n      };\n\n      event.getTransactionReceipt = function () {\n        return _this.provider.getTransactionReceipt(log.transactionHash);\n      };\n\n      _this.emit.apply(_this, [eventFilter.filter].concat(args));\n    };\n\n    this.provider.on(eventFilter.filter, wrappedListener);\n\n    this._events.push({\n      eventFilter: eventFilter,\n      listener: listener,\n      wrappedListener: wrappedListener,\n      once: once\n    });\n  };\n\n  Contract.prototype.on = function (event, listener) {\n    this._addEventListener(this._getEventFilter(event), listener, false);\n\n    return this;\n  };\n\n  Contract.prototype.once = function (event, listener) {\n    this._addEventListener(this._getEventFilter(event), listener, true);\n\n    return this;\n  };\n\n  Contract.prototype.addListener = function (eventName, listener) {\n    return this.on(eventName, listener);\n  };\n\n  Contract.prototype.emit = function (eventName) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    if (!this.provider) {\n      return false;\n    }\n\n    var result = false;\n\n    var eventFilter = this._getEventFilter(eventName);\n\n    this._events = this._events.filter(function (event) {\n      // Not this event (keep it for later)\n      if (event.eventFilter.eventTag !== eventFilter.eventTag) {\n        return true;\n      } // Call the callback in the next event loop\n\n\n      setTimeout(function () {\n        event.listener.apply(_this, args);\n      }, 0);\n      result = true; // Reschedule it if it not \"once\"\n\n      return !event.once;\n    });\n    return result;\n  };\n\n  Contract.prototype.listenerCount = function (eventName) {\n    if (!this.provider) {\n      return 0;\n    }\n\n    var eventFilter = this._getEventFilter(eventName);\n\n    return this._events.filter(function (event) {\n      return event.eventFilter.eventTag === eventFilter.eventTag;\n    }).length;\n  };\n\n  Contract.prototype.listeners = function (eventName) {\n    if (!this.provider) {\n      return [];\n    }\n\n    var eventFilter = this._getEventFilter(eventName);\n\n    return this._events.filter(function (event) {\n      return event.eventFilter.eventTag === eventFilter.eventTag;\n    }).map(function (event) {\n      return event.listener;\n    });\n  };\n\n  Contract.prototype.removeAllListeners = function (eventName) {\n    var _this = this;\n\n    if (!this.provider) {\n      return this;\n    }\n\n    var eventFilter = this._getEventFilter(eventName);\n\n    this._events = this._events.filter(function (event) {\n      // Keep all other events\n      if (event.eventFilter.eventTag !== eventFilter.eventTag) {\n        return true;\n      } // Deregister this event from the provider and filter it out\n\n\n      _this.provider.removeListener(event.eventFilter.filter, event.wrappedListener);\n\n      return false;\n    });\n    return this;\n  };\n\n  Contract.prototype.removeListener = function (eventName, listener) {\n    var _this = this;\n\n    if (!this.provider) {\n      return this;\n    }\n\n    var found = false;\n\n    var eventFilter = this._getEventFilter(eventName);\n\n    this._events = this._events.filter(function (event) {\n      // Make sure this event and listener match\n      if (event.eventFilter.eventTag !== eventFilter.eventTag) {\n        return true;\n      }\n\n      if (event.listener !== listener) {\n        return true;\n      }\n\n      _this.provider.removeListener(event.eventFilter.filter, event.wrappedListener); // Already found a matching event in a previous loop\n\n\n      if (found) {\n        return true;\n      } // REmove this event (returning false filters us out)\n\n\n      found = true;\n      return false;\n    });\n    return this;\n  };\n\n  return Contract;\n}();\n\nexports.Contract = Contract;\n\nvar ContractFactory =\n/** @class */\nfunction () {\n  function ContractFactory(contractInterface, bytecode, signer) {\n    var bytecodeHex = null; // Allow the bytecode object from the Solidity compiler\n\n    if (typeof bytecode === 'string') {\n      bytecodeHex = bytecode;\n    } else if (bytes_1.isArrayish(bytecode)) {\n      bytecodeHex = bytes_1.hexlify(bytecode);\n    } else if (typeof bytecode.object === 'string') {\n      bytecodeHex = bytecode.object;\n    } else {\n      errors.throwError('bytecode must be a valid hex string', errors.INVALID_ARGUMENT, {\n        arg: 'bytecode',\n        value: bytecode\n      });\n    } // Make sure it is 0x prefixed\n\n\n    if (bytecodeHex.substring(0, 2) !== '0x') {\n      bytecodeHex = '0x' + bytecodeHex;\n    }\n\n    if (!bytes_1.isHexString(bytecodeHex)) {\n      errors.throwError('bytecode must be a valid hex string', errors.INVALID_ARGUMENT, {\n        arg: 'bytecode',\n        value: bytecode\n      });\n    }\n\n    if (bytecodeHex.length % 2 !== 0) {\n      errors.throwError('bytecode must be valid data (even length)', errors.INVALID_ARGUMENT, {\n        arg: 'bytecode',\n        value: bytecode\n      });\n    }\n\n    properties_1.defineReadOnly(this, 'bytecode', bytecodeHex);\n\n    if (interface_1.Interface.isInterface(contractInterface)) {\n      properties_1.defineReadOnly(this, 'interface', contractInterface);\n    } else {\n      properties_1.defineReadOnly(this, 'interface', new interface_1.Interface(contractInterface));\n    }\n\n    if (signer && !abstract_signer_1.Signer.isSigner(signer)) {\n      errors.throwError('invalid signer', errors.INVALID_ARGUMENT, {\n        arg: 'signer',\n        value: null\n      });\n    }\n\n    properties_1.defineReadOnly(this, 'signer', signer || null);\n  }\n\n  ContractFactory.prototype.getDeployTransaction = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var tx = {}; // If we have 1 additional argument, we allow transaction overrides\n\n    if (args.length === this.interface.deployFunction.inputs.length + 1) {\n      tx = properties_1.shallowCopy(args.pop());\n\n      for (var key in tx) {\n        if (!allowedTransactionKeys[key]) {\n          throw new Error('unknown transaction override ' + key);\n        }\n      }\n    } // Do not allow these to be overridden in a deployment transaction\n\n\n    ['data', 'from', 'to'].forEach(function (key) {\n      if (tx[key] == null) {\n        return;\n      }\n\n      errors.throwError('cannot override ' + key, errors.UNSUPPORTED_OPERATION, {\n        operation: key\n      });\n    }); // Make sure the call matches the constructor signature\n\n    errors.checkArgumentCount(args.length, this.interface.deployFunction.inputs.length, ' in Contract constructor'); // Set the data to the bytecode + the encoded constructor arguments\n\n    tx.data = this.interface.deployFunction.encode(this.bytecode, args);\n    return tx;\n  };\n\n  ContractFactory.prototype.deploy = function () {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    } // Get the deployment transaction (with optional overrides)\n\n\n    var tx = this.getDeployTransaction.apply(this, args); // Send the deployment transaction\n\n    return this.signer.sendTransaction(tx).then(function (tx) {\n      var contract = new Contract(address_1.getContractAddress(tx), _this.interface, _this.signer);\n      properties_1.defineReadOnly(contract, 'deployTransaction', tx);\n      return contract;\n    });\n  };\n\n  ContractFactory.prototype.attach = function (address) {\n    return new Contract(address, this.interface, this.signer);\n  };\n\n  ContractFactory.prototype.connect = function (signer) {\n    return new ContractFactory(this.interface, this.bytecode, signer);\n  };\n\n  ContractFactory.fromSolidity = function (compilerOutput, signer) {\n    if (compilerOutput == null) {\n      errors.throwError('missing compiler output', errors.MISSING_ARGUMENT, {\n        argument: 'compilerOutput'\n      });\n    }\n\n    if (typeof compilerOutput === 'string') {\n      compilerOutput = JSON.parse(compilerOutput);\n    }\n\n    var abi = compilerOutput.abi;\n    var bytecode = null;\n\n    if (compilerOutput.bytecode) {\n      bytecode = compilerOutput.bytecode;\n    } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n      bytecode = compilerOutput.evm.bytecode;\n    }\n\n    return new ContractFactory(abi, bytecode, signer);\n  };\n\n  return ContractFactory;\n}();\n\nexports.ContractFactory = ContractFactory;","map":null,"metadata":{},"sourceType":"script"}