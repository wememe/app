{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar pull = require('pull-stream');\n\nvar debug = require('debug');\n\nvar PeerInfo = require('peer-info');\n\nvar PeerId = require('peer-id');\n\nvar EE = require('events').EventEmitter;\n\nvar once = require('once');\n\nvar utilsFactory = require('./utils');\n\nvar StreamHandler = require('./stream-handler');\n\nvar proto = require('../protocol').CircuitRelay;\n\nvar multiaddr = require('multiaddr');\n\nvar series = require('async/series');\n\nvar waterfall = require('async/waterfall');\n\nvar multicodec = require('./../multicodec');\n\nvar log = debug('libp2p:swarm:circuit:relay');\nlog.err = debug('libp2p:swarm:circuit:error:relay');\n\nvar Hop =\n/*#__PURE__*/\nfunction (_EE) {\n  _inherits(Hop, _EE);\n\n  /**\n   * Construct a Circuit object\n   *\n   * This class will handle incoming circuit connections and\n   * either start a relay or hand the relayed connection to\n   * the swarm\n   *\n   * @param {Swarm} swarm\n   * @param {Object} options\n   */\n  function Hop(swarm, options) {\n    var _this;\n\n    _classCallCheck(this, Hop);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Hop).call(this));\n    _this.swarm = swarm;\n    _this.peerInfo = _this.swarm._peerInfo;\n    _this.utils = utilsFactory(swarm);\n    _this.config = options || {\n      active: false,\n      enabled: false\n    };\n    _this.active = _this.config.active;\n    return _this;\n  }\n  /**\n   * Handle the relay message\n   *\n   * @param {CircuitRelay} message\n   * @param {StreamHandler} sh\n   * @returns {*}\n   */\n\n\n  _createClass(Hop, [{\n    key: \"handle\",\n    value: function handle(message, sh) {\n      var _this2 = this;\n\n      if (!this.config.enabled) {\n        this.utils.writeResponse(sh, proto.Status.HOP_CANT_SPEAK_RELAY);\n        return sh.close();\n      } // check if message is `CAN_HOP`\n\n\n      if (message.type === proto.Type.CAN_HOP) {\n        this.utils.writeResponse(sh, proto.Status.SUCCESS);\n        return sh.close();\n      } // This is a relay request - validate and create a circuit\n\n\n      var srcPeerId = PeerId.createFromBytes(message.dstPeer.id);\n\n      if (srcPeerId.toB58String() === this.peerInfo.id.toB58String()) {\n        this.utils.writeResponse(sh, proto.Status.HOP_CANT_RELAY_TO_SELF);\n        return sh.close();\n      }\n\n      var dstPeerId = PeerId.createFromBytes(message.dstPeer.id).toB58String();\n\n      if (!message.dstPeer.addrs.length) {\n        // TODO: use encapsulate here\n        var addr = multiaddr(\"/p2p-circuit/ipfs/\".concat(dstPeerId)).buffer;\n        message.dstPeer.addrs.push(addr);\n      }\n\n      var noPeer = function noPeer(err) {\n        log.err(err);\n\n        _this2.utils.writeResponse(sh, proto.Status.HOP_NO_CONN_TO_DST);\n\n        return sh.close();\n      };\n\n      var isConnected = function isConnected(cb) {\n        var dstPeer;\n\n        try {\n          dstPeer = _this2.swarm._peerBook.get(dstPeerId);\n\n          if (!dstPeer.isConnected() && !_this2.active) {\n            var err = new Error('No Connection to peer');\n            noPeer(err);\n            return cb(err);\n          }\n        } catch (err) {\n          if (!_this2.active) {\n            noPeer(err);\n            return cb(err);\n          }\n        }\n\n        cb();\n      };\n\n      series([function (cb) {\n        return _this2.utils.validateAddrs(message, sh, proto.Type.HOP, cb);\n      }, function (cb) {\n        return isConnected(cb);\n      }, function (cb) {\n        return _this2._circuit(sh.rest(), message, cb);\n      }], function (err) {\n        if (err) {\n          log.err(err);\n          setImmediate(function () {\n            return _this2.emit('circuit:error', err);\n          });\n        }\n\n        setImmediate(function () {\n          return _this2.emit('circuit:success');\n        });\n      });\n    }\n    /**\n     * Connect to STOP\n     *\n     * @param {PeerInfo} peer\n     * @param {StreamHandler} srcSh\n     * @param {function} callback\n     * @returns {function}\n     */\n\n  }, {\n    key: \"_connectToStop\",\n    value: function _connectToStop(peer, srcSh, callback) {\n      var _this3 = this;\n\n      this._dialPeer(peer, function (err, dstConn) {\n        if (err) {\n          _this3.utils.writeResponse(srcSh, proto.Status.HOP_CANT_DIAL_DST);\n\n          log.err(err);\n          return callback(err);\n        }\n\n        return _this3.utils.writeResponse(srcSh, proto.Status.SUCCESS, function (err) {\n          if (err) {\n            log.err(err);\n            return callback(err);\n          }\n\n          return callback(null, dstConn);\n        });\n      });\n    }\n    /**\n     * Negotiate STOP\n     *\n     * @param {StreamHandler} dstSh\n     * @param {StreamHandler} srcSh\n     * @param {CircuitRelay} message\n     * @param {function} callback\n     * @returns {function}\n     */\n\n  }, {\n    key: \"_negotiateStop\",\n    value: function _negotiateStop(dstSh, srcSh, message, callback) {\n      var _this4 = this;\n\n      var stopMsg = Object.assign({}, message, {\n        type: proto.Type.STOP // change the message type\n\n      });\n      dstSh.write(proto.encode(stopMsg), function (err) {\n        if (err) {\n          _this4.utils.writeResponse(srcSh, proto.Status.HOP_CANT_OPEN_DST_STREAM);\n\n          log.err(err);\n          return callback(err);\n        } // read response from STOP\n\n\n        dstSh.read(function (err, msg) {\n          if (err) {\n            log.err(err);\n            return callback(err);\n          }\n\n          var message = proto.decode(msg);\n\n          if (message.code !== proto.Status.SUCCESS) {\n            return callback(new Error(\"Unable to create circuit!\"));\n          }\n\n          return callback(null, msg);\n        });\n      });\n    }\n    /**\n     * Attempt to make a circuit from A <-> R <-> B where R is this relay\n     *\n     * @param {Connection} srcConn - the source connection\n     * @param {CircuitRelay} message - the message with the src and dst entries\n     * @param {Function} callback - callback to signal success or failure\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: \"_circuit\",\n    value: function _circuit(srcConn, message, callback) {\n      var _this5 = this;\n\n      var dstSh = null;\n      var srcSh = new StreamHandler(srcConn);\n      waterfall([function (cb) {\n        return _this5._connectToStop(message.dstPeer, srcSh, cb);\n      }, function (_dstConn, cb) {\n        dstSh = new StreamHandler(_dstConn);\n\n        _this5._negotiateStop(dstSh, srcConn, message, cb);\n      }], function (err) {\n        if (err) {\n          // close/end the source stream if there was an error\n          if (srcSh) {\n            srcSh.close();\n          }\n\n          if (dstSh) {\n            dstSh.close();\n          }\n\n          return callback(err);\n        }\n\n        var src = srcSh.rest();\n        var dst = dstSh.rest(); // circuit the src and dst streams\n\n        pull(src, dst, src);\n        callback();\n      });\n    }\n    /**\n     * Dial the dest peer and create a circuit\n     *\n     * @param {Multiaddr} dstPeer\n     * @param {Function} callback\n     * @returns {Function|void}\n     * @private\n     */\n\n  }, {\n    key: \"_dialPeer\",\n    value: function _dialPeer(dstPeer, callback) {\n      var peerInfo = new PeerInfo(PeerId.createFromBytes(dstPeer.id));\n      dstPeer.addrs.forEach(function (a) {\n        return peerInfo.multiaddrs.add(a);\n      });\n      this.swarm.dial(peerInfo, multicodec.relay, once(function (err, conn) {\n        if (err) {\n          log.err(err);\n          return callback(err);\n        }\n\n        callback(null, conn);\n      }));\n    }\n  }]);\n\n  return Hop;\n}(EE);\n\nmodule.exports = Hop;","map":null,"metadata":{},"sourceType":"script"}