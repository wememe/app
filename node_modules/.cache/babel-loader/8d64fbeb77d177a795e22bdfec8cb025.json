{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Clock = require('./lamport-clock');\n\nvar isDefined = require('./utils/is-defined');\n\nvar IpfsNotDefinedError = function IpfsNotDefinedError() {\n  return new Error('Ipfs instance not defined');\n};\n\nvar Entry =\n/*#__PURE__*/\nfunction () {\n  function Entry() {\n    _classCallCheck(this, Entry);\n  }\n\n  _createClass(Entry, null, [{\n    key: \"create\",\n\n    /**\n     * Create an Entry\n     * @param {IPFS} ipfs - An IPFS instance\n     * @param {string|Buffer|Object|Array} data - Data of the entry to be added. Can be any JSON.stringifyable data.\n     * @param {Array<Entry|string>} [next=[]] Parents of the entry\n     * @example\n     * const entry = await Entry.create(ipfs, 'hello')\n     * console.log(entry)\n     * // { hash: \"Qm...Foo\", payload: \"hello\", next: [] }\n     * @returns {Promise<Entry>}\n     */\n    value: function () {\n      var _create = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(ipfs, keystore, id, data) {\n        var next,\n            clock,\n            signKey,\n            toEntry,\n            nexts,\n            clockId,\n            clockTime,\n            entry,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                next = _args.length > 4 && _args[4] !== undefined ? _args[4] : [];\n                clock = _args.length > 5 ? _args[5] : undefined;\n                signKey = _args.length > 6 ? _args[6] : undefined;\n\n                if (isDefined(ipfs)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw IpfsNotDefinedError();\n\n              case 5:\n                if (isDefined(id)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error('Entry requires an id');\n\n              case 7:\n                if (isDefined(data)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                throw new Error('Entry requires data');\n\n              case 9:\n                if (!(!isDefined(next) || !Array.isArray(next))) {\n                  _context.next = 11;\n                  break;\n                }\n\n                throw new Error(\"'next' argument is not an array\");\n\n              case 11:\n                // Clean the next objects and convert to hashes\n                toEntry = function toEntry(e) {\n                  return e.hash ? e.hash : e;\n                };\n\n                nexts = next.filter(isDefined).map(toEntry); // Take the id of the given clock by default,\n                // if clock not given, take the signing key if it's a Key instance,\n                // or if none given, take the id as the clock id\n\n                clockId = clock ? clock.id : signKey ? signKey.getPublic('hex') : id;\n                clockTime = clock ? clock.time : null;\n                entry = {\n                  hash: null,\n                  // \"Qm...Foo\", we'll set the hash after persisting the entry\n                  id: id,\n                  // For determining a unique chain\n                  payload: data,\n                  // Can be any JSON.stringifyable data\n                  next: nexts,\n                  // Array of Multihashes\n                  v: 0,\n                  // For future data structure updates, should currently always be 0\n                  clock: new Clock(clockId, clockTime) // If signing key was passedd, sign the enrty\n\n                };\n\n                if (!(keystore && signKey)) {\n                  _context.next = 20;\n                  break;\n                }\n\n                _context.next = 19;\n                return Entry.signEntry(keystore, entry, signKey);\n\n              case 19:\n                entry = _context.sent;\n\n              case 20:\n                _context.next = 22;\n                return Entry.toMultihash(ipfs, entry);\n\n              case 22:\n                entry.hash = _context.sent;\n                return _context.abrupt(\"return\", entry);\n\n              case 24:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function create(_x, _x2, _x3, _x4) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }, {\n    key: \"signEntry\",\n    value: function () {\n      var _signEntry = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(keystore, entry, key) {\n        var signature;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return keystore.sign(key, Buffer.from(JSON.stringify(entry)));\n\n              case 2:\n                signature = _context2.sent;\n                entry.sig = signature;\n                entry.key = key.getPublic('hex');\n                return _context2.abrupt(\"return\", entry);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function signEntry(_x5, _x6, _x7) {\n        return _signEntry.apply(this, arguments);\n      }\n\n      return signEntry;\n    }()\n  }, {\n    key: \"verifyEntry\",\n    value: function () {\n      var _verifyEntry = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(entry, keystore) {\n        var e, pubKey;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                e = Object.assign({}, {\n                  hash: null,\n                  id: entry.id,\n                  payload: entry.payload,\n                  next: entry.next,\n                  v: entry.v,\n                  clock: entry.clock\n                });\n                _context3.next = 3;\n                return keystore.importPublicKey(entry.key);\n\n              case 3:\n                pubKey = _context3.sent;\n                _context3.next = 6;\n                return keystore.verify(entry.sig, pubKey, Buffer.from(JSON.stringify(e)));\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function verifyEntry(_x8, _x9) {\n        return _verifyEntry.apply(this, arguments);\n      }\n\n      return verifyEntry;\n    }()\n    /**\n     * Get the multihash of an Entry\n     * @param {IPFS} [ipfs] An IPFS instance\n     * @param {Entry} [entry] Entry to get a multihash for\n     * @example\n     * const hash = await Entry.toMultihash(ipfs, entry)\n     * console.log(hash)\n     * // \"Qm...Foo\"\n     * @returns {Promise<string>}\n     */\n\n  }, {\n    key: \"toMultihash\",\n    value: function toMultihash(ipfs, entry) {\n      if (!ipfs) throw IpfsNotDefinedError();\n      var data = Buffer.from(JSON.stringify(entry));\n      return ipfs.object.put(data).then(function (res) {\n        return res.toJSON().multihash;\n      });\n    }\n    /**\n     * Create an Entry from a multihash\n     * @param {IPFS} [ipfs] An IPFS instance\n     * @param {string} [hash] Multihash as Base58 encoded string to create an Entry from\n     * @example\n     * const hash = await Entry.fromMultihash(ipfs, \"Qm...Foo\")\n     * console.log(hash)\n     * // { hash: \"Qm...Foo\", payload: \"hello\", next: [] }\n     * @returns {Promise<Entry>}\n     */\n\n  }, {\n    key: \"fromMultihash\",\n    value: function fromMultihash(ipfs, hash) {\n      if (!ipfs) throw IpfsNotDefinedError();\n      if (!hash) throw new Error(\"Invalid hash: \".concat(hash));\n      return ipfs.object.get(hash, {\n        enc: 'base58'\n      }).then(function (obj) {\n        return JSON.parse(obj.toJSON().data);\n      }).then(function (data) {\n        var entry = {\n          hash: hash,\n          id: data.id,\n          payload: data.payload,\n          next: data.next,\n          v: data.v,\n          clock: data.clock\n        };\n        if (data.sig) Object.assign(entry, {\n          sig: data.sig\n        });\n        if (data.key) Object.assign(entry, {\n          key: data.key\n        });\n        return entry;\n      });\n    }\n    /**\n     * Check if an object is an Entry\n     * @param {Entry} obj\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEntry\",\n    value: function isEntry(obj) {\n      return obj.id !== undefined && obj.next !== undefined && obj.hash !== undefined && obj.payload !== undefined && obj.v !== undefined && obj.clock !== undefined;\n    }\n  }, {\n    key: \"compare\",\n    value: function compare(a, b) {\n      var distance = Clock.compare(a.clock, b.clock);\n      if (distance === 0) return a.clock.id < b.clock.id ? -1 : 1;\n      return distance;\n    }\n    /**\n     * Check if an entry equals another entry\n     * @param {Entry} a\n     * @param {Entry} b\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(a, b) {\n      return a.hash === b.hash;\n    }\n    /**\n     * Check if an entry is a parent to another entry.\n     * @param {Entry} [entry1] Entry to check\n     * @param {Entry} [entry2] Parent\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isParent\",\n    value: function isParent(entry1, entry2) {\n      return entry2.next.indexOf(entry1.hash) > -1;\n    }\n    /**\n     * Find entry's children from an Array of entries\n     *\n     * @description\n     * Returns entry's children as an Array up to the last know child.\n     *\n     * @param {Entry} [entry] Entry for which to find the parents\n     * @param {Array<Entry>} [vaules] Entries to search parents from\n     * @returns {Array<Entry>}\n     */\n\n  }, {\n    key: \"findChildren\",\n    value: function findChildren(entry, values) {\n      var stack = [];\n      var parent = values.find(function (e) {\n        return Entry.isParent(entry, e);\n      });\n      var prev = entry;\n\n      while (parent) {\n        stack.push(parent);\n        prev = parent;\n        parent = values.find(function (e) {\n          return Entry.isParent(prev, e);\n        });\n      }\n\n      stack = stack.sort(function (a, b) {\n        return a.clock.time > a.clock.time;\n      });\n      return stack;\n    }\n  }]);\n\n  return Entry;\n}();\n\nmodule.exports = Entry;","map":null,"metadata":{},"sourceType":"script"}