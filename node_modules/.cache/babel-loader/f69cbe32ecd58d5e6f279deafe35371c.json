{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar assert = require('assert');\n\nvar each = require('async/each');\n\nvar series = require('async/series');\n\nvar parallel = require('async/parallel');\n\nvar PeerBook = require('peer-book');\n\nvar Switch = require('libp2p-switch');\n\nvar Ping = require('libp2p-ping');\n\nvar WebSockets = require('libp2p-websockets');\n\nvar ConnectionManager = require('libp2p-connection-manager');\n\nvar peerRouting = require('./peer-routing');\n\nvar contentRouting = require('./content-routing');\n\nvar dht = require('./dht');\n\nvar pubsub = require('./pubsub');\n\nvar getPeerInfo = require('./get-peer-info');\n\nvar validateConfig = require('./config').validate;\n\nexports = module.exports;\nvar NOT_STARTED_ERROR_MESSAGE = 'The libp2p node is not started yet';\n\nvar Node =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(Node, _EventEmitter);\n\n  function Node(_options) {\n    var _this;\n\n    _classCallCheck(this, Node);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Node).call(this)); // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n\n    _options = validateConfig(_options);\n    _this.peerInfo = _options.peerInfo;\n    _this.peerBook = _options.peerBook || new PeerBook();\n    _this._modules = _options.modules;\n    _this._config = _options.config;\n    _this._isStarted = false;\n    _this._transport = []; // Transport instances/references\n\n    _this._discovery = []; // Discovery service instances/references\n\n    _this._switch = new Switch(_this.peerInfo, _this.peerBook, _options.switch);\n    _this.stats = _this._switch.stats;\n    _this.connectionManager = new ConnectionManager(_assertThisInitialized(_assertThisInitialized(_this)), _options.connectionManager); // Attach stream multiplexers\n\n    if (_this._modules.streamMuxer) {\n      var muxers = _this._modules.streamMuxer;\n      muxers.forEach(function (muxer) {\n        return _this._switch.connection.addStreamMuxer(muxer);\n      }); // If muxer exists\n      //   we can use Identify\n\n      _this._switch.connection.reuse(); //   we can use Relay for listening/dialing\n\n\n      _this._switch.connection.enableCircuitRelay(_this._config.relay); // Received incomming dial and muxer upgrade happened,\n      // reuse this muxed connection\n\n\n      _this._switch.on('peer-mux-established', function (peerInfo) {\n        _this.emit('peer:connect', peerInfo);\n\n        _this.peerBook.put(peerInfo);\n      });\n\n      _this._switch.on('peer-mux-closed', function (peerInfo) {\n        _this.emit('peer:disconnect', peerInfo);\n      });\n    } // Attach crypto channels\n\n\n    if (_this._modules.connEncryption) {\n      var cryptos = _this._modules.connEncryption;\n      cryptos.forEach(function (crypto) {\n        _this._switch.connection.crypto(crypto.tag, crypto.encrypt);\n      });\n    } // Attach private network protector\n\n\n    if (_this._modules.connProtector) {\n      _this._switch.protector = _this._modules.connProtector;\n    } else if (process.env.LIBP2P_FORCE_PNET) {\n      throw new Error('Private network is enforced, but no protector was provided');\n    } // dht provided components (peerRouting, contentRouting, dht)\n\n\n    if (_this._config.EXPERIMENTAL.dht) {\n      var DHT = _this._modules.dht;\n      _this._dht = new DHT(_this._switch, {\n        kBucketSize: _this._config.dht.kBucketSize || 20,\n        // TODO make datastore an option of libp2p itself so\n        // that other things can use it as well\n        datastore: dht.datastore\n      });\n    } // enable/disable pubsub\n\n\n    if (_this._config.EXPERIMENTAL.pubsub) {\n      _this.pubsub = pubsub(_assertThisInitialized(_assertThisInitialized(_this)));\n    } // Attach remaining APIs\n\n\n    _this.peerRouting = peerRouting(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.contentRouting = contentRouting(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.dht = dht(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._getPeerInfo = getPeerInfo(_assertThisInitialized(_assertThisInitialized(_this))); // Mount default protocols\n\n    Ping.mount(_this._switch);\n    return _this;\n  }\n  /*\n   * Start the libp2p node\n   *   - create listeners on the multiaddrs the Peer wants to listen\n   */\n\n\n  _createClass(Node, [{\n    key: \"start\",\n    value: function start(callback) {\n      var _this2 = this;\n\n      if (!this._modules.transport) {\n        return callback(new Error('no transports were present'));\n      }\n\n      var ws; // so that we can have webrtc-star addrs without adding manually the id\n\n      var maOld = [];\n      var maNew = [];\n      this.peerInfo.multiaddrs.toArray().forEach(function (ma) {\n        if (!ma.getPeerId()) {\n          maOld.push(ma);\n          maNew.push(ma.encapsulate('/ipfs/' + _this2.peerInfo.id.toB58String()));\n        }\n      });\n      this.peerInfo.multiaddrs.replace(maOld, maNew);\n      var multiaddrs = this.peerInfo.multiaddrs.toArray();\n\n      this._modules.transport.forEach(function (Transport) {\n        var t;\n\n        if (typeof Transport === 'function') {\n          t = new Transport();\n        } else {\n          t = Transport;\n        }\n\n        if (t.filter(multiaddrs).length > 0) {\n          _this2._switch.transport.add(t.tag || t.constructor.name, t);\n        } else if (WebSockets.isWebSockets(t)) {\n          // TODO find a cleaner way to signal that a transport is always used\n          // for dialing, even if no listener\n          ws = t;\n        }\n\n        _this2._transport.push(t);\n      });\n\n      series([function (cb) {\n        _this2.connectionManager.start();\n\n        _this2._switch.start(cb);\n      }, function (cb) {\n        if (ws) {\n          // always add dialing on websockets\n          _this2._switch.transport.add(ws.tag || ws.constructor.name, ws);\n        } // all transports need to be setup before discover starts\n\n\n        if (_this2._modules.peerDiscovery) {\n          each(_this2._modules.peerDiscovery, function (D, _cb) {\n            var config = {};\n\n            if (D.tag && _this2._config.peerDiscovery && _this2._config.peerDiscovery[D.tag]) {\n              config = _this2._config.peerDiscovery[D.tag];\n            } // If not configured to be enabled/disabled then enable by default\n\n\n            var enabled = config.enabled == null ? true : config.enabled; // If enabled then start it\n\n            if (enabled) {\n              var d;\n\n              if (typeof D === 'function') {\n                d = new D(Object.assign({}, config, {\n                  peerInfo: _this2.peerInfo\n                }));\n              } else {\n                d = D;\n              }\n\n              d.on('peer', function (peerInfo) {\n                return _this2.emit('peer:discovery', peerInfo);\n              });\n\n              _this2._discovery.push(d);\n\n              d.start(_cb);\n            } else {\n              _cb();\n            }\n          }, cb);\n        } else {\n          cb();\n        }\n      }, function (cb) {\n        // TODO: chicken-and-egg problem #1:\n        // have to set started here because DHT requires libp2p is already started\n        _this2._isStarted = true;\n\n        if (_this2._dht) {\n          _this2._dht.start(cb);\n        } else {\n          cb();\n        }\n      }, function (cb) {\n        // TODO: chicken-and-egg problem #2:\n        // have to set started here because FloodSub requires libp2p is already started\n        if (_this2._floodSub) {\n          _this2._floodSub.start(cb);\n        } else {\n          cb();\n        }\n      }, function (cb) {\n        // detect which multiaddrs we don't have a transport for and remove them\n        var multiaddrs = _this2.peerInfo.multiaddrs.toArray();\n\n        multiaddrs.forEach(function (multiaddr) {\n          if (!multiaddr.toString().match(/\\/p2p-circuit($|\\/)/) && !_this2._transport.find(function (transport) {\n            return transport.filter(multiaddr).length > 0;\n          })) {\n            _this2.peerInfo.multiaddrs.delete(multiaddr);\n          }\n        });\n        cb();\n      }, function (cb) {\n        _this2.emit('start');\n\n        cb();\n      }], callback);\n    }\n    /*\n     * Stop the libp2p node by closing its listeners and open connections\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      var _this3 = this;\n\n      series([function (cb) {\n        if (_this3._modules.peerDiscovery) {\n          // stop all discoveries before continuing with shutdown\n          return parallel(_this3._discovery.map(function (d) {\n            return function (_cb) {\n              return d.stop(function () {\n                _cb();\n              });\n            };\n          }), cb);\n        }\n\n        cb();\n      }, function (cb) {\n        if (_this3._floodSub) {\n          return _this3._floodSub.stop(cb);\n        }\n\n        cb();\n      }, function (cb) {\n        if (_this3._dht) {\n          return _this3._dht.stop(cb);\n        }\n\n        cb();\n      }, function (cb) {\n        _this3.connectionManager.stop();\n\n        _this3._switch.stop(cb);\n      }, function (cb) {\n        _this3.emit('stop');\n\n        cb();\n      }], function (err) {\n        _this3._isStarted = false;\n        callback(err);\n      });\n    }\n  }, {\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this._isStarted;\n    }\n  }, {\n    key: \"dial\",\n    value: function dial(peer, callback) {\n      var _this4 = this;\n\n      assert(this.isStarted(), NOT_STARTED_ERROR_MESSAGE);\n\n      this._getPeerInfo(peer, function (err, peerInfo) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this4._switch.dial(peerInfo, function (err) {\n          if (err) {\n            return callback(err);\n          }\n\n          _this4.peerBook.put(peerInfo);\n\n          callback();\n        });\n      });\n    }\n  }, {\n    key: \"dialProtocol\",\n    value: function dialProtocol(peer, protocol, callback) {\n      var _this5 = this;\n\n      assert(this.isStarted(), NOT_STARTED_ERROR_MESSAGE);\n\n      if (typeof protocol === 'function') {\n        callback = protocol;\n        protocol = undefined;\n      }\n\n      this._getPeerInfo(peer, function (err, peerInfo) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this5._switch.dial(peerInfo, protocol, function (err, conn) {\n          if (err) {\n            return callback(err);\n          }\n\n          _this5.peerBook.put(peerInfo);\n\n          callback(null, conn);\n        });\n      });\n    }\n  }, {\n    key: \"hangUp\",\n    value: function hangUp(peer, callback) {\n      var _this6 = this;\n\n      assert(this.isStarted(), NOT_STARTED_ERROR_MESSAGE);\n\n      this._getPeerInfo(peer, function (err, peerInfo) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this6._switch.hangUp(peerInfo, callback);\n      });\n    }\n  }, {\n    key: \"ping\",\n    value: function ping(peer, callback) {\n      var _this7 = this;\n\n      if (!this.isStarted()) {\n        return callback(new Error(NOT_STARTED_ERROR_MESSAGE));\n      }\n\n      this._getPeerInfo(peer, function (err, peerInfo) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, new Ping(_this7._switch, peerInfo));\n      });\n    }\n  }, {\n    key: \"handle\",\n    value: function handle(protocol, handlerFunc, matchFunc) {\n      this._switch.handle(protocol, handlerFunc, matchFunc);\n    }\n  }, {\n    key: \"unhandle\",\n    value: function unhandle(protocol) {\n      this._switch.unhandle(protocol);\n    }\n  }]);\n\n  return Node;\n}(EventEmitter);\n\nmodule.exports = Node;","map":null,"metadata":{},"sourceType":"script"}