{"ast":null,"code":"'use strict';\n\nvar waterfall = require('async/waterfall');\n\nvar createIsLink = require('../util/createIsLink');\n\nvar createUtil = require('../util/createUtil');\n\nmodule.exports = createResolver;\n\nfunction createResolver(multicodec, EthObjClass, mapFromEthObject) {\n  var util = createUtil(multicodec, EthObjClass);\n  var resolver = {\n    multicodec: multicodec,\n    defaultHashAlg: 'keccak-256',\n    resolve: resolve,\n    tree: tree,\n    isLink: createIsLink(resolve),\n    _resolveFromEthObject: resolveFromEthObject,\n    _treeFromEthObject: treeFromEthObject,\n    _mapFromEthObject: mapFromEthObject\n  };\n  return {\n    resolver: resolver,\n    util: util\n    /*\n     * tree: returns a flattened array with paths: values of the project. options\n     * are option (i.e. nestness)\n     */\n\n  };\n\n  function tree(binaryBlob, options, callback) {\n    // parse arguments\n    if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    waterfall([function (cb) {\n      return util.deserialize(binaryBlob, cb);\n    }, function (ethObj, cb) {\n      return treeFromEthObject(ethObj, options, cb);\n    }], callback);\n  }\n\n  function treeFromEthObject(ethObj, options, callback) {\n    waterfall([function (cb) {\n      return mapFromEthObject(ethObj, options, cb);\n    }, function (tuples, cb) {\n      return cb(null, tuples.map(function (tuple) {\n        return tuple.path;\n      }));\n    }], callback);\n  }\n  /*\n   * resolve: receives a path and a binary blob and returns the value on path,\n   * throw if not possible. `binaryBlob`` is an Ethereum binary block.\n   */\n\n\n  function resolve(binaryBlob, path, callback) {\n    waterfall([function (cb) {\n      return util.deserialize(binaryBlob, cb);\n    }, function (ethObj, cb) {\n      return resolveFromEthObject(ethObj, path, cb);\n    }], callback);\n  }\n\n  function resolveFromEthObject(ethObj, path, callback) {\n    // root\n    if (!path || path === '/') {\n      var result = {\n        value: ethObj,\n        remainderPath: ''\n      };\n      return callback(null, result);\n    } // check tree results\n\n\n    mapFromEthObject(ethObj, {}, function (err, paths) {\n      if (err) return callback(err); // parse path\n\n      var pathParts = path.split('/'); // find potential matches\n\n      var matches = paths.filter(function (child) {\n        return child.path === path.slice(0, child.path.length);\n      }); // only match whole path chunks\n\n      matches = matches.filter(function (child) {\n        return child.path.split('/').every(function (part, index) {\n          return part === pathParts[index];\n        });\n      }); // take longest match\n\n      var sortedMatches = matches.sort(function (a, b) {\n        return b.path.length - a.path.length;\n      });\n      var treeResult = sortedMatches[0];\n\n      if (!treeResult) {\n        var _err = new Error('Path not found (\"' + path + '\").');\n\n        return callback(_err);\n      } // slice off remaining path (after match and following slash)\n\n\n      var remainderPath = path.slice(treeResult.path.length + 1);\n      var result = {\n        value: treeResult.value,\n        remainderPath: remainderPath\n      };\n      return callback(null, result);\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"script"}