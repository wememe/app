{"ast":null,"code":"'use strict';\n\nvar eachSeries = require('async/eachSeries');\n\nvar eachOfSeries = require('async/eachOfSeries');\n\nvar waterfall = require('async/waterfall');\n\nvar createQueue = require('async/queue');\n\nvar writable = require('pull-write');\n\nvar pushable = require('pull-pushable');\n\nvar DirFlat = require('./dir-flat');\n\nvar flatToShard = require('./flat-to-shard');\n\nvar Dir = require('./dir');\n\nmodule.exports = createTreeBuilder;\nvar defaultOptions = {\n  wrap: false,\n  shardSplitThreshold: 1000,\n  onlyHash: false\n};\n\nfunction createTreeBuilder(ipld, _options) {\n  var options = Object.assign({}, defaultOptions, _options);\n  var queue = createQueue(consumeQueue, 1); // returned stream\n\n  var stream = createStream(); // root node\n\n  var tree = DirFlat({\n    path: '',\n    root: true,\n    dir: true,\n    dirty: false,\n    flat: true\n  }, options);\n  return {\n    flush: flushRoot,\n    stream: getStream\n  };\n\n  function consumeQueue(action, callback) {\n    var args = action.args.concat(function () {\n      action.cb.apply(null, arguments);\n      callback();\n    });\n    action.fn.apply(null, args);\n  }\n\n  function getStream() {\n    return stream;\n  }\n\n  function createStream() {\n    var sink = writable(write, null, 1, ended);\n    var source = pushable();\n    return {\n      sink: sink,\n      source: source\n    };\n\n    function write(elems, callback) {\n      eachSeries(elems, function (elem, callback) {\n        queue.push({\n          fn: addToTree,\n          args: [elem],\n          cb: function cb(err) {\n            if (err) {\n              callback(err);\n            } else {\n              source.push(elem);\n              callback();\n            }\n          }\n        });\n      }, callback);\n    }\n\n    function ended(err) {\n      flushRoot(function (flushErr) {\n        source.end(flushErr || err);\n      });\n    }\n  } // ---- Add to tree\n\n\n  function addToTree(elem, callback) {\n    var pathElems = (elem.path || '').split('/').filter(notEmpty);\n    var parent = tree;\n    var lastIndex = pathElems.length - 1;\n    var currentPath = '';\n    eachOfSeries(pathElems, function (pathElem, index, callback) {\n      if (currentPath) {\n        currentPath += '/';\n      }\n\n      currentPath += pathElem;\n      var last = index === lastIndex;\n      parent.dirty = true;\n      parent.multihash = null;\n      parent.size = null;\n\n      if (last) {\n        waterfall([function (callback) {\n          return parent.put(pathElem, elem, callback);\n        }, function (callback) {\n          return flatToShard(null, parent, options.shardSplitThreshold, options, callback);\n        }, function (newRoot, callback) {\n          tree = newRoot;\n          callback();\n        }], callback);\n      } else {\n        parent.get(pathElem, function (err, treeNode) {\n          if (err) {\n            callback(err);\n            return; // early\n          }\n\n          var dir = treeNode;\n\n          if (!dir || !(dir instanceof Dir)) {\n            dir = DirFlat({\n              dir: true,\n              parent: parent,\n              parentKey: pathElem,\n              path: currentPath,\n              dirty: true,\n              flat: true\n            }, options);\n          }\n\n          var parentDir = parent;\n          parent = dir;\n          parentDir.put(pathElem, dir, callback);\n        });\n      }\n    }, callback);\n  } // ---- Flush\n\n\n  function flushRoot(callback) {\n    queue.push({\n      fn: flush,\n      args: ['', tree],\n      cb: function cb(err, node) {\n        if (err) {\n          callback(err);\n        } else {\n          callback(null, node && node.multihash);\n        }\n      }\n    });\n  }\n\n  function flush(path, tree, callback) {\n    if (tree.dir) {\n      if (tree.root && tree.childCount() > 1 && !options.wrap) {\n        callback(new Error('detected more than one root'));\n        return; // early\n      }\n\n      tree.eachChildSeries(function (key, child, callback) {\n        flush(path ? path + '/' + key : key, child, callback);\n      }, function (err) {\n        if (err) {\n          callback(err);\n          return; // early\n        }\n\n        flushDir(path, tree, callback);\n      });\n    } else {\n      // leaf node, nothing to do here\n      process.nextTick(callback);\n    }\n  }\n\n  function flushDir(path, tree, callback) {\n    // don't create a wrapping node unless the user explicitely said so\n    if (tree.root && !options.wrap) {\n      tree.onlyChild(function (err, onlyChild) {\n        if (err) {\n          callback(err);\n          return; // early\n        }\n\n        callback(null, onlyChild);\n      });\n      return; // early\n    }\n\n    if (!tree.dirty) {\n      callback(null, tree.multihash);\n      return; // early\n    } // don't flush directory unless it's been modified\n\n\n    tree.dirty = false;\n    tree.flush(path, ipld, stream.source, function (err, node) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, node);\n      }\n    });\n  }\n}\n\nfunction notEmpty(str) {\n  return Boolean(str);\n}","map":null,"metadata":{},"sourceType":"script"}