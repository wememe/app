{"ast":null,"code":"'use strict';\n\nvar Block = require('ipfs-block');\n\nvar multihash = require('multihashes');\n\nvar multihashing = require('multihashing-async');\n\nvar CID = require('cids');\n\nvar waterfall = require('async/waterfall');\n\nvar setImmediate = require('async/setImmediate');\n\nvar promisify = require('promisify-es6');\n\nvar errCode = require('err-code');\n\nmodule.exports = function block(self) {\n  return {\n    get: promisify(function (cid, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n\n      try {\n        cid = cleanCid(cid);\n      } catch (err) {\n        return setImmediate(function () {\n          return callback(errCode(err, 'ERR_INVALID_CID'));\n        });\n      }\n\n      if (options.preload !== false) {\n        self._preload(cid);\n      }\n\n      self._blockService.get(cid, callback);\n    }),\n    put: promisify(function (block, options, callback) {\n      callback = callback || function noop() {};\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n\n      if (Array.isArray(block)) {\n        return callback(new Error('Array is not supported'));\n      }\n\n      waterfall([function (cb) {\n        if (Block.isBlock(block)) {\n          return cb(null, block);\n        }\n\n        if (options.cid && CID.isCID(options.cid)) {\n          return cb(null, new Block(block, options.cid));\n        }\n\n        var mhtype = options.mhtype || 'sha2-256';\n        var format = options.format || 'dag-pb';\n        var cidVersion = options.version || 0; // const mhlen = options.mhlen || 0\n\n        multihashing(block, mhtype, function (err, multihash) {\n          if (err) {\n            return cb(err);\n          }\n\n          cb(null, new Block(block, new CID(cidVersion, format, multihash)));\n        });\n      }, function (block, cb) {\n        return self._blockService.put(block, function (err) {\n          if (err) {\n            return cb(err);\n          }\n\n          if (options.preload !== false) {\n            self._preload(block.cid);\n          }\n\n          cb(null, block);\n        });\n      }], callback);\n    }),\n    rm: promisify(function (cid, callback) {\n      try {\n        cid = cleanCid(cid);\n      } catch (err) {\n        return setImmediate(function () {\n          return callback(errCode(err, 'ERR_INVALID_CID'));\n        });\n      }\n\n      self._blockService.delete(cid, callback);\n    }),\n    stat: promisify(function (cid, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n\n      try {\n        cid = cleanCid(cid);\n      } catch (err) {\n        return setImmediate(function () {\n          return callback(errCode(err, 'ERR_INVALID_CID'));\n        });\n      }\n\n      if (options.preload !== false) {\n        self._preload(cid);\n      }\n\n      self._blockService.get(cid, function (err, block) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, {\n          key: multihash.toB58String(cid.multihash),\n          size: block.data.length\n        });\n      });\n    })\n  };\n};\n\nfunction cleanCid(cid) {\n  if (CID.isCID(cid)) {\n    return cid;\n  } // CID constructor knows how to do the cleaning :)\n\n\n  return new CID(cid);\n}","map":null,"metadata":{},"sourceType":"script"}