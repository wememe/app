{"ast":null,"code":"'use strict';\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar bip39 = require('bip39');\n\nvar hdkey = require('ethereumjs-wallet/hdkey');\n\nvar Tx = require('ethereumjs-tx');\n\nvar nacl = require('tweetnacl');\n\nnacl.util = require('tweetnacl-util');\n\nvar bs58 = require('bs58');\n\nvar sss = require('secrets.js');\n\nvar SimpleSigner = require('did-jwt').SimpleSigner;\n\nvar BASE_PATH = \"m/7696500'/0'/0'\";\nvar MM_PATH = \"m/44'/60'/0'/0\";\n\nvar Keyring = function () {\n  function Keyring() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    (0, _classCallCheck3.default)(this, Keyring);\n    opts.mnemonic = opts.mnemonic || bip39.generateMnemonic();\n\n    this._initKeys(opts);\n  }\n\n  (0, _createClass3.default)(Keyring, [{\n    key: 'createShares',\n    value: function () {\n      var _ref = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee(dids, publicKeys) {\n        var amount, theshold, entropyStr, shares, nonce;\n        return _regenerator2.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                amount = 3;\n                theshold = 2;\n\n                if (!(dids.length !== amount && publicKeys.length !== amount)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw new Error('There needs to be exactly ' + amount + ' dids and corresponding publicKeys');\n\n              case 4:\n                entropyStr = bip39.mnemonicToEntropy(this.mnemonic).toString('hex');\n                _context.next = 7;\n                return sss.share(entropyStr, amount, theshold);\n\n              case 7:\n                shares = _context.sent;\n                nonce = randomNonce(); // we need to add 0 to the end of the shares because they are of odd length\n\n                return _context.abrupt('return', {\n                  nonce: nacl.util.encodeBase64(nonce),\n                  ciphertexts: [this.encrypt(Buffer.concat([didToBuffer(dids[0]), Buffer.from(shares[0] + '0', 'hex')]), publicKeys[0], nonce).ciphertext, this.encrypt(Buffer.concat([didToBuffer(dids[1]), Buffer.from(shares[1] + '0', 'hex')]), publicKeys[1], nonce).ciphertext, this.encrypt(Buffer.concat([didToBuffer(dids[2]), Buffer.from(shares[2] + '0', 'hex')]), publicKeys[2], nonce).ciphertext]\n                });\n\n              case 10:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function createShares(_x2, _x3) {\n        return _ref.apply(this, arguments);\n      }\n\n      return createShares;\n    }()\n  }, {\n    key: 'encrypt',\n    value: function encrypt(msg, toPublic, nonce) {\n      nonce = nonce || randomNonce();\n      toPublic = nacl.util.decodeBase64(toPublic);\n\n      if (typeof msg === 'string') {\n        msg = nacl.util.decodeUTF8(msg);\n      }\n\n      var ciphertext = nacl.box(msg, nonce, toPublic, this.asymEncryptionKey.secretKey);\n      return {\n        nonce: nacl.util.encodeBase64(nonce),\n        ciphertext: nacl.util.encodeBase64(ciphertext)\n      };\n    }\n  }, {\n    key: 'decrypt',\n    value: function decrypt(ciphertext, fromPublic, nonce, toBuffer) {\n      fromPublic = nacl.util.decodeBase64(fromPublic);\n      ciphertext = nacl.util.decodeBase64(ciphertext);\n      nonce = nacl.util.decodeBase64(nonce);\n      var cleartext = nacl.box.open(ciphertext, nonce, fromPublic, this.asymEncryptionKey.secretKey);\n\n      if (toBuffer) {\n        return cleartext ? Buffer.from(cleartext) : null;\n      }\n\n      return cleartext ? nacl.util.encodeUTF8(cleartext) : null;\n    }\n  }, {\n    key: 'decryptOneShare',\n    value: function decryptOneShare(recoveryNetwork, fromPublic, did) {\n      var didBuf = didToBuffer(did);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = (0, _getIterator3.default)(recoveryNetwork.ciphertexts), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var box = _step.value;\n          var cleartextBuf = this.decrypt(box, fromPublic, recoveryNetwork.nonce, true); // where we able to decrypt?\n          // check if encrypted did is our did\n\n          if (cleartextBuf && didBuf.equals(cleartextBuf.slice(0, didBuf.length))) {\n            // return the decrypted share, remove the trailing zero\n            return cleartextBuf.slice(didBuf.length, cleartextBuf.length + 1).toString('hex').slice(0, -1);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'symEncrypt',\n    value: function symEncrypt(msg, nonce) {\n      return symEncryptBase(msg, this.symEncryptionKey, nonce);\n    }\n  }, {\n    key: 'symDecrypt',\n    value: function symDecrypt(ciphertext, nonce, toBuffer) {\n      return symDecryptBase(ciphertext, this.symEncryptionKey, nonce, toBuffer);\n    }\n  }, {\n    key: 'getJWTSigner',\n    value: function getJWTSigner() {\n      return SimpleSigner(this.signingKey._hdkey._privateKey);\n    }\n  }, {\n    key: 'signManagementTx',\n    value: function signManagementTx(txParams) {\n      if (this.externalMgmtKey) throw new Error('Can not sign transaction if externalMgmtKey is set');\n      var privKey = this.managementKey.getWallet().getPrivateKey();\n      var tx = new Tx(txParams);\n      tx.sign(privKey);\n      return '0x' + tx.serialize().toString('hex');\n    }\n  }, {\n    key: 'getManagementAddress',\n    value: function getManagementAddress() {\n      if (this.externalMgmtKey) {\n        return this.managementKey;\n      }\n\n      return this.managementKey.getWallet().getChecksumAddressString();\n    }\n  }, {\n    key: 'getPublicKeys',\n    value: function getPublicKeys() {\n      return {\n        signingKey: this.signingKey._hdkey._publicKey.toString('hex'),\n        managementKey: this.externalMgmtKey ? this.managementKey : this.managementKey._hdkey._publicKey.toString('hex'),\n        asymEncryptionKey: nacl.util.encodeBase64(this.asymEncryptionKey.publicKey)\n      };\n    }\n  }, {\n    key: 'serialize',\n    value: function serialize() {\n      var obj = {\n        mnemonic: this.mnemonic\n      };\n\n      if (this.externalMgmtKey) {\n        obj.externalMgmtKey = this.managementKey;\n      }\n\n      return obj;\n    }\n  }, {\n    key: '_initKeys',\n    value: function _initKeys(_ref2) {\n      var mnemonic = _ref2.mnemonic,\n          externalMgmtKey = _ref2.externalMgmtKey;\n      this.mnemonic = mnemonic;\n      var seed = bip39.mnemonicToSeed(mnemonic);\n      var seedKey = hdkey.fromMasterSeed(seed);\n      var baseKey = seedKey.derivePath(BASE_PATH);\n      this.signingKey = baseKey.deriveChild(0);\n\n      var tmpEncKey = baseKey.deriveChild(2)._hdkey._privateKey;\n\n      this.asymEncryptionKey = nacl.box.keyPair.fromSecretKey(tmpEncKey);\n      this.symEncryptionKey = baseKey.deriveChild(3)._hdkey._privateKey;\n\n      if (externalMgmtKey) {\n        this.managementKey = externalMgmtKey;\n        this.externalMgmtKey = true;\n      } else {\n        // Management key is used to sign ethereum txs, so we use the MM base path\n        this.managementKey = seedKey.derivePath(MM_PATH).deriveChild(0);\n      }\n    }\n  }], [{\n    key: 'recoverKeyring',\n    value: function () {\n      var _ref3 = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee2(shares) {\n        var entropy;\n        return _regenerator2.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return sss.combine(shares);\n\n              case 2:\n                entropy = _context2.sent;\n                return _context2.abrupt('return', new Keyring({\n                  mnemonic: bip39.entropyToMnemonic(entropy)\n                }));\n\n              case 4:\n              case 'end':\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function recoverKeyring(_x4) {\n        return _ref3.apply(this, arguments);\n      }\n\n      return recoverKeyring;\n    }()\n  }]);\n  return Keyring;\n}();\n\nvar randomNonce = function randomNonce() {\n  return nacl.randomBytes(24);\n};\n\nvar didToBuffer = function didToBuffer(didUri) {\n  var hash = didUri.split(':')[2];\n  return bs58.decode(hash);\n};\n\nvar symEncryptBase = function symEncryptBase(msg, symKey, nonce) {\n  nonce = nonce || randomNonce();\n\n  if (typeof msg === 'string') {\n    msg = nacl.util.decodeUTF8(msg);\n  }\n\n  var ciphertext = nacl.secretbox(msg, nonce, symKey);\n  return {\n    nonce: nacl.util.encodeBase64(nonce),\n    ciphertext: nacl.util.encodeBase64(ciphertext)\n  };\n};\n\nvar symDecryptBase = function symDecryptBase(ciphertext, symKey, nonce, toBuffer) {\n  ciphertext = nacl.util.decodeBase64(ciphertext);\n  nonce = nacl.util.decodeBase64(nonce);\n  var cleartext = nacl.secretbox.open(ciphertext, nonce, symKey);\n\n  if (toBuffer) {\n    return cleartext ? Buffer.from(cleartext) : null;\n  }\n\n  return cleartext ? nacl.util.encodeUTF8(cleartext) : null;\n};\n\nmodule.exports = Keyring;","map":null,"metadata":{},"sourceType":"script"}