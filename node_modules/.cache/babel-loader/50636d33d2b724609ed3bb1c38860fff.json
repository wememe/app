{"ast":null,"code":"module.exports = Level;\n\nvar AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN;\n\nvar util = require('util');\n\nvar Iterator = require('./iterator');\n\nvar xtend = require('xtend');\n\nfunction Level(location) {\n  if (!(this instanceof Level)) return new Level(location);\n  AbstractLevelDOWN.call(this, location);\n}\n\nutil.inherits(Level, AbstractLevelDOWN);\n/**\n * Open a database and optionally create if missing.\n *\n * @param {Object} [options]  storeName and other options passed to indexedDB\n *                            open and createObjectStore.\n * @param {Function} callback  First parameter will be an error object or null.\n */\n\nLevel.prototype._open = function (options, callback) {\n  var self = this; // assume createIfMissing and errorIfExists are initialized by abstract-leveldown\n\n  this._idbOpts = xtend({\n    storeName: this.location,\n    keyEncoding: 'none',\n    valueEncoding: 'none'\n  }, options); // support passing an open database\n\n  if (this._idbOpts.idb) {\n    onsuccess(this._idbOpts.idb);\n  } else {\n    var req = indexedDB.open(this.location); // use the databases current version\n\n    req.onerror = onerror;\n\n    req.onsuccess = function () {\n      onsuccess(req.result);\n    };\n  }\n\n  function onerror(ev) {\n    callback(ev.target.error);\n  } // if the store does not exist and createIfMissing is true, create the object store\n\n\n  function onsuccess(db) {\n    self._db = db;\n\n    var exists = self._db.objectStoreNames.contains(self._idbOpts.storeName);\n\n    if (options.errorIfExists && exists) {\n      self._db.close();\n\n      callback(new Error('store already exists'));\n      return;\n    }\n\n    if (!options.createIfMissing && !exists) {\n      self._db.close();\n\n      callback(new Error('store does not exist'));\n      return;\n    }\n\n    if (options.createIfMissing && !exists) {\n      self._db.close();\n\n      var req2 = indexedDB.open(self.location, self._db.version + 1);\n\n      req2.onerror = function (ev) {\n        callback(ev.target.error);\n      };\n\n      req2.onupgradeneeded = function () {\n        var db = req2.result;\n        db.createObjectStore(self._idbOpts.storeName, self._idbOpts);\n      };\n\n      req2.onsuccess = function () {\n        self._db = req2.result;\n        callback(null, self);\n      };\n\n      return;\n    }\n\n    callback(null, self);\n  }\n};\n\nLevel.prototype._get = function (key, options, callback) {\n  options = xtend(this._idbOpts, options);\n  var origKey = key; // support binary keys for any iterable type via array (ArrayBuffers as keys are only supported in IndexedDB Second Edition)\n\n  if (options.keyEncoding === 'binary' && !Array.isArray(key)) key = Array.prototype.slice.call(key);\n\n  var tx = this._db.transaction(this._idbOpts.storeName);\n\n  var req = tx.objectStore(this._idbOpts.storeName).openCursor(IDBKeyRange.only(key));\n\n  tx.onabort = function () {\n    callback(tx.error);\n  };\n\n  req.onsuccess = function () {\n    var cursor = req.result;\n\n    if (cursor) {\n      var value = cursor.value; // automatically convert Uint8Array values to Buffer\n\n      if (value instanceof Uint8Array) value = new Buffer(value);\n      if (options.valueEncoding === 'binary' && !Buffer.isBuffer(value)) value = new Buffer(value);\n\n      if (options.asBuffer && !Buffer.isBuffer(value)) {\n        if (value == null) value = new Buffer(0);else if (typeof value === 'string') value = new Buffer(value); // defaults to utf8, should the encoding be utf16? (DOMString)\n        else if (typeof value === 'boolean') value = new Buffer(String(value)); // compatible with leveldb\n          else if (typeof value === 'number') value = new Buffer(String(value)); // compatible with leveldb\n            else if (Array.isArray(value)) value = new Buffer(String(value)); // compatible with leveldb\n              else if (value instanceof Uint8Array) value = new Buffer(value);else return void callback(new TypeError('can\\'t coerce `' + value.constructor.name + '` into a Buffer'));\n      }\n\n      return void callback(null, value, origKey);\n    } else {\n      // 'NotFound' error, consistent with LevelDOWN API\n      return void callback(new Error('NotFound'));\n    }\n  };\n};\n\nLevel.prototype._del = function (key, options, callback) {\n  options = xtend(this._idbOpts, options); // support binary keys for any iterable type via array (ArrayBuffers as keys are only supported in IndexedDB Second Edition)\n\n  if (options.keyEncoding === 'binary' && !Array.isArray(key)) key = Array.prototype.slice.call(key);\n  var mode = 'readwrite';\n\n  if (options.sync === true) {\n    mode = 'readwriteflush'; // only supported in Firefox (with \"dom.indexedDB.experimental\" pref set to true)\n  }\n\n  var tx = this._db.transaction(this._idbOpts.storeName, mode);\n\n  var req = tx.objectStore(this._idbOpts.storeName).delete(key);\n\n  tx.onabort = function () {\n    callback(tx.error);\n  };\n\n  tx.oncomplete = function () {\n    callback();\n  };\n};\n\nLevel.prototype._put = function (key, value, options, callback) {\n  options = xtend(this._idbOpts, options); // support binary keys for any iterable type via array (ArrayBuffers as keys are only supported in IndexedDB Second Edition)\n\n  if (options.keyEncoding === 'binary' && !Array.isArray(key)) key = Array.prototype.slice.call(key);\n  var mode = 'readwrite';\n\n  if (options.sync === true) {\n    mode = 'readwriteflush'; // only supported in Firefox (with \"dom.indexedDB.experimental\" pref set to true)\n  }\n\n  var tx = this._db.transaction(this._idbOpts.storeName, mode);\n\n  var req = tx.objectStore(this._idbOpts.storeName).put(value, key);\n\n  tx.onabort = function () {\n    callback(tx.error);\n  };\n\n  tx.oncomplete = function () {\n    callback();\n  };\n};\n\nLevel.prototype._iterator = function (options) {\n  return new Iterator(this, options);\n}; // only support sync: true on batch level, not operation level\n\n\nLevel.prototype._batch = function (array, options, callback) {\n  if (array.length === 0) return process.nextTick(callback);\n  var mode = 'readwrite';\n\n  if (options.sync === true) {\n    mode = 'readwriteflush'; // only supported in Firefox (with \"dom.indexedDB.experimental\" pref set to true)\n  }\n\n  var tx = this._db.transaction(this._idbOpts.storeName, mode);\n\n  var store = tx.objectStore(this._idbOpts.storeName);\n\n  tx.onabort = function () {\n    callback(tx.error);\n  };\n\n  tx.oncomplete = function () {\n    callback();\n  };\n\n  array.forEach(function (currentOp) {\n    var opts = xtend(options, currentOp); // support binary keys for any iterable type via array (ArrayBuffers as keys are only supported in IndexedDB Second Edition)\n\n    if (opts.keyEncoding === 'binary' && !Array.isArray(currentOp.key)) currentOp.key = Array.prototype.slice.call(currentOp.key);\n\n    if (currentOp.type === 'del') {\n      store.delete(currentOp.key);\n    } else {\n      store.put(currentOp.value, currentOp.key);\n    }\n  });\n};\n\nLevel.prototype._close = function (callback) {\n  this._db.close();\n\n  process.nextTick(callback);\n};\n\nLevel.prototype._approximateSize = function (start, end, callback) {\n  var err = new Error('Not implemented');\n  if (callback) return void process.nextTick(function () {\n    callback(err);\n  });\n  throw err;\n};\n/**\n * Destroy the object store and the database if no other object stores exist.\n *\n * @param {String|Object} location  Name of the database or a database instance.\n */\n\n\nLevel.destroy = function (db, callback) {\n  var idbOpts;\n\n  if (db != null && typeof db === 'object') {\n    idbOpts = xtend({\n      location: db.location,\n      storeName: db.location\n    }, db._idbOpts);\n  } else if (typeof db === 'string') {\n    idbOpts = {\n      location: db,\n      storeName: db\n    };\n  } else {\n    throw new TypeError('location must be a string or an object');\n  }\n\n  if (typeof idbOpts.location !== 'string') throw new TypeError('location must be a string');\n  if (typeof idbOpts.storeName !== 'string') throw new TypeError('db.storeName must be a string');\n  var req = indexedDB.open(idbOpts.location); // use the databases current version\n\n  req.onerror = function (ev) {\n    callback(ev.target.error);\n  }; // if the database contains no other stores, delete the database as well\n\n\n  req.onsuccess = function () {\n    var db = req.result;\n\n    function deleteDatabase(name) {\n      var req2 = indexedDB.deleteDatabase(name);\n\n      req2.onerror = function (ev) {\n        callback(ev.target.error);\n      };\n\n      req2.onsuccess = function () {\n        callback();\n      };\n    }\n\n    db.close();\n    if (db.objectStoreNames.length === 0) return void deleteDatabase(idbOpts.location);\n    if (!db.objectStoreNames.contains(idbOpts.storeName)) return void callback(); // delete object store, and if no object stores remain, delete database\n\n    var req2 = indexedDB.open(idbOpts.location, db.version + 1);\n\n    req2.onerror = function (ev) {\n      callback(ev.target.error);\n    };\n\n    req2.onupgradeneeded = function () {\n      db = req2.result;\n      db.deleteObjectStore(idbOpts.storeName);\n    };\n\n    req2.onsuccess = function () {\n      db = req2.result;\n      db.close();\n      if (db.objectStoreNames.length === 0) deleteDatabase(idbOpts.location);else callback();\n    };\n  };\n};","map":null,"metadata":{},"sourceType":"script"}