{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar KeyValueStore =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Please use **box.profileStore** or **box.profileStore** to get the instance of this class\n   */\n  function KeyValueStore(orbitdb, name, ensureConnected) {\n    (0, _classCallCheck2.default)(this, KeyValueStore);\n    this._orbitdb = orbitdb;\n    this._name = name;\n    this._ensureConnected = ensureConnected;\n  }\n  /**\n   * Get the value of the given key\n   *\n   * @param     {String}    key                     the key\n   * @return    {String}                            the value associated with the key\n   */\n\n\n  (0, _createClass2.default)(KeyValueStore, [{\n    key: \"get\",\n    value: function () {\n      var _get = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee(key) {\n        var dbGetRes;\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this._requireLoad();\n\n                _context.next = 3;\n                return this._db.get(key);\n\n              case 3:\n                dbGetRes = _context.sent;\n                return _context.abrupt(\"return\", dbGetRes ? dbGetRes.value : dbGetRes);\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function get(_x) {\n        return _get.apply(this, arguments);\n      };\n    }()\n    /**\n     * Set a value for the given key\n     *\n     * @param     {String}    key                     the key\n     * @param     {String}    value                   the value\n     * @return    {Boolean}                           true if successful\n     */\n\n  }, {\n    key: \"set\",\n    value: function () {\n      var _set = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee2(key, value) {\n        var timeStamp;\n        return _regenerator.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._requireLoad();\n\n                this._ensureConnected();\n\n                timeStamp = new Date().getTime();\n                _context2.next = 5;\n                return this._db.put(key, {\n                  value: value,\n                  timeStamp: timeStamp\n                });\n\n              case 5:\n                return _context2.abrupt(\"return\", true);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function set(_x2, _x3) {\n        return _set.apply(this, arguments);\n      };\n    }()\n    /**\n     * Remove the value for the given key\n     *\n     * @param     {String}    key                     the key\n     * @return    {Boolean}                           true if successful\n     */\n\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee3(key) {\n        return _regenerator.default.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this._requireLoad();\n\n                this._ensureConnected();\n\n                _context3.next = 4;\n                return this._db.del(key);\n\n              case 4:\n                return _context3.abrupt(\"return\", true);\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      return function remove(_x4) {\n        return _remove.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"_sync\",\n    value: function () {\n      var _sync2 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee4(numRemoteEntries) {\n        var _this = this;\n\n        return _regenerator.default.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                this._requireLoad(); // let toid = null\n\n\n                if (!(numRemoteEntries === this._db._oplog.values.length)) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", Promise.resolve());\n\n              case 3:\n                _context4.next = 5;\n                return new Promise(function (resolve, reject) {\n                  if (!numRemoteEntries) {\n                    setTimeout(function () {\n                      _this._db.events.removeAllListeners('replicated');\n\n                      _this._db.events.removeAllListeners('replicate.progress');\n\n                      resolve();\n                    }, 3000);\n                  }\n\n                  _this._db.events.on('replicated', function () {\n                    if (numRemoteEntries === _this._db._oplog.values.length) resolve();\n                  });\n                  /*\n                  this._db.events.on('replicate.progress', (_x, _y, _z, num, max) => {\n                    if (toid) {\n                      clearTimeout(toid)\n                      toid = null\n                    }\n                    const total = numRemoteEntries || max\n                    if (num >= total) {\n                      this._db.events.on('replicated', resolve)\n                      listenerAdded = true\n                    }\n                  })\n                  */\n\n                });\n\n              case 5:\n                return _context4.abrupt(\"return\", this._db.address.toString());\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      return function _sync(_x5) {\n        return _sync2.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"_load\",\n    value: function () {\n      var _load2 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee5(odbAddress) {\n        return _regenerator.default.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this._orbitdb.keyvalue(odbAddress || this._name);\n\n              case 2:\n                this._db = _context5.sent;\n                _context5.next = 5;\n                return this._db.load();\n\n              case 5:\n                return _context5.abrupt(\"return\", this._db.address.toString());\n\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      return function _load(_x6) {\n        return _load2.apply(this, arguments);\n      };\n    }()\n  }, {\n    key: \"_requireLoad\",\n    value: function _requireLoad() {\n      if (!this._db) throw new Error('_load must be called before interacting with the store');\n    }\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee6() {\n        return _regenerator.default.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                this._requireLoad();\n\n                _context6.next = 3;\n                return this._db.close();\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      return function close() {\n        return _close.apply(this, arguments);\n      };\n    }()\n    /**\n     * Returns array of underlying log entries. In linearized order according to their Lamport clocks.\n     * Useful for generating a complete history of all operations on store.\n     *\n     *  @example\n     *  const log = store.log\n     *  const entry = log[0]\n     *  console.log(entry)\n     *  // { op: 'PUT', key: 'Name', value: 'Botbot', timeStamp: '1538575416068' }\n     *\n     * @return    {Array<Object>}     Array of ordered log entry objects\n     */\n\n  }, {\n    key: \"log\",\n    get: function get() {\n      return this._db._oplog.values.map(function (obj) {\n        return {\n          op: obj.payload.op,\n          key: obj.payload.key,\n          value: obj.payload.value ? obj.payload.value.value : null,\n          timeStamp: obj.payload.value ? obj.payload.value.timeStamp : null\n        };\n      });\n    }\n  }]);\n  return KeyValueStore;\n}();\n\nmodule.exports = KeyValueStore;","map":null,"metadata":{},"sourceType":"script"}