{"ast":null,"code":"'use strict';\n\nvar setImmediate = require('async/setImmediate');\n\nvar waterfall = require('async/waterfall');\n\nvar multihashing = require('multihashing-async');\n\nvar CID = require('cids');\n\nvar resolver = require('./resolver');\n\nvar gitUtil = require('./util/util');\n\nvar commit = require('./util/commit');\n\nvar tag = require('./util/tag');\n\nvar tree = require('./util/tree');\n\nexports = module.exports;\n\nexports.serialize = function (dagNode, callback) {\n  if (dagNode === null) {\n    setImmediate(function () {\n      return callback(new Error('dagNode passed to serialize was null'), null);\n    });\n    return;\n  }\n\n  if (Buffer.isBuffer(dagNode)) {\n    if (dagNode.slice(0, 4).toString() === 'blob') {\n      setImmediate(function () {\n        return callback(null, dagNode);\n      });\n    } else {\n      setImmediate(function () {\n        return callback(new Error('unexpected dagNode passed to serialize'), null);\n      });\n    }\n\n    return;\n  }\n\n  switch (dagNode.gitType) {\n    case 'commit':\n      commit.serialize(dagNode, callback);\n      break;\n\n    case 'tag':\n      tag.serialize(dagNode, callback);\n      break;\n\n    default:\n      // assume tree as a file named 'type' is legal\n      tree.serialize(dagNode, callback);\n  }\n};\n\nexports.deserialize = function (data, callback) {\n  var headLen = gitUtil.find(data, 0);\n  var head = data.slice(0, headLen).toString();\n  var typeLen = head.match(/([^ ]+) (\\d+)/);\n\n  if (!typeLen) {\n    setImmediate(function () {\n      return callback(new Error('invalid object header'), null);\n    });\n    return;\n  }\n\n  switch (typeLen[1]) {\n    case 'blob':\n      callback(null, data);\n      break;\n\n    case 'commit':\n      commit.deserialize(data.slice(headLen + 1), callback);\n      break;\n\n    case 'tag':\n      tag.deserialize(data.slice(headLen + 1), callback);\n      break;\n\n    case 'tree':\n      tree.deserialize(data.slice(headLen + 1), callback);\n      break;\n\n    default:\n      setImmediate(function () {\n        return callback(new Error('unknown object type ' + typeLen[1]), null);\n      });\n  }\n};\n/**\n * @callback CidCallback\n * @param {?Error} error - Error if getting the CID failed\n * @param {?CID} cid - CID if call was successful\n */\n\n/**\n * Get the CID of the DAG-Node.\n *\n * @param {Object} dagNode - Internal representation\n * @param {Object} [options] - Options to create the CID\n * @param {number} [options.version=1] - CID version number\n * @param {string} [options.hashAlg='sha1'] - Hashing algorithm\n * @param {CidCallback} callback - Callback that handles the return value\n * @returns {void}\n */\n\n\nexports.cid = function (dagNode, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  var hashAlg = options.hashAlg || resolver.defaultHashAlg;\n  var version = typeof options.version === 'undefined' ? 1 : options.version;\n  waterfall([function (cb) {\n    return exports.serialize(dagNode, cb);\n  }, function (serialized, cb) {\n    return multihashing(serialized, hashAlg, cb);\n  }, function (mh, cb) {\n    return cb(null, new CID(version, resolver.multicodec, mh));\n  }], callback);\n};","map":null,"metadata":{},"sourceType":"script"}