{"ast":null,"code":"'use strict';\n/* @flow */\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar stream = require('readable-stream');\n\nvar debug = require('debug');\n/* :: import type Multiplex from './index'\n\nexport type ChannelOpts = {\n  chunked?: bool,\n  halfOpen?: bool,\n  lazy?: bool\n}\n*/\n\n\nvar Channel =\n/*#__PURE__*/\nfunction (_stream$Duplex) {\n  _inherits(Channel, _stream$Duplex);\n\n  function Channel(name\n  /* : Buffer | string */\n  , plex\n  /* : Multiplex */\n  , opts\n  /* : ChannelOpts = {} */\n  ) {\n    var _this;\n\n    _classCallCheck(this, Channel);\n\n    var halfOpen = Boolean(opts.halfOpen);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Channel).call(this, {\n      allowHalfOpen: halfOpen\n    }));\n    _this.name = name;\n    _this.log = debug('mplex:channel:' + _this.name.toString());\n    _this.channel = 0;\n    _this.initiator = false;\n    _this.chunked = Boolean(opts.chunked);\n    _this.halfOpen = halfOpen;\n    _this.destroyed = false;\n    _this.finalized = false;\n    _this.local = true;\n    _this._multiplex = plex;\n    _this._dataHeader = 0;\n    _this._opened = false;\n    _this._awaitDrain = 0;\n    _this._lazy = Boolean(opts.lazy);\n    var finished = false;\n    var ended = false;\n\n    _this.log('open, halfOpen: ' + _this.halfOpen);\n\n    _this.once('end', function () {\n      _this.log('end');\n\n      _this._read(); // trigger drain\n\n\n      if (_this.destroyed) {\n        return;\n      }\n\n      ended = true;\n\n      if (finished) {\n        _this._finalize();\n      } else if (!_this.halfOpen) {\n        _this.end();\n      }\n    });\n\n    _this.once('finish', function onfinish() {\n      if (this.destroyed) {\n        return;\n      }\n\n      if (!this._opened) {\n        return this.once('open', onfinish);\n      }\n\n      if (this._lazy && this.initiator) {\n        this._open();\n      }\n\n      this._multiplex._send(this.channel << 3 | (this.initiator ? 4 : 3), null);\n\n      finished = true;\n\n      if (ended) {\n        this._finalize();\n      }\n    });\n\n    return _this;\n  }\n  /**\n   * Conditionally emit errors if we have listeners. All other\n   * events are sent to EventEmitter.emit\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {void}\n   */\n\n\n  _createClass(Channel, [{\n    key: \"emit\",\n    value: function emit(eventName) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (eventName === 'error' && !this._events.error) {\n        this.log.apply(this, ['error'].concat(args));\n      } else {\n        var _get2;\n\n        (_get2 = _get(_getPrototypeOf(Channel.prototype), \"emit\", this)).call.apply(_get2, [this, eventName].concat(args));\n      }\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy(err\n    /* : Error */\n    , callback) {\n      this.log('_destroy:' + (this.local ? 'local' : 'remote'));\n\n      if (this.local && this._opened) {\n        if (this._lazy && this.initiator) {\n          this._open();\n        }\n\n        var msg = err ? Buffer.from(err.message) : null;\n\n        try {\n          this._multiplex._send(this.channel << 3 | (this.initiator ? 6 : 5), msg);\n        } catch (e) {\n          /* do nothing */\n        }\n      }\n\n      this._finalize();\n\n      callback(err);\n    }\n  }, {\n    key: \"_finalize\",\n    value: function _finalize() {\n      if (this.finalized) {\n        return;\n      }\n\n      this.finalized = true;\n      this.emit('finalize');\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(data\n    /* : Buffer */\n    , enc\n    /* : string */\n    , cb\n    /* : () => void */\n    ) {\n      var _this2 = this;\n\n      this.log('write: ', data.length);\n\n      if (!this._opened) {\n        this.once('open', function () {\n          _this2._write(data, enc, cb);\n        });\n        return;\n      }\n\n      if (this.destroyed) {\n        cb();\n        return;\n      }\n\n      if (this._lazy && this.initiator) {\n        this._open();\n      }\n\n      var drained = this._multiplex._send(this._dataHeader, data);\n\n      if (drained) {\n        cb();\n        return;\n      }\n\n      this._multiplex._ondrain.push(cb);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      if (this._awaitDrain) {\n        var drained = this._awaitDrain;\n        this._awaitDrain = 0;\n\n        this._multiplex._onchanneldrain(drained);\n      }\n    }\n  }, {\n    key: \"_open\",\n    value: function _open() {\n      var buf = null;\n\n      if (Buffer.isBuffer(this.name)) {\n        buf = this.name;\n      } else if (this.name !== this.channel.toString()) {\n        buf = Buffer.from(this.name);\n      }\n\n      this._lazy = false;\n\n      this._multiplex._send(this.channel << 3 | 0, buf);\n    }\n  }, {\n    key: \"open\",\n    value: function open(channel\n    /* : number */\n    , initiator\n    /* : bool */\n    ) {\n      this.log('open: ' + channel);\n      this.channel = channel;\n      this.initiator = initiator;\n      this._dataHeader = channel << 3 | (initiator ? 2 : 1);\n      this._opened = true;\n      if (!this._lazy && this.initiator) this._open();\n      this.emit('open');\n    }\n  }]);\n\n  return Channel;\n}(stream.Duplex);\n\nmodule.exports = Channel;","map":null,"metadata":{},"sourceType":"script"}