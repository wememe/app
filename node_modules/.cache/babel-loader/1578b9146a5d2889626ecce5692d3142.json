{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar pWhilst = require('p-whilst');\n\nvar pMap = require('p-map');\n\nvar Entry = require('./entry');\n\nvar EntryIO =\n/*#__PURE__*/\nfunction () {\n  function EntryIO() {\n    _classCallCheck(this, EntryIO);\n  }\n\n  _createClass(EntryIO, null, [{\n    key: \"fetchParallel\",\n    // Fetch log graphs in parallel\n    value: function fetchParallel(ipfs, hashes, length) {\n      var exclude = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      var concurrency = arguments.length > 4 ? arguments[4] : undefined;\n      var timeout = arguments.length > 5 ? arguments[5] : undefined;\n      var onProgressCallback = arguments.length > 6 ? arguments[6] : undefined;\n\n      var fetchOne = function fetchOne(hash) {\n        return EntryIO.fetchAll(ipfs, hash, length, exclude, timeout, onProgressCallback);\n      };\n\n      var concatArrays = function concatArrays(arr1, arr2) {\n        return arr1.concat(arr2);\n      };\n\n      var flatten = function flatten(arr) {\n        return arr.reduce(concatArrays, []);\n      };\n\n      return pMap(hashes, fetchOne, {\n        concurrency: Math.max(concurrency || hashes.length, 1)\n      }).then(flatten); // Flatten the results\n    }\n    /**\n     * Fetch log entries sequentially\n     *\n     * @param {IPFS} [ipfs] An IPFS instance\n     * @param {string} [hash] Multihash of the entry to fetch\n     * @param {string} [parent] Parent of the node to be fetched\n     * @param {Object} [all] Entries to skip\n     * @param {Number} [amount=-1] How many entries to fetch\n     * @param {Number} [depth=0] Current depth of the recursion\n     * @param {function(hash, entry, parent, depth)} onProgressCallback\n     * @returns {Promise<Array<Entry>>}\n     */\n\n  }, {\n    key: \"fetchAll\",\n    value: function fetchAll(ipfs, hashes, amount) {\n      var exclude = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      var timeout = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n      var onProgressCallback = arguments.length > 5 ? arguments[5] : undefined;\n      var result = [];\n      var cache = {};\n      var loadingQueue = Array.isArray(hashes) ? hashes.slice() : [hashes]; // Add a multihash to the loading queue\n\n      var addToLoadingQueue = function addToLoadingQueue(e) {\n        return loadingQueue.push(e);\n      }; // Add entries that we don't need to fetch to the \"cache\"\n\n\n      var addToExcludeCache = function addToExcludeCache(e) {\n        return cache[e.hash] = e;\n      };\n\n      exclude.forEach(addToExcludeCache);\n\n      var shouldFetchMore = function shouldFetchMore() {\n        return loadingQueue.length > 0 && (result.length < amount || amount < 0);\n      };\n\n      var fetchEntry = function fetchEntry() {\n        var hash = loadingQueue.shift();\n\n        if (cache[hash]) {\n          return Promise.resolve();\n        }\n\n        return new Promise(function (resolve, reject) {\n          // Resolve the promise after a timeout (if given) in order to\n          // not get stuck loading a block that is unreachable\n          var timer = timeout ? setTimeout(function () {\n            console.warn(\"Warning: Couldn't fetch entry '\".concat(hash, \"', request timed out (\").concat(timeout, \"ms)\"));\n            resolve();\n          }, timeout) : null;\n\n          var addToResults = function addToResults(entry) {\n            clearTimeout(timer);\n\n            if (Entry.isEntry(entry)) {\n              entry.next.forEach(addToLoadingQueue);\n              result.push(entry);\n              cache[hash] = entry;\n\n              if (onProgressCallback) {\n                onProgressCallback(hash, entry, result.length);\n              }\n            }\n          }; // Load the entry\n\n\n          Entry.fromMultihash(ipfs, hash).then(addToResults).then(resolve).catch(function (err) {\n            resolve();\n          });\n        });\n      };\n\n      return pWhilst(shouldFetchMore, fetchEntry).then(function () {\n        return result;\n      });\n    }\n  }]);\n\n  return EntryIO;\n}();\n\nmodule.exports = EntryIO;","map":null,"metadata":{},"sourceType":"script"}