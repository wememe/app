{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar EventEmitter = require('events');\n\nvar LatencyMonitor = require('latency-monitor').default;\n\nvar debug = require('debug')('libp2p:connection-manager');\n\nvar defaultOptions = {\n  maxPeers: Infinity,\n  minPeers: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n};\n\nvar ConnectionManager =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(ConnectionManager, _EventEmitter);\n\n  function ConnectionManager(libp2p, options) {\n    var _this;\n\n    _classCallCheck(this, ConnectionManager);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ConnectionManager).call(this));\n    _this._libp2p = libp2p;\n    _this._options = Object.assign({}, defaultOptions, options);\n    _this._options.maxPeersPerProtocol = fixMaxPeersPerProtocol(_this._options.maxPeersPerProtocol);\n    debug('options: %j', _this._options);\n    _this._stats = libp2p.stats;\n\n    if (options && !_this._stats) {\n      throw new Error('No libp2p.stats');\n    }\n\n    _this._peerValues = new Map();\n    _this._peers = new Map();\n    _this._peerProtocols = new Map();\n    _this._peerCountPerProtocol = new Map();\n    _this._onStatsUpdate = _this._onStatsUpdate.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._onPeerConnect = _this._onPeerConnect.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._onPeerDisconnect = _this._onPeerDisconnect.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n\n    if (_this._libp2p.isStarted()) {\n      _this._onceStarted();\n    } else {\n      _this._libp2p.once('start', _this._onceStarted.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n    }\n\n    return _this;\n  }\n\n  _createClass(ConnectionManager, [{\n    key: \"start\",\n    value: function start() {\n      this._stats.on('update', this._onStatsUpdate);\n\n      this._libp2p.on('peer:connect', this._onPeerConnect);\n\n      this._libp2p.on('peer:disconnect', this._onPeerDisconnect); // latency monitor\n\n\n      this._latencyMonitor = new LatencyMonitor({\n        dataEmitIntervalMs: this._options.pollInterval\n      });\n      this._onLatencyMeasure = this._onLatencyMeasure.bind(this);\n\n      this._latencyMonitor.on('data', this._onLatencyMeasure);\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._stats.removeListener('update', this._onStatsUpdate);\n\n      this._libp2p.removeListener('peer:connect', this._onPeerConnect);\n\n      this._libp2p.removeListener('peer:disconnect', this._onPeerDisconnect);\n\n      this._latencyMonitor.removeListener('data', this._onLatencyMeasure);\n    }\n  }, {\n    key: \"setPeerValue\",\n    value: function setPeerValue(peerId, value) {\n      if (value < 0 || value > 1) {\n        throw new Error('value should be a number between 0 and 1');\n      }\n\n      if (peerId.toB58String) {\n        peerId = peerId.toB58String();\n      }\n\n      this._peerValues.set(peerId, value);\n    }\n  }, {\n    key: \"_onceStarted\",\n    value: function _onceStarted() {\n      this._peerId = this._libp2p.peerInfo.id.toB58String();\n    }\n  }, {\n    key: \"_onStatsUpdate\",\n    value: function _onStatsUpdate() {\n      var movingAvgs = this._stats.global.movingAverages;\n\n      var received = movingAvgs.dataReceived[this._options.movingAverageInterval].movingAverage();\n\n      this._checkLimit('maxReceivedData', received);\n\n      var sent = movingAvgs.dataSent[this._options.movingAverageInterval].movingAverage();\n\n      this._checkLimit('maxSentData', sent);\n\n      var total = received + sent;\n\n      this._checkLimit('maxData', total);\n\n      debug('stats update', total);\n    }\n  }, {\n    key: \"_onPeerConnect\",\n    value: function _onPeerConnect(peerInfo) {\n      var _this2 = this;\n\n      var peerId = peerInfo.id.toB58String();\n      debug('%s: connected to %s', this._peerId, peerId);\n\n      this._peerValues.set(peerId, this._options.defaultPeerValue);\n\n      this._peers.set(peerId, peerInfo);\n\n      this.emit('connected', peerId);\n\n      this._checkLimit('maxPeers', this._peers.size);\n\n      protocolsFromPeerInfo(peerInfo).forEach(function (protocolTag) {\n        var protocol = _this2._peerCountPerProtocol[protocolTag];\n\n        if (!protocol) {\n          _this2._peerCountPerProtocol[protocolTag] = 0;\n        }\n\n        _this2._peerCountPerProtocol[protocolTag]++;\n        var peerProtocols = _this2._peerProtocols[peerId];\n\n        if (!peerProtocols) {\n          peerProtocols = _this2._peerProtocols[peerId] = new Set();\n        }\n\n        peerProtocols.add(protocolTag);\n\n        _this2._checkProtocolMaxPeersLimit(protocolTag, _this2._peerCountPerProtocol[protocolTag]);\n      });\n    }\n  }, {\n    key: \"_onPeerDisconnect\",\n    value: function _onPeerDisconnect(peerInfo) {\n      var _this3 = this;\n\n      var peerId = peerInfo.id.toB58String();\n      debug('%s: disconnected from %s', this._peerId, peerId);\n\n      this._peerValues.delete(peerId);\n\n      this._peers.delete(peerId);\n\n      var peerProtocols = this._peerProtocols[peerId];\n\n      if (peerProtocols) {\n        Array.from(peerProtocols).forEach(function (protocolTag) {\n          var peerCountForProtocol = _this3._peerCountPerProtocol[protocolTag];\n\n          if (peerCountForProtocol) {\n            _this3._peerCountPerProtocol[protocolTag]--;\n          }\n        });\n      }\n\n      this.emit('disconnected', peerId);\n    }\n  }, {\n    key: \"_onLatencyMeasure\",\n    value: function _onLatencyMeasure(summary) {\n      this._checkLimit('maxEventLoopDelay', summary.avgMs);\n    }\n  }, {\n    key: \"_checkLimit\",\n    value: function _checkLimit(name, value) {\n      debug('checking limit. current value of %s is %d', name, value);\n      var limit = this._options[name];\n\n      if (value > limit) {\n        debug('%s: limit exceeded: %s, %d', this._peerId, name, value);\n        this.emit('limit:exceeded', name, value);\n\n        this._maybeDisconnectOne();\n      }\n    }\n  }, {\n    key: \"_checkProtocolMaxPeersLimit\",\n    value: function _checkProtocolMaxPeersLimit(protocolTag, value) {\n      debug('checking protocol limit. current value of %s is %d', protocolTag, value);\n      var limit = this._options.maxPeersPerProtocol[protocolTag];\n\n      if (value > limit) {\n        debug('%s: protocol max peers limit exceeded: %s, %d', this._peerId, protocolTag, value);\n        this.emit('limit:exceeded', protocolTag, value);\n\n        this._maybeDisconnectOne();\n      }\n    }\n  }, {\n    key: \"_maybeDisconnectOne\",\n    value: function _maybeDisconnectOne() {\n      if (this._options.minPeers < this._peerValues.size) {\n        var peerValues = Array.from(this._peerValues).sort(byPeerValue);\n        debug('%s: sorted peer values: %j', this._peerId, peerValues);\n        var disconnectPeer = peerValues[0];\n\n        if (disconnectPeer) {\n          var peerId = disconnectPeer[0];\n          debug('%s: lowest value peer is %s', this._peerId, peerId);\n          debug('%s: forcing disconnection from %j', this._peerId, peerId);\n\n          this._disconnectPeer(peerId);\n        }\n      }\n    }\n  }, {\n    key: \"_disconnectPeer\",\n    value: function _disconnectPeer(peerId) {\n      var _this4 = this;\n\n      debug('preemptively disconnecting peer', peerId);\n      this.emit('%s: disconnect:preemptive', this._peerId, peerId);\n\n      var peer = this._peers.get(peerId);\n\n      this._libp2p.hangUp(peer, function (err) {\n        if (err) {\n          _this4.emit('error', err);\n        }\n      });\n    }\n  }]);\n\n  return ConnectionManager;\n}(EventEmitter);\n\nmodule.exports = ConnectionManager;\n\nfunction byPeerValue(peerValueEntryA, peerValueEntryB) {\n  return peerValueEntryA[1] - peerValueEntryB[1];\n}\n\nfunction fixMaxPeersPerProtocol(maxPeersPerProtocol) {\n  if (!maxPeersPerProtocol) {\n    maxPeersPerProtocol = {};\n  }\n\n  Object.keys(maxPeersPerProtocol).forEach(function (transportTag) {\n    var max = maxPeersPerProtocol[transportTag];\n    delete maxPeersPerProtocol[transportTag];\n    maxPeersPerProtocol[transportTag.toLowerCase()] = max;\n  });\n  return maxPeersPerProtocol;\n}\n\nfunction protocolsFromPeerInfo(peerInfo) {\n  var protocolTags = new Set();\n  peerInfo.multiaddrs.forEach(function (multiaddr) {\n    multiaddr.protos().map(protocolToProtocolTag).forEach(function (protocolTag) {\n      protocolTags.add(protocolTag);\n    });\n  });\n  return Array.from(protocolTags);\n}\n\nfunction protocolToProtocolTag(protocol) {\n  return protocol.name.toLowerCase();\n}","map":null,"metadata":{},"sourceType":"script"}