{"ast":null,"code":"'use strict';\n\nvar pull = require('pull-stream');\n\nvar CID = require('cids');\n\nvar createResolver = require('./resolve').createResolver;\n\nfunction pathBaseAndRest(path) {\n  // Buffer -> raw multihash or CID in buffer\n  var pathBase = path;\n  var pathRest = '/';\n\n  if (Buffer.isBuffer(path)) {\n    pathBase = new CID(path).toBaseEncodedString();\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = pathBase = path.substring(6);\n    }\n\n    var subtreeStart = path.indexOf('/');\n\n    if (subtreeStart > 0) {\n      pathBase = path.substring(0, subtreeStart);\n      pathRest = path.substring(subtreeStart);\n    }\n  } else if (CID.isCID(pathBase)) {\n    pathBase = pathBase.toBaseEncodedString();\n  }\n\n  pathBase = new CID(pathBase).toBaseEncodedString();\n  return {\n    base: pathBase,\n    rest: pathRest.split('/').filter(Boolean)\n  };\n}\n\nvar defaultOptions = {\n  maxDepth: Infinity,\n  offset: undefined,\n  length: undefined\n};\n\nmodule.exports = function (path, dag, options) {\n  options = Object.assign({}, defaultOptions, options);\n  var dPath;\n\n  try {\n    dPath = pathBaseAndRest(path);\n  } catch (err) {\n    return pull.error(err);\n  }\n\n  var pathLengthToCut = join([dPath.base].concat(dPath.rest.slice(0, dPath.rest.length - 1))).length;\n  return pull(pull.values([{\n    multihash: new CID(dPath.base),\n    name: dPath.base,\n    path: dPath.base,\n    pathRest: dPath.rest,\n    depth: 0\n  }]), createResolver(dag, options), pull.filter(Boolean), pull.map(function (node) {\n    return {\n      depth: node.depth,\n      name: node.name,\n      path: finalPathFor(node),\n      size: node.size,\n      hash: node.hash || node.multihash,\n      content: node.content,\n      type: node.type\n    };\n  }));\n\n  function finalPathFor(node) {\n    if (!dPath.rest.length) {\n      return node.path;\n    }\n\n    var retPath = node.path.substring(pathLengthToCut);\n\n    if (retPath.charAt(0) === '/') {\n      retPath = retPath.substring(1);\n    }\n\n    if (!retPath) {\n      retPath = dPath.rest[dPath.rest.length - 1] || dPath.base;\n    }\n\n    return retPath;\n  }\n};\n\nfunction join(paths) {\n  return paths.reduce(function (acc, path) {\n    if (acc.length) {\n      acc += '/';\n    }\n\n    return acc + path;\n  }, '');\n}","map":null,"metadata":{},"sourceType":"script"}