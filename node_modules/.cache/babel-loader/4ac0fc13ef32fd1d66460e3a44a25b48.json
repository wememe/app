{"ast":null,"code":"'use strict';\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar EthAbi = require('web3-eth-abi');\n\nvar bs58 = require('bs58');\n\nvar ethers = require('ethers');\n\nvar EthrDIDRegistryArtifact = require('ethr-did-registry');\n\nvar EthrDIDRegistryAbi = EthrDIDRegistryArtifact.abi;\nvar EthrDIDRegistryAddress = EthrDIDRegistryArtifact.networks[1].address;\nvar PROVIDER_URL = 'https://mainnet.infura.io';\nvar claimKey = '0x' + Buffer.from('muPortDocument', 'utf8').toString('hex');\n\nvar EthereumUtils = function () {\n  function EthereumUtils(providerUrl) {\n    (0, _classCallCheck3.default)(this, EthereumUtils);\n    this.provider = new ethers.providers.JsonRpcProvider(providerUrl || PROVIDER_URL);\n  }\n\n  (0, _createClass3.default)(EthereumUtils, [{\n    key: 'createPublishTxParams',\n    value: function () {\n      var _ref = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee(ipfsHash, managementAddress) {\n        var encodedHash, data, nonce, gasPrice, txParams;\n        return _regenerator2.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                encodedHash = encodeIpfsHash(ipfsHash);\n                data = encodeMethodCall('setAttribute', [managementAddress, claimKey, encodedHash, 0]);\n                _context.next = 4;\n                return this.provider.getTransactionCount(managementAddress);\n\n              case 4:\n                nonce = _context.sent;\n                _context.next = 7;\n                return this.provider.getGasPrice();\n\n              case 7:\n                gasPrice = _context.sent.toNumber();\n                txParams = {\n                  nonce: nonce,\n                  gasPrice: gasPrice,\n                  to: EthrDIDRegistryAddress,\n                  data: data // we need to add 500 as a gas buffer\n\n                };\n                _context.next = 11;\n                return this.provider.estimateGas((0, _extends3.default)({}, txParams, {\n                  from: managementAddress\n                }));\n\n              case 11:\n                _context.t0 = _context.sent.toNumber();\n                txParams.gasLimit = _context.t0 + 500;\n                return _context.abrupt('return', txParams);\n\n              case 14:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function createPublishTxParams(_x, _x2) {\n        return _ref.apply(this, arguments);\n      }\n\n      return createPublishTxParams;\n    }()\n  }, {\n    key: 'calculateTxCost',\n    value: function calculateTxCost(txParams) {\n      return ethers.utils.formatUnits(txParams.gasPrice * txParams.gasLimit, 'ether');\n    }\n  }, {\n    key: 'sendRawTx',\n    value: function () {\n      var _ref2 = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee2(rawTx) {\n        return _regenerator2.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt('return', this.provider.sendTransaction(rawTx));\n\n              case 1:\n              case 'end':\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function sendRawTx(_x3) {\n        return _ref2.apply(this, arguments);\n      }\n\n      return sendRawTx;\n    }()\n  }, {\n    key: 'waitForTx',\n    value: function () {\n      var _ref3 = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee3(txHash) {\n        return _regenerator2.default.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt('return', this.provider.waitForTransaction(txHash, 60000));\n\n              case 1:\n              case 'end':\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function waitForTx(_x4) {\n        return _ref3.apply(this, arguments);\n      }\n\n      return waitForTx;\n    }()\n  }]);\n  return EthereumUtils;\n}();\n\nvar encodeIpfsHash = function encodeIpfsHash(hash) {\n  return '0x' + bs58.decode(hash).toString('hex');\n};\n\nvar encodeMethodCall = function encodeMethodCall(methodName, args) {\n  var methodAbi = EthrDIDRegistryAbi.filter(function (obj) {\n    return obj.name === methodName;\n  })[0];\n  return EthAbi.encodeFunctionCall(methodAbi, args);\n};\n\nmodule.exports = EthereumUtils;","map":null,"metadata":{},"sourceType":"script"}