{"ast":null,"code":"'use strict';\n/* @flow */\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar stream = require('readable-stream');\n\nvar varint = require('varint');\n\nvar duplexify = require('duplexify');\n\nvar debug = require('debug');\n\nvar Channel = require('./channel');\n/* :: import type {ChannelOpts} from './channel' */\n\n\nvar SIGNAL_FLUSH = Buffer.from([0]);\nvar empty = Buffer.alloc(0);\nvar pool = Buffer.alloc(10 * 1024);\nvar used = 0;\n/* ::\ntype MultiplexOpts = {\n  binaryName?: bool,\n  limit?: number,\n  initiator?: bool\n}\n\ntype ChannelCallback = (Channel) => void\n*/\n\nvar Multiplex =\n/*#__PURE__*/\nfunction (_stream$Duplex) {\n  _inherits(Multiplex, _stream$Duplex);\n\n  function Multiplex(opts\n  /* :: ?: MultiplexOpts | ChannelCallback */\n  , onchannel\n  /* :: ?: ChannelCallback */\n  ) {\n    var _this;\n\n    _classCallCheck(this, Multiplex);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Multiplex).call(this));\n\n    if (typeof opts === 'function') {\n      onchannel = opts;\n      opts = {};\n    }\n\n    if (!opts) {\n      opts = {};\n    }\n\n    if (onchannel) {\n      _this.on('stream', onchannel);\n    }\n\n    _this.destroyed = false;\n    _this.limit = opts.limit || 0;\n\n    if (opts.initiator == null) {\n      opts.initiator = true;\n    }\n\n    _this.initiator = opts.initiator;\n    _this._corked = 0;\n    _this._options = opts;\n    _this._binaryName = Boolean(opts.binaryName);\n    _this._local = [];\n    _this._remote = [];\n    _this._list = _this._local;\n    _this._receiving = null;\n    _this._chunked = false;\n    _this._state = 0;\n    _this._type = 0;\n    _this._channel = 0;\n    _this._missing = 0;\n    _this._message = null;\n    _this.log = debug('mplex:main:' + Math.floor(Math.random() * 100000));\n\n    _this.log('construction');\n\n    var bufSize = 100;\n\n    if (_this.limit) {\n      bufSize = varint.encodingLength(_this.limit);\n    }\n\n    _this._buf = Buffer.alloc(bufSize);\n    _this._ptr = 0;\n    _this._awaitChannelDrains = 0;\n    _this._onwritedrain = null;\n    _this._ondrain = [];\n    _this._finished = false;\n\n    _this.once('finish', _this._clear); // setup id handling\n\n\n    _this._nextId = _this.initiator ? 0 : 1;\n    return _this;\n  } // Generate the next stream id\n\n\n  _createClass(Multiplex, [{\n    key: \"_nextStreamId\",\n    value: function _nextStreamId()\n    /* : number */\n    {\n      var id = this._nextId;\n      this._nextId += 2;\n      return id;\n    }\n  }, {\n    key: \"createStream\",\n    value: function createStream(name\n    /* : Buffer | string */\n    , opts\n    /* : ChannelOpts */\n    )\n    /* : Channel */\n    {\n      if (this.destroyed) {\n        throw new Error('Multiplexer is destroyed');\n      }\n\n      var id = this._nextStreamId();\n\n      var channelName = this._name(name || id.toString());\n\n      var options = Object.assign(this._options, opts);\n      this.log('createStream: %s', id, channelName.toString(), options);\n      var channel = new Channel(channelName, this, options);\n      return this._addChannel(channel, id, this._local);\n    }\n  }, {\n    key: \"receiveStream\",\n    value: function receiveStream(name\n    /* : Buffer | string */\n    , opts\n    /* : ChannelOpts */\n    )\n    /* : Channel */\n    {\n      if (this.destroyed) {\n        throw new Error('Multiplexer is destroyed');\n      }\n\n      if (name === undefined || name === null) {\n        throw new Error('Name is needed when receiving a stream');\n      }\n\n      var channelName = this._name(name);\n\n      this.log('receiveStream: ' + channelName.toString());\n      var channel = new Channel(channelName, this, Object.assign(this._options, opts));\n\n      if (!this._receiving) {\n        this._receiving = {};\n      }\n\n      if (this._receiving[channel.name]) {\n        throw new Error('You are already receiving this stream');\n      }\n\n      this._receiving[channel.name] = channel;\n      return channel;\n    }\n  }, {\n    key: \"createSharedStream\",\n    value: function createSharedStream(name\n    /* : Buffer | string */\n    , opts\n    /* : ChannelOpts */\n    )\n    /* : stream.Duplex */\n    {\n      this.log('createSharedStream');\n      return duplexify(this.createStream(name, Object.assign(opts, {\n        lazy: true\n      })), this.receiveStream(name, opts));\n    }\n  }, {\n    key: \"_name\",\n    value: function _name(name\n    /* : Buffer | string */\n    )\n    /* : Buffer | string */\n    {\n      if (!this._binaryName) {\n        return name.toString();\n      }\n\n      return Buffer.isBuffer(name) ? name : Buffer.from(name);\n    }\n  }, {\n    key: \"_send\",\n    value: function _send(header\n    /* : number */\n    , data\n    /* :: ?: Buffer */\n    )\n    /* : bool */\n    {\n      var len = data ? data.length : 0;\n      var oldUsed = used;\n      this.log('_send', header, len);\n      varint.encode(header, pool, used);\n      used += varint.encode.bytes;\n      varint.encode(len, pool, used);\n      used += varint.encode.bytes;\n      var buf = pool.slice(oldUsed, used);\n\n      if (pool.length - used < 100) {\n        pool = Buffer.alloc(10 * 1024);\n        used = 0;\n      }\n\n      if (data) {\n        buf = Buffer.concat([buf, data]);\n      } // Push and return the results\n\n\n      return this.push(buf);\n    }\n  }, {\n    key: \"_addChannel\",\n    value: function _addChannel(channel\n    /* : Channel */\n    , id\n    /* : number */\n    , list\n    /* : Array<Channel|null> */\n    )\n    /* : Channel */\n    {\n      var _this2 = this;\n\n      this.log('_addChannel', id);\n      list[id] = channel;\n      channel.on('finalize', function () {\n        _this2.log('_remove channel', id);\n\n        list[id] = null;\n      });\n      channel.open(id, list === this._local);\n      return channel;\n    }\n  }, {\n    key: \"_writeVarint\",\n    value: function _writeVarint(data\n    /* : Buffer */\n    , offset\n    /* : number */\n    )\n    /* : number */\n    {\n      for (offset; offset < data.length; offset++) {\n        if (this._ptr === this._buf.length) {\n          return this._lengthError(data);\n        }\n\n        this._buf[this._ptr++] = data[offset];\n\n        if (!(data[offset] & 0x80)) {\n          if (this._state === 0) {\n            var header = varint.decode(this._buf);\n            this._type = header & 7;\n            this._channel = header >> 3;\n            this._list = this._type & 1 ? this._local : this._remote;\n            var chunked = this._list.length > this._channel && this._list[this._channel] && this._list[this._channel].chunked;\n            this._chunked = Boolean(this._type === 1 || this._type === 2) && chunked;\n          } else {\n            this._missing = varint.decode(this._buf);\n\n            if (this.limit && this._missing > this.limit) {\n              return this._lengthError(data);\n            }\n          }\n\n          this._state++;\n          this._ptr = 0;\n          return offset + 1;\n        }\n      }\n\n      return data.length;\n    }\n  }, {\n    key: \"_lengthError\",\n    value: function _lengthError(data\n    /* : Buffer */\n    )\n    /* : number */\n    {\n      this.destroy(new Error('Incoming message is too big'));\n      return data.length;\n    }\n  }, {\n    key: \"_writeMessage\",\n    value: function _writeMessage(data\n    /* : Buffer */\n    , offset\n    /* : number */\n    )\n    /* : number */\n    {\n      var free = data.length - offset;\n      var missing = this._missing;\n\n      if (!this._message) {\n        if (missing <= free) {\n          // fast track - no copy\n          this._missing = 0;\n\n          this._push(data.slice(offset, offset + missing));\n\n          return offset + missing;\n        }\n\n        if (this._chunked) {\n          this._missing -= free;\n\n          this._push(data.slice(offset, data.length));\n\n          return data.length;\n        }\n\n        this._message = Buffer.alloc(missing);\n      }\n\n      data.copy(this._message, this._ptr, offset, offset + missing);\n\n      if (missing <= free) {\n        this._missing = 0;\n\n        this._push(this._message);\n\n        return offset + missing;\n      }\n\n      this._missing -= free;\n      this._ptr += free;\n      return data.length;\n    }\n  }, {\n    key: \"_push\",\n    value: function _push(data\n    /* : Buffer */\n    ) {\n      this.log('_push', data.length);\n\n      if (!this._missing) {\n        this._ptr = 0;\n        this._state = 0;\n        this._message = null;\n      }\n\n      if (this._type === 0) {\n        // open\n        this.log('open', this._channel);\n\n        if (this.destroyed || this._finished) {\n          return;\n        }\n\n        var name;\n\n        if (this._binaryName) {\n          name = data;\n        } else {\n          name = data.toString() || this._channel.toString();\n        }\n\n        this.log('open name', name);\n        var channel;\n\n        if (this._receiving && this._receiving[name]) {\n          channel = this._receiving[name];\n          delete this._receiving[name];\n\n          this._addChannel(channel, this._channel, this._list);\n        } else {\n          channel = new Channel(name, this, this._options);\n          this.emit('stream', this._addChannel(channel, this._channel, this._list), channel.name);\n        }\n\n        return;\n      }\n\n      var stream = this._list[this._channel];\n\n      if (!stream) {\n        return;\n      }\n\n      switch (this._type) {\n        case 5: // local error\n\n        case 6:\n          {\n            // remote error\n            var error = new Error(data.toString() || 'Channel destroyed');\n            stream.local = false;\n            stream.destroy(error);\n            return;\n          }\n\n        case 3: // local end\n\n        case 4:\n          {\n            // remote end\n            stream.push(null);\n            return;\n          }\n\n        case 1: // local packet\n\n        case 2:\n          // remote packet\n          if (!stream.push(data)) {\n            this._awaitChannelDrains++;\n            stream._awaitDrain++;\n          }\n\n          break;\n\n        default: // no action\n\n      }\n    }\n  }, {\n    key: \"_onchanneldrain\",\n    value: function _onchanneldrain(drained\n    /* : number */\n    ) {\n      this._awaitChannelDrains -= drained;\n\n      if (this._awaitChannelDrains) {\n        return;\n      }\n\n      var ondrain = this._onwritedrain;\n      this._onwritedrain = null;\n\n      if (ondrain) {\n        ondrain();\n      }\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(data\n    /* : Buffer */\n    , enc\n    /* : string */\n    , cb\n    /* : () => void */\n    ) {\n      this.log('_write', data.length);\n\n      if (this._finished) {\n        cb();\n        return;\n      }\n\n      if (this._corked) {\n        this._onuncork(this._write.bind(this, data, enc, cb));\n\n        return;\n      }\n\n      if (data === SIGNAL_FLUSH) {\n        this._finish(cb);\n\n        return;\n      }\n\n      var offset = 0;\n\n      while (offset < data.length) {\n        if (this._state === 2) {\n          offset = this._writeMessage(data, offset);\n        } else {\n          offset = this._writeVarint(data, offset);\n        }\n      }\n\n      if (this._state === 2 && !this._missing) {\n        this._push(empty);\n      }\n\n      if (this._awaitChannelDrains) {\n        this._onwritedrain = cb;\n      } else {\n        cb();\n      }\n    }\n  }, {\n    key: \"_finish\",\n    value: function _finish(cb\n    /* : () => void */\n    ) {\n      var _this3 = this;\n\n      this._onuncork(function () {\n        if (_this3._writableState.prefinished === false) {\n          _this3._writableState.prefinished = true;\n        }\n\n        _this3.emit('prefinish');\n\n        _this3._onuncork(cb);\n      });\n    }\n  }, {\n    key: \"cork\",\n    value: function cork() {\n      if (++this._corked === 1) {\n        this.emit('cork');\n      }\n    }\n  }, {\n    key: \"uncork\",\n    value: function uncork() {\n      if (this._corked && --this._corked === 0) {\n        this.emit('uncork');\n      }\n    }\n  }, {\n    key: \"end\",\n    value: function end(data\n    /* :: ?: Buffer | () => void */\n    , enc\n    /* :: ?: string | () => void */\n    , cb\n    /* :: ?: () => void */\n    ) {\n      this.log('end');\n\n      if (typeof data === 'function') {\n        cb = data;\n        data = undefined;\n      }\n\n      if (typeof enc === 'function') {\n        cb = enc;\n        enc = undefined;\n      }\n\n      if (data) {\n        this.write(data);\n      }\n\n      if (!this._writableState.ending) {\n        this.write(SIGNAL_FLUSH);\n      }\n\n      return stream.Writable.prototype.end.call(this, cb);\n    }\n  }, {\n    key: \"_onuncork\",\n    value: function _onuncork(fn\n    /* : () => void */\n    ) {\n      if (this._corked) {\n        this.once('uncork', fn);\n        return;\n      }\n\n      fn();\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      while (this._ondrain.length) {\n        this._ondrain.shift()();\n      }\n    }\n  }, {\n    key: \"_clear\",\n    value: function _clear() {\n      this.log('_clear');\n\n      if (this._finished) {\n        return;\n      }\n\n      this._finished = true;\n\n      var list = this._local.concat(this._remote);\n\n      this._local = [];\n      this._remote = [];\n      list.forEach(function (stream) {\n        if (stream) {\n          stream.local = false;\n          stream.destroy(null);\n        }\n      });\n      this.push(null);\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      this._clear();\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy(err\n    /* :: ?: Error */\n    , callback) {\n      this.log('destroy');\n\n      var list = this._local.concat(this._remote);\n\n      list.forEach(function (stream) {\n        if (stream) {\n          stream.destroy(err || new Error('Channel destroyed'));\n        }\n      });\n\n      this._clear();\n\n      callback(err);\n    }\n  }]);\n\n  return Multiplex;\n}(stream.Duplex);\n\nmodule.exports = Multiplex;","map":null,"metadata":{},"sourceType":"script"}