{"ast":null,"code":"'use strict';\n\nvar waterfall = require('async/waterfall');\n\nvar setImmediate = require('async/setImmediate');\n\nvar promisify = require('promisify-es6');\n\nvar dagPB = require('ipld-dag-pb');\n\nvar DAGNode = dagPB.DAGNode;\nvar DAGLink = dagPB.DAGLink;\n\nvar CID = require('cids');\n\nvar mh = require('multihashes');\n\nvar Unixfs = require('ipfs-unixfs');\n\nvar errCode = require('err-code');\n\nfunction normalizeMultihash(multihash, enc) {\n  if (typeof multihash === 'string') {\n    if (enc === 'base58' || !enc) {\n      return multihash;\n    }\n\n    return Buffer.from(multihash, enc);\n  } else if (Buffer.isBuffer(multihash)) {\n    return multihash;\n  } else {\n    throw new Error('unsupported multihash');\n  }\n}\n\nfunction parseBuffer(buf, encoding, callback) {\n  switch (encoding) {\n    case 'json':\n      return parseJSONBuffer(buf, callback);\n\n    case 'protobuf':\n      return parseProtoBuffer(buf, callback);\n\n    default:\n      callback(new Error(\"unkown encoding: \".concat(encoding)));\n  }\n}\n\nfunction parseJSONBuffer(buf, callback) {\n  var data;\n  var links;\n\n  try {\n    var parsed = JSON.parse(buf.toString());\n    links = (parsed.Links || []).map(function (link) {\n      return new DAGLink(link.Name || link.name, link.Size || link.size, mh.fromB58String(link.Hash || link.hash || link.multihash));\n    });\n    data = Buffer.from(parsed.Data);\n  } catch (err) {\n    return callback(new Error('failed to parse JSON: ' + err));\n  }\n\n  DAGNode.create(data, links, callback);\n}\n\nfunction parseProtoBuffer(buf, callback) {\n  dagPB.util.deserialize(buf, callback);\n}\n\nmodule.exports = function object(self) {\n  function editAndSave(edit) {\n    return function (multihash, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      waterfall([function (cb) {\n        self.object.get(multihash, options, cb);\n      }, function (node, cb) {\n        // edit applies the edit func passed to\n        // editAndSave\n        edit(node, function (err, node) {\n          if (err) {\n            return cb(err);\n          }\n\n          var cid = new CID(node.multihash);\n\n          self._ipld.put(node, {\n            cid: cid\n          }, function (err) {\n            if (err) return cb(err);\n\n            if (options.preload !== false) {\n              self._preload(cid);\n            }\n\n            cb(null, node);\n          });\n        });\n      }], callback);\n    };\n  }\n\n  return {\n    new: promisify(function (template, options, callback) {\n      if (typeof template === 'function') {\n        callback = template;\n        template = undefined;\n        options = {};\n      }\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      var data;\n\n      if (template) {\n        if (template !== 'unixfs-dir') {\n          return setImmediate(function () {\n            return callback(new Error('unknown template'));\n          });\n        }\n\n        data = new Unixfs('directory').marshal();\n      } else {\n        data = Buffer.alloc(0);\n      }\n\n      DAGNode.create(data, function (err, node) {\n        if (err) {\n          return callback(err);\n        }\n\n        var cid = new CID(node.multihash);\n\n        self._ipld.put(node, {\n          cid: cid\n        }, function (err) {\n          if (err) {\n            return callback(err);\n          }\n\n          if (options.preload !== false) {\n            self._preload(cid);\n          }\n\n          callback(null, node);\n        });\n      });\n    }),\n    put: promisify(function (obj, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      var encoding = options.enc;\n      var node;\n\n      if (Buffer.isBuffer(obj)) {\n        if (encoding) {\n          parseBuffer(obj, encoding, function (err, _node) {\n            if (err) {\n              return callback(err);\n            }\n\n            node = _node;\n            next();\n          });\n        } else {\n          DAGNode.create(obj, function (err, _node) {\n            if (err) {\n              return callback(err);\n            }\n\n            node = _node;\n            next();\n          });\n        }\n      } else if (obj.multihash) {\n        // already a dag node\n        node = obj;\n        next();\n      } else if (typeof obj === 'object') {\n        DAGNode.create(obj.Data, obj.Links, function (err, _node) {\n          if (err) {\n            return callback(err);\n          }\n\n          node = _node;\n          next();\n        });\n      } else {\n        return callback(new Error('obj not recognized'));\n      }\n\n      function next() {\n        var cid;\n\n        try {\n          cid = new CID(node.multihash);\n        } catch (err) {\n          return setImmediate(function () {\n            return callback(errCode(err, 'ERR_INVALID_CID'));\n          });\n        }\n\n        self._ipld.put(node, {\n          cid: cid\n        }, function (err) {\n          if (err) {\n            return callback(err);\n          }\n\n          self.object.get(node.multihash, {\n            preload: options.preload\n          }, callback);\n        });\n      }\n    }),\n    get: promisify(function (multihash, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      var mh, cid;\n\n      try {\n        mh = normalizeMultihash(multihash, options.enc);\n      } catch (err) {\n        return setImmediate(function () {\n          return callback(errCode(err, 'ERR_INVALID_MULTIHASH'));\n        });\n      }\n\n      try {\n        cid = new CID(mh);\n      } catch (err) {\n        return setImmediate(function () {\n          return callback(errCode(err, 'ERR_INVALID_CID'));\n        });\n      }\n\n      if (options.cidVersion === 1) {\n        cid = cid.toV1();\n      }\n\n      if (options.preload !== false) {\n        self._preload(cid);\n      }\n\n      self._ipld.get(cid, function (err, result) {\n        if (err) {\n          return callback(err);\n        }\n\n        var node = result.value;\n        callback(null, node);\n      });\n    }),\n    data: promisify(function (multihash, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      self.object.get(multihash, options, function (err, node) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, node.data);\n      });\n    }),\n    links: promisify(function (multihash, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      self.object.get(multihash, options, function (err, node) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, node.links);\n      });\n    }),\n    stat: promisify(function (multihash, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      self.object.get(multihash, options, function (err, node) {\n        if (err) {\n          return callback(err);\n        }\n\n        dagPB.util.serialize(node, function (err, serialized) {\n          if (err) {\n            return callback(err);\n          }\n\n          var blockSize = serialized.length;\n          var linkLength = node.links.reduce(function (a, l) {\n            return a + l.size;\n          }, 0);\n          var nodeJSON = node.toJSON();\n          callback(null, {\n            Hash: nodeJSON.multihash,\n            NumLinks: node.links.length,\n            BlockSize: blockSize,\n            LinksSize: blockSize - node.data.length,\n            DataSize: node.data.length,\n            CumulativeSize: blockSize + linkLength\n          });\n        });\n      });\n    }),\n    patch: promisify({\n      addLink: function addLink(multihash, link, options, callback) {\n        editAndSave(function (node, cb) {\n          DAGNode.addLink(node, link, cb);\n        })(multihash, options, callback);\n      },\n      rmLink: function rmLink(multihash, linkRef, options, callback) {\n        editAndSave(function (node, cb) {\n          if (DAGLink.isDAGLink(linkRef)) {\n            linkRef = linkRef._name;\n          } else if (linkRef && linkRef.name) {\n            linkRef = linkRef.name;\n          }\n\n          DAGNode.rmLink(node, linkRef, cb);\n        })(multihash, options, callback);\n      },\n      appendData: function appendData(multihash, data, options, callback) {\n        editAndSave(function (node, cb) {\n          var newData = Buffer.concat([node.data, data]);\n          DAGNode.create(newData, node.links, cb);\n        })(multihash, options, callback);\n      },\n      setData: function setData(multihash, data, options, callback) {\n        editAndSave(function (node, cb) {\n          DAGNode.create(data, node.links, cb);\n        })(multihash, options, callback);\n      }\n    })\n  };\n};","map":null,"metadata":{},"sourceType":"script"}