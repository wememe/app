{"ast":null,"code":"/* @flow */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar each = require('async/each');\n\nvar whilst = require('async/whilst');\n\nvar Errors = require('interface-datastore').Errors;\n/* ::\nimport type {Key, Datastore, Callback, Batch, Query, QueryResult} from 'interface-datastore'\n*/\n\n/**\n * A datastore that can combine multiple stores. Puts and deletes\n * will write through to all datastores. Has and get will\n * try each store sequentially. Query will always try the\n * last one first.\n *\n */\n\n\nvar TieredDatastore\n/* :: <Value> */\n=\n/*#__PURE__*/\nfunction () {\n  /* :: stores: Array<Datastore<Value>> */\n  function TieredDatastore(stores\n  /* : Array<Datastore<Value>> */\n  ) {\n    _classCallCheck(this, TieredDatastore);\n\n    this.stores = stores.slice();\n  }\n\n  _createClass(TieredDatastore, [{\n    key: \"open\",\n    value: function open(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      each(this.stores, function (store, cb) {\n        store.open(cb);\n      }, function (err) {\n        if (err) {\n          return callback(Errors.dbOpenFailedError());\n        }\n\n        callback();\n      });\n    }\n  }, {\n    key: \"put\",\n    value: function put(key\n    /* : Key */\n    , value\n    /* : Value */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      each(this.stores, function (store, cb) {\n        store.put(key, value, cb);\n      }, function (err) {\n        if (err) {\n          return callback(Errors.dbWriteFailedError());\n        }\n\n        callback();\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function get(key\n    /* : Key */\n    , callback\n    /* : Callback<Value> */\n    )\n    /* : void */\n    {\n      var _this = this;\n\n      var storeLength = this.stores.length;\n      var done = false;\n      var i = 0;\n      whilst(function () {\n        return !done && i < storeLength;\n      }, function (cb) {\n        var store = _this.stores[i++];\n        store.get(key, function (err, res) {\n          if (err == null) {\n            done = true;\n            return cb(null, res);\n          }\n\n          cb();\n        });\n      }, function (err, res) {\n        if (err || !res) {\n          return callback(Errors.notFoundError());\n        }\n\n        callback(null, res);\n      });\n    }\n  }, {\n    key: \"has\",\n    value: function has(key\n    /* : Key */\n    , callback\n    /* : Callback<bool> */\n    )\n    /* : void */\n    {\n      var _this2 = this;\n\n      var storeLength = this.stores.length;\n      var done = false;\n      var i = 0;\n      whilst(function () {\n        return !done && i < storeLength;\n      }, function (cb) {\n        var store = _this2.stores[i++];\n        store.has(key, function (err, exists) {\n          if (err == null) {\n            done = true;\n            return cb(null, exists);\n          }\n\n          cb();\n        });\n      }, callback);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key\n    /* : Key */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      each(this.stores, function (store, cb) {\n        store.delete(key, cb);\n      }, function (err) {\n        if (err) {\n          return callback(Errors.dbDeleteFailedError());\n        }\n\n        callback();\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      each(this.stores, function (store, cb) {\n        store.close(cb);\n      }, callback);\n    }\n  }, {\n    key: \"batch\",\n    value: function batch()\n    /* : Batch<Value> */\n    {\n      var batches = this.stores.map(function (store) {\n        return store.batch();\n      });\n      return {\n        put: function put(key\n        /* : Key */\n        , value\n        /* : Value */\n        )\n        /* : void */\n        {\n          batches.forEach(function (b) {\n            return b.put(key, value);\n          });\n        },\n        delete: function _delete(key\n        /* : Key */\n        )\n        /* : void */\n        {\n          batches.forEach(function (b) {\n            return b.delete(key);\n          });\n        },\n        commit: function commit(callback\n        /* : Callback<void> */\n        )\n        /* : void */\n        {\n          each(batches, function (b, cb) {\n            b.commit(cb);\n          }, callback);\n        }\n      };\n    }\n  }, {\n    key: \"query\",\n    value: function query(q\n    /* : Query<Value> */\n    )\n    /* : QueryResult<Value> */\n    {\n      return this.stores[this.stores.length - 1].query(q);\n    }\n  }]);\n\n  return TieredDatastore;\n}();\n\nmodule.exports = TieredDatastore;","map":null,"metadata":{},"sourceType":"script"}