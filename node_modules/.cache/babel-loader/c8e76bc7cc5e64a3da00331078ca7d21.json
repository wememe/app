{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ipns = require('ipns');\n\nvar _require = require('multihashes'),\n    fromB58String = _require.fromB58String;\n\nvar Record = require('libp2p-record').Record;\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('jsipfs:ipns:resolver');\nlog.error = debug('jsipfs:ipns:resolver:error');\nvar defaultMaximumRecursiveDepth = 32;\n\nvar IpnsResolver =\n/*#__PURE__*/\nfunction () {\n  function IpnsResolver(routing, repo) {\n    _classCallCheck(this, IpnsResolver);\n\n    this._routing = routing;\n    this._repo = repo;\n    this._resolver = undefined; // TODO Routing - add Router resolver\n  }\n\n  _createClass(IpnsResolver, [{\n    key: \"resolve\",\n    value: function resolve(name, peerId, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      if (typeof name !== 'string') {\n        var errMsg = \"one or more of the provided parameters are not valid\";\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_INVALID_PARAMETER'));\n      }\n\n      options = options || {};\n      var recursive = options.recursive && options.recursive.toString() === 'true';\n      var local = !(options.local === false);\n      var nameSegments = name.split('/');\n\n      if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n        var _errMsg = \"invalid name syntax for \".concat(name);\n\n        log.error(_errMsg);\n        return callback(errcode(new Error(_errMsg), 'ERR_INVALID_NAME_SYNTAX'));\n      }\n\n      var key = nameSegments[2]; // Define a maximum depth if recursive option enabled\n\n      var depth;\n\n      if (recursive) {\n        depth = defaultMaximumRecursiveDepth;\n      } // Get the intended resoulver function\n      // TODO Routing - set default resolverFn\n\n\n      var resolverFn;\n\n      if (local) {\n        resolverFn = this._resolveLocal;\n      }\n\n      if (!resolverFn) {\n        return callback(new Error('not implemented yet'));\n      }\n\n      this.resolver(key, depth, peerId, resolverFn, function (err, res) {\n        if (err) {\n          return callback(err);\n        }\n\n        log(\"\".concat(name, \" was locally resolved correctly\"));\n        callback(null, res);\n      });\n    } // Recursive resolver according to the specified depth\n\n  }, {\n    key: \"resolver\",\n    value: function resolver(name, depth, peerId, resolverFn, callback) {\n      var _this = this;\n\n      // bind resolver function\n      this._resolver = resolverFn; // Exceeded recursive maximum depth\n\n      if (depth === 0) {\n        var errMsg = \"could not resolve name (recursion limit of \".concat(defaultMaximumRecursiveDepth, \" exceeded)\");\n        log.error(errMsg);\n        return callback(errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT'));\n      }\n\n      this._resolver(name, peerId, function (err, res) {\n        if (err) {\n          return callback(err);\n        }\n\n        var nameSegments = res.split('/'); // If obtained a ipfs cid or recursive option is disabled\n\n        if (nameSegments[1] === 'ipfs' || !depth) {\n          return callback(null, res);\n        } // continue recursively until depth equals 0\n\n\n        _this.resolver(nameSegments[2], depth - 1, peerId, resolverFn, callback);\n      });\n    } // resolve ipns entries locally using the datastore\n\n  }, {\n    key: \"_resolveLocal\",\n    value: function _resolveLocal(name, peerId, callback) {\n      var _ipns$getIdKeys = ipns.getIdKeys(fromB58String(name)),\n          ipnsKey = _ipns$getIdKeys.ipnsKey;\n\n      this._repo.datastore.get(ipnsKey, function (err, dsVal) {\n        if (err) {\n          var errMsg = \"local record requested was not found for \".concat(name, \" (\").concat(ipnsKey, \")\");\n          log.error(errMsg);\n          return callback(errcode(new Error(errMsg), 'ERR_NO_LOCAL_RECORD_FOUND'));\n        }\n\n        if (!Buffer.isBuffer(dsVal)) {\n          var _errMsg2 = \"found ipns record that we couldn't convert to a value\";\n          log.error(_errMsg2);\n          return callback(errcode(new Error(_errMsg2), 'ERR_INVALID_RECORD_RECEIVED'));\n        }\n\n        var record = Record.deserialize(dsVal);\n        var ipnsEntry = ipns.unmarshal(record.value);\n        ipns.extractPublicKey(peerId, ipnsEntry, function (err, pubKey) {\n          if (err) {\n            return callback(err);\n          } // IPNS entry validation\n\n\n          ipns.validate(pubKey, ipnsEntry, function (err) {\n            if (err) {\n              return callback(err);\n            }\n\n            callback(null, ipnsEntry.value.toString());\n          });\n        });\n      });\n    }\n  }]);\n\n  return IpnsResolver;\n}();\n\nexports = module.exports = IpnsResolver;","map":null,"metadata":{},"sourceType":"script"}