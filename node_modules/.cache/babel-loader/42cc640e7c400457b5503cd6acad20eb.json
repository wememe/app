{"ast":null,"code":"'use strict';\n\nvar UnixFs = require('ipfs-unixfs');\n\nvar waterfall = require('async/waterfall');\n\nvar series = require('async/series');\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode;\n\nvar CID = require('cids');\n\nvar _require2 = require('./utils'),\n    traverseTo = _require2.traverseTo,\n    updateTree = _require2.updateTree,\n    updateMfsRoot = _require2.updateMfsRoot,\n    toSources = _require2.toSources,\n    FILE_SEPARATOR = _require2.FILE_SEPARATOR;\n\nvar defaultOptions = {\n  recursive: false\n};\n\nmodule.exports = function (ipfs) {\n  return function mfsRm() {\n    var args = Array.from(arguments);\n\n    var _toSources = toSources(args, defaultOptions),\n        sources = _toSources.sources,\n        options = _toSources.options,\n        callback = _toSources.callback;\n\n    if (!sources.length) {\n      return callback(new Error('Please supply at least one path to remove'));\n    }\n\n    series(sources.map(function (source) {\n      return function (done) {\n        return removePath(ipfs, source.path, options, done);\n      };\n    }), function (error) {\n      return callback(error);\n    });\n  };\n};\n\nvar removePath = function removePath(ipfs, path, options, callback) {\n  if (path === FILE_SEPARATOR) {\n    return callback(new Error('Cannot delete root'));\n  }\n\n  waterfall([function (cb) {\n    return traverseTo(ipfs, path, {\n      withCreateHint: false\n    }, cb);\n  }, function (result, cb) {\n    var meta = UnixFs.unmarshal(result.node.data);\n\n    if (meta.type === 'directory' && !options.recursive) {\n      return cb(new Error(\"\".concat(path, \" is a directory, use -r to remove directories\")));\n    }\n\n    waterfall([function (next) {\n      return DAGNode.rmLink(result.parent.node, result.name, next);\n    }, function (newParentNode, next) {\n      ipfs.dag.put(newParentNode, {\n        cid: new CID(newParentNode.hash || newParentNode.multihash)\n      }, function (error) {\n        return next(error, newParentNode);\n      });\n    }, function (newParentNode, next) {\n      result.parent.node = newParentNode;\n      updateTree(ipfs, result.parent, next);\n    }, function (newRoot, next) {\n      return updateMfsRoot(ipfs, newRoot.node.multihash, next);\n    }], cb);\n  }], callback);\n};","map":null,"metadata":{},"sourceType":"script"}