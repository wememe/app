{"ast":null,"code":"'use strict';\n\nvar Interface = require('./interface.js');\n\nvar utils = function () {\n  var convert = require('../utils/convert.js');\n\n  return {\n    defineProperty: require('../utils/properties.js').defineProperty,\n    getAddress: require('../utils/address.js').getAddress,\n    bigNumberify: require('../utils/bignumber.js').bigNumberify,\n    arrayify: convert.arrayify,\n    hexlify: convert.hexlify\n  };\n}();\n\nvar errors = require('../utils/errors');\n\nvar allowedTransactionKeys = {\n  data: true,\n  from: true,\n  gasLimit: true,\n  gasPrice: true,\n  nonce: true,\n  to: true,\n  value: true\n};\n\nfunction copyObject(object) {\n  var result = {};\n\n  for (var key in object) {\n    result[key] = object[key];\n  }\n\n  return result;\n}\n\nfunction Contract(addressOrName, contractInterface, signerOrProvider) {\n  if (!(this instanceof Contract)) {\n    throw new Error('missing new');\n  } // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n  //address = utils.getAddress(address);\n\n\n  if (!(contractInterface instanceof Interface)) {\n    contractInterface = new Interface(contractInterface);\n  }\n\n  if (!signerOrProvider) {\n    throw new Error('missing signer or provider');\n  }\n\n  var signer = signerOrProvider;\n  var provider = null;\n\n  if (signerOrProvider.provider) {\n    provider = signerOrProvider.provider;\n  } else {\n    provider = signerOrProvider;\n    signer = null;\n  }\n\n  utils.defineProperty(this, 'address', addressOrName);\n  utils.defineProperty(this, 'interface', contractInterface);\n  utils.defineProperty(this, 'signer', signer);\n  utils.defineProperty(this, 'provider', provider);\n  var addressPromise = provider.resolveName(addressOrName);\n\n  function runMethod(method, estimateOnly) {\n    return function () {\n      var transaction = {};\n      var params = Array.prototype.slice.call(arguments); // If 1 extra parameter was passed in, it contains overrides\n\n      if (params.length === method.inputs.types.length + 1 && typeof params[params.length - 1] === 'object') {\n        transaction = copyObject(params.pop()); // Check for unexpected keys (e.g. using \"gas\" instead of \"gasLimit\")\n\n        for (var key in transaction) {\n          if (!allowedTransactionKeys[key]) {\n            throw new Error('unknown transaction override ' + key);\n          }\n        }\n      } // Check overrides make sense\n\n\n      ['data', 'to'].forEach(function (key) {\n        if (transaction[key] != null) {\n          throw new Error('cannot override ' + key);\n        }\n      });\n      var call = method.apply(contractInterface, params); // Send to the contract address\n\n      transaction.to = addressOrName; // Set the transaction data\n\n      transaction.data = call.data;\n\n      switch (call.type) {\n        case 'call':\n          // Call (constant functions) always cost 0 ether\n          if (estimateOnly) {\n            return Promise.resolve(new utils.bigNumberify(0));\n          } // Check overrides make sense\n\n\n          ['gasLimit', 'gasPrice', 'value'].forEach(function (key) {\n            if (transaction[key] != null) {\n              throw new Error('call cannot override ' + key);\n            }\n          });\n          var fromPromise = null;\n\n          if (transaction.from == null && signer && signer.getAddress) {\n            fromPromise = signer.getAddress();\n\n            if (!(fromPromise instanceof Promise)) {\n              fromPromise = Promise.resolve(fromPromise);\n            }\n          } else {\n            fromPromise = Promise.resolve(null);\n          }\n\n          return fromPromise.then(function (address) {\n            if (address) {\n              transaction.from = utils.getAddress(address);\n            }\n\n            return provider.call(transaction);\n          }).then(function (value) {\n            try {\n              if (utils.arrayify(value).length % 32 !== 0) {\n                throw new Error('call exception');\n              }\n\n              var result = call.parse(value);\n            } catch (error) {\n              if (value === '0x' && method.outputs.types.length > 0 || error.message === 'call exception') {\n                errors.throwError('call exception', errors.CALL_EXCEPTION, {\n                  address: addressOrName,\n                  method: call.signature,\n                  value: params\n                });\n              }\n\n              throw error;\n            }\n\n            if (method.outputs.types.length === 1) {\n              result = result[0];\n            }\n\n            return result;\n          });\n\n        case 'transaction':\n          if (!signer) {\n            return Promise.reject(new Error('missing signer'));\n          } // Make sure they aren't overriding something they shouldn't\n\n\n          if (transaction.from != null) {\n            throw new Error('transaction cannot override from');\n          } // Only computing the transaction estimate\n\n\n          if (estimateOnly) {\n            if (signer && signer.estimateGas) {\n              return signer.estimateGas(transaction);\n            }\n\n            return provider.estimateGas(transaction);\n          } // If the signer supports sendTrasaction, use it\n\n\n          if (signer.sendTransaction) {\n            return signer.sendTransaction(transaction);\n          }\n\n          if (!signer.sign) {\n            return Promise.reject(new Error('custom signer does not support signing'));\n          }\n\n          if (transaction.gasLimit == null) {\n            transaction.gasLimit = signer.defaultGasLimit || 2000000;\n          }\n\n          var noncePromise = null;\n\n          if (transaction.nonce != null) {\n            noncePromise = Promise.resolve(transaction.nonce);\n          } else if (signer.getTransactionCount) {\n            noncePromise = signer.getTransactionCount();\n\n            if (!(noncePromise instanceof Promise)) {\n              noncePromise = Promise.resolve(noncePromise);\n            }\n          } else {\n            var addressPromise = signer.getAddress();\n\n            if (!(addressPromise instanceof Promise)) {\n              addressPromise = Promise.resolve(addressPromise);\n            }\n\n            noncePromise = addressPromise.then(function (address) {\n              return provider.getTransactionCount(address, 'pending');\n            });\n          }\n\n          var gasPricePromise = null;\n\n          if (transaction.gasPrice) {\n            gasPricePromise = Promise.resolve(transaction.gasPrice);\n          } else {\n            gasPricePromise = provider.getGasPrice();\n          }\n\n          return Promise.all([noncePromise, gasPricePromise]).then(function (results) {\n            transaction.nonce = results[0];\n            transaction.gasPrice = results[1];\n            return signer.sign(transaction);\n          }).then(function (signedTransaction) {\n            return provider.sendTransaction(signedTransaction);\n          });\n      }\n    };\n  }\n\n  var estimate = {};\n  utils.defineProperty(this, 'estimate', estimate);\n  var functions = {};\n  utils.defineProperty(this, 'functions', functions);\n  var events = {};\n  utils.defineProperty(this, 'events', events);\n  Object.keys(contractInterface.functions).forEach(function (methodName) {\n    var method = contractInterface.functions[methodName];\n    var run = runMethod(method, false);\n\n    if (this[methodName] == null) {\n      utils.defineProperty(this, methodName, run);\n    } else {\n      console.log('WARNING: Multiple definitions for ' + method);\n    }\n\n    if (functions[method] == null) {\n      utils.defineProperty(functions, methodName, run);\n      utils.defineProperty(estimate, methodName, runMethod(method, true));\n    }\n  }, this);\n  Object.keys(contractInterface.events).forEach(function (eventName) {\n    var eventInfo = contractInterface.events[eventName];\n    var eventCallback = null;\n\n    function handleEvent(log) {\n      addressPromise.then(function (address) {\n        // Not meant for us (the topics just has the same name)\n        if (address != log.address) {\n          return;\n        }\n\n        try {\n          var result = eventInfo.parse(log.topics, log.data); // Some useful things to have with the log\n\n          log.args = result;\n          log.event = eventName;\n          log.parse = eventInfo.parse;\n\n          log.removeListener = function () {\n            provider.removeListener(eventInfo.topics, handleEvent);\n          };\n\n          log.getBlock = function () {\n            return provider.getBlock(log.blockHash);\n            ;\n          };\n\n          log.getTransaction = function () {\n            return provider.getTransaction(log.transactionHash);\n          };\n\n          log.getTransactionReceipt = function () {\n            return provider.getTransactionReceipt(log.transactionHash);\n          };\n\n          log.eventSignature = eventInfo.signature;\n          eventCallback.apply(log, Array.prototype.slice.call(result));\n        } catch (error) {\n          console.log(error);\n        }\n\n        return null;\n      }).catch(function (error) {//console.log(error);\n      });\n    }\n\n    var property = {\n      enumerable: true,\n      get: function get() {\n        return eventCallback;\n      },\n      set: function set(value) {\n        if (!value) {\n          value = null;\n        }\n\n        if (!value && eventCallback) {\n          provider.removeListener(eventInfo.topics, handleEvent);\n        } else if (value && !eventCallback) {\n          provider.on(eventInfo.topics, handleEvent);\n        }\n\n        eventCallback = value;\n      }\n    };\n    var propertyName = 'on' + eventName.toLowerCase();\n\n    if (this[propertyName] == null) {\n      Object.defineProperty(this, propertyName, property);\n    }\n\n    Object.defineProperty(events, eventName, property);\n  }, this);\n}\n\nutils.defineProperty(Contract.prototype, 'connect', function (signerOrProvider) {\n  return new Contract(this.address, this.interface, signerOrProvider);\n});\nutils.defineProperty(Contract, 'getDeployTransaction', function (bytecode, contractInterface) {\n  if (!(contractInterface instanceof Interface)) {\n    contractInterface = new Interface(contractInterface);\n  }\n\n  var args = Array.prototype.slice.call(arguments);\n  args.splice(1, 1);\n  return {\n    data: contractInterface.deployFunction.apply(contractInterface, args).bytecode\n  };\n});\nmodule.exports = Contract;","map":null,"metadata":{},"sourceType":"script"}