{"ast":null,"code":"'use strict';\n\nvar pull = require('pull-stream');\n\nvar pushable = require('pull-pushable');\n\nvar batch = require('pull-batch');\n\nvar pullPair = require('pull-pair');\n\nvar through = require('pull-through');\n\nvar pullWrite = require('pull-write');\n\nvar pause = require('pull-pause');\n\nmodule.exports = function trickleReduceToRoot(reduce, options) {\n  var pair = pullPair();\n  var result = pushable();\n  var pausable = pause(function () {});\n  var pendingResumes = 0;\n  pull(pair.source, pausable, trickle(0, -1), batch(Infinity), pull.asyncMap(reduce), pull.collect(function (err, roots) {\n    if (err) {\n      result.end(err);\n    } else {\n      if (roots.length === 1) {\n        result.push(roots[0]);\n        result.end();\n      } else if (roots.length > 1) {\n        result.end(new Error('expected a maximum of 1 roots and got ' + roots.length));\n      } else {\n        result.end();\n      }\n    }\n  }));\n  return {\n    sink: pair.sink,\n    source: result\n  };\n\n  function trickle(indent, maxDepth) {\n    var iteration = 0;\n    var depth = 0;\n    var deeper;\n    var aborting = false;\n    var result = pushable();\n    return {\n      source: result,\n      sink: pullWrite(write, null, 1, end)\n    };\n\n    function write(nodes, callback) {\n      var ended = false;\n      var node = nodes[0];\n\n      if (depth && !deeper) {\n        deeper = pushable();\n        pull(deeper, trickle(indent + 1, depth - 1), through(function (d) {\n          this.queue(d);\n        }, function (err) {\n          if (err) {\n            this.emit('error', err);\n            return; // early\n          }\n\n          if (!ended) {\n            ended = true;\n            pendingResumes++;\n            pausable.pause();\n          }\n\n          this.queue(null);\n        }), batch(Infinity), pull.asyncMap(reduce), pull.collect(function (err, nodes) {\n          pendingResumes--;\n\n          if (err) {\n            result.end(err);\n            return;\n          }\n\n          nodes.forEach(function (node) {\n            result.push(node);\n          });\n          iterate();\n        }));\n      }\n\n      if (deeper) {\n        deeper.push(node);\n      } else {\n        result.push(node);\n        iterate();\n      }\n\n      callback();\n    }\n\n    function iterate() {\n      deeper = null;\n      iteration++;\n\n      if (depth === 0 && iteration === options.maxChildrenPerNode || depth > 0 && iteration === options.layerRepeat) {\n        iteration = 0;\n        depth++;\n      }\n\n      if (!aborting && maxDepth >= 0 && depth > maxDepth || aborting && !pendingResumes) {\n        aborting = true;\n        result.end();\n      }\n\n      if (!pendingResumes) {\n        pausable.resume();\n      }\n    }\n\n    function end(err) {\n      if (err) {\n        result.end(err);\n        return;\n      }\n\n      if (deeper) {\n        if (!aborting) {\n          aborting = true;\n          deeper.end();\n        }\n      } else {\n        result.end();\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}