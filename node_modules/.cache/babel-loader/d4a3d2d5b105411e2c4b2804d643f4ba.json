{"ast":null,"code":"'use strict';\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar aes_js_1 = __importDefault(require(\"aes-js\"));\n\nvar scrypt_js_1 = __importDefault(require(\"scrypt-js\"));\n\nvar uuid_1 = __importDefault(require(\"uuid\"));\n\nvar signing_key_1 = require(\"./signing-key\");\n\nvar HDNode = __importStar(require(\"./hdnode\"));\n\nvar address_1 = require(\"./address\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar pbkdf2_1 = require(\"./pbkdf2\");\n\nvar keccak256_1 = require(\"./keccak256\");\n\nvar utf8_1 = require(\"./utf8\");\n\nvar random_bytes_1 = require(\"./random-bytes\");\n\nfunction looseArrayify(hexString) {\n  if (typeof hexString === 'string' && hexString.substring(0, 2) !== '0x') {\n    hexString = '0x' + hexString;\n  }\n\n  return bytes_1.arrayify(hexString);\n}\n\nfunction zpad(value, length) {\n  value = String(value);\n\n  while (value.length < length) {\n    value = '0' + value;\n  }\n\n  return value;\n}\n\nfunction getPassword(password) {\n  if (typeof password === 'string') {\n    return utf8_1.toUtf8Bytes(password, utf8_1.UnicodeNormalizationForm.NFKC);\n  }\n\n  return bytes_1.arrayify(password);\n} // Search an Object and its children recursively, caselessly.\n\n\nfunction searchPath(object, path) {\n  var currentChild = object;\n  var comps = path.toLowerCase().split('/');\n\n  for (var i = 0; i < comps.length; i++) {\n    // Search for a child object with a case-insensitive matching key\n    var matchingChild = null;\n\n    for (var key in currentChild) {\n      if (key.toLowerCase() === comps[i]) {\n        matchingChild = currentChild[key];\n        break;\n      }\n    } // Didn't find one. :'(\n\n\n    if (matchingChild === null) {\n      return null;\n    } // Now check this child...\n\n\n    currentChild = matchingChild;\n  }\n\n  return currentChild;\n} // @TODO: Make a type for string or arrayish\n// See: https://github.com/ethereum/pyethsaletool\n\n\nfunction decryptCrowdsale(json, password) {\n  var data = JSON.parse(json);\n  password = getPassword(password); // Ethereum Address\n\n  var ethaddr = address_1.getAddress(searchPath(data, 'ethaddr')); // Encrypted Seed\n\n  var encseed = looseArrayify(searchPath(data, 'encseed'));\n\n  if (!encseed || encseed.length % 16 !== 0) {\n    throw new Error('invalid encseed');\n  }\n\n  var key = pbkdf2_1.pbkdf2(password, password, 2000, 32, 'sha256').slice(0, 16);\n  var iv = encseed.slice(0, 16);\n  var encryptedSeed = encseed.slice(16); // Decrypt the seed\n\n  var aesCbc = new aes_js_1.default.ModeOfOperation.cbc(key, iv);\n  var seed = bytes_1.arrayify(aesCbc.decrypt(encryptedSeed));\n  seed = aes_js_1.default.padding.pkcs7.strip(seed); // This wallet format is weird... Convert the binary encoded hex to a string.\n\n  var seedHex = '';\n\n  for (var i = 0; i < seed.length; i++) {\n    seedHex += String.fromCharCode(seed[i]);\n  }\n\n  var seedHexBytes = utf8_1.toUtf8Bytes(seedHex);\n  var signingKey = new signing_key_1.SigningKey(keccak256_1.keccak256(seedHexBytes));\n\n  if (signingKey.address !== ethaddr) {\n    throw new Error('corrupt crowdsale wallet');\n  }\n\n  return signingKey;\n}\n\nexports.decryptCrowdsale = decryptCrowdsale; //@TODO: string or arrayish\n\nfunction decrypt(json, password, progressCallback) {\n  var data = JSON.parse(json);\n  var passwordBytes = getPassword(password);\n\n  var decrypt = function decrypt(key, ciphertext) {\n    var cipher = searchPath(data, 'crypto/cipher');\n\n    if (cipher === 'aes-128-ctr') {\n      var iv = looseArrayify(searchPath(data, 'crypto/cipherparams/iv'));\n      var counter = new aes_js_1.default.Counter(iv);\n      var aesCtr = new aes_js_1.default.ModeOfOperation.ctr(key, counter);\n      return bytes_1.arrayify(aesCtr.decrypt(ciphertext));\n    }\n\n    return null;\n  };\n\n  var computeMAC = function computeMAC(derivedHalf, ciphertext) {\n    return keccak256_1.keccak256(bytes_1.concat([derivedHalf, ciphertext]));\n  };\n\n  var getSigningKey = function getSigningKey(key, reject) {\n    var ciphertext = looseArrayify(searchPath(data, 'crypto/ciphertext'));\n    var computedMAC = bytes_1.hexlify(computeMAC(key.slice(16, 32), ciphertext)).substring(2);\n\n    if (computedMAC !== searchPath(data, 'crypto/mac').toLowerCase()) {\n      reject(new Error('invalid password'));\n      return null;\n    }\n\n    var privateKey = decrypt(key.slice(0, 16), ciphertext);\n    var mnemonicKey = key.slice(32, 64);\n\n    if (!privateKey) {\n      reject(new Error('unsupported cipher'));\n      return null;\n    }\n\n    var signingKey = new signing_key_1.SigningKey(privateKey);\n\n    if (signingKey.address !== address_1.getAddress(data.address)) {\n      reject(new Error('address mismatch'));\n      return null;\n    } // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n\n\n    if (searchPath(data, 'x-ethers/version') === '0.1') {\n      var mnemonicCiphertext = looseArrayify(searchPath(data, 'x-ethers/mnemonicCiphertext'));\n      var mnemonicIv = looseArrayify(searchPath(data, 'x-ethers/mnemonicCounter'));\n      var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);\n      var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n      var path = searchPath(data, 'x-ethers/path') || HDNode.defaultPath;\n      var entropy = bytes_1.arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\n      var mnemonic = HDNode.entropyToMnemonic(entropy);\n      var node = HDNode.fromMnemonic(mnemonic).derivePath(path);\n\n      if (node.privateKey != bytes_1.hexlify(privateKey)) {\n        reject(new Error('mnemonic mismatch'));\n        return null;\n      }\n\n      signingKey = new signing_key_1.SigningKey(node);\n    }\n\n    return signingKey;\n  };\n\n  return new Promise(function (resolve, reject) {\n    var kdf = searchPath(data, 'crypto/kdf');\n\n    if (kdf && typeof kdf === 'string') {\n      if (kdf.toLowerCase() === 'scrypt') {\n        var salt = looseArrayify(searchPath(data, 'crypto/kdfparams/salt'));\n        var N = parseInt(searchPath(data, 'crypto/kdfparams/n'));\n        var r = parseInt(searchPath(data, 'crypto/kdfparams/r'));\n        var p = parseInt(searchPath(data, 'crypto/kdfparams/p'));\n\n        if (!N || !r || !p) {\n          reject(new Error('unsupported key-derivation function parameters'));\n          return;\n        } // Make sure N is a power of 2\n\n\n        if ((N & N - 1) !== 0) {\n          reject(new Error('unsupported key-derivation function parameter value for N'));\n          return;\n        }\n\n        var dkLen = parseInt(searchPath(data, 'crypto/kdfparams/dklen'));\n\n        if (dkLen !== 32) {\n          reject(new Error('unsupported key-derivation derived-key length'));\n          return;\n        }\n\n        if (progressCallback) {\n          progressCallback(0);\n        }\n\n        scrypt_js_1.default(passwordBytes, salt, N, r, p, 64, function (error, progress, key) {\n          if (error) {\n            error.progress = progress;\n            reject(error);\n          } else if (key) {\n            key = bytes_1.arrayify(key);\n            var signingKey = getSigningKey(key, reject);\n\n            if (!signingKey) {\n              return;\n            }\n\n            if (progressCallback) {\n              progressCallback(1);\n            }\n\n            resolve(signingKey);\n          } else if (progressCallback) {\n            return progressCallback(progress);\n          }\n        });\n      } else if (kdf.toLowerCase() === 'pbkdf2') {\n        var salt = looseArrayify(searchPath(data, 'crypto/kdfparams/salt'));\n        var prfFunc = null;\n        var prf = searchPath(data, 'crypto/kdfparams/prf');\n\n        if (prf === 'hmac-sha256') {\n          prfFunc = 'sha256';\n        } else if (prf === 'hmac-sha512') {\n          prfFunc = 'sha512';\n        } else {\n          reject(new Error('unsupported prf'));\n          return;\n        }\n\n        var c = parseInt(searchPath(data, 'crypto/kdfparams/c'));\n        var dkLen = parseInt(searchPath(data, 'crypto/kdfparams/dklen'));\n\n        if (dkLen !== 32) {\n          reject(new Error('unsupported key-derivation derived-key length'));\n          return;\n        }\n\n        var key = pbkdf2_1.pbkdf2(passwordBytes, salt, c, dkLen, prfFunc);\n        var signingKey = getSigningKey(key, reject);\n\n        if (!signingKey) {\n          return;\n        }\n\n        resolve(signingKey);\n      } else {\n        reject(new Error('unsupported key-derivation function'));\n      }\n    } else {\n      reject(new Error('unsupported key-derivation function'));\n    }\n  });\n}\n\nexports.decrypt = decrypt;\n\nfunction encrypt(privateKey, password, options, progressCallback) {\n  // the options are optional, so adjust the call as needed\n  if (typeof options === 'function' && !progressCallback) {\n    progressCallback = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  } // Check the private key\n\n\n  var privateKeyBytes = null;\n\n  if (signing_key_1.SigningKey.isSigningKey(privateKey)) {\n    privateKeyBytes = bytes_1.arrayify(privateKey.privateKey);\n  } else {\n    privateKeyBytes = bytes_1.arrayify(privateKey);\n  }\n\n  if (privateKeyBytes.length !== 32) {\n    throw new Error('invalid private key');\n  }\n\n  var passwordBytes = getPassword(password);\n  var entropy = null;\n\n  if (options.entropy) {\n    entropy = bytes_1.arrayify(options.entropy);\n  }\n\n  if (options.mnemonic) {\n    if (entropy) {\n      if (HDNode.entropyToMnemonic(entropy) !== options.mnemonic) {\n        throw new Error('entropy and mnemonic mismatch');\n      }\n    } else {\n      entropy = bytes_1.arrayify(HDNode.mnemonicToEntropy(options.mnemonic));\n    }\n  }\n\n  var path = options.path;\n\n  if (entropy && !path) {\n    path = HDNode.defaultPath;\n  }\n\n  var client = options.client;\n\n  if (!client) {\n    client = \"ethers.js\";\n  } // Check/generate the salt\n\n\n  var salt = null;\n\n  if (options.salt) {\n    salt = bytes_1.arrayify(options.salt);\n  } else {\n    salt = random_bytes_1.randomBytes(32);\n    ;\n  } // Override initialization vector\n\n\n  var iv = null;\n\n  if (options.iv) {\n    iv = bytes_1.arrayify(options.iv);\n\n    if (iv.length !== 16) {\n      throw new Error('invalid iv');\n    }\n  } else {\n    iv = random_bytes_1.randomBytes(16);\n  } // Override the uuid\n\n\n  var uuidRandom = null;\n\n  if (options.uuid) {\n    uuidRandom = bytes_1.arrayify(options.uuid);\n\n    if (uuidRandom.length !== 16) {\n      throw new Error('invalid uuid');\n    }\n  } else {\n    uuidRandom = random_bytes_1.randomBytes(16);\n  } // Override the scrypt password-based key derivation function parameters\n\n\n  var N = 1 << 17,\n      r = 8,\n      p = 1;\n\n  if (options.scrypt) {\n    if (options.scrypt.N) {\n      N = options.scrypt.N;\n    }\n\n    if (options.scrypt.r) {\n      r = options.scrypt.r;\n    }\n\n    if (options.scrypt.p) {\n      p = options.scrypt.p;\n    }\n  }\n\n  return new Promise(function (resolve, reject) {\n    if (progressCallback) {\n      progressCallback(0);\n    } // We take 64 bytes:\n    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n\n\n    scrypt_js_1.default(passwordBytes, salt, N, r, p, 64, function (error, progress, key) {\n      if (error) {\n        error.progress = progress;\n        reject(error);\n      } else if (key) {\n        key = bytes_1.arrayify(key); // This will be used to encrypt the wallet (as per Web3 secret storage)\n\n        var derivedKey = key.slice(0, 16);\n        var macPrefix = key.slice(16, 32); // This will be used to encrypt the mnemonic phrase (if any)\n\n        var mnemonicKey = key.slice(32, 64); // Get the address for this private key\n\n        var address = new signing_key_1.SigningKey(privateKeyBytes).address; // Encrypt the private key\n\n        var counter = new aes_js_1.default.Counter(iv);\n        var aesCtr = new aes_js_1.default.ModeOfOperation.ctr(derivedKey, counter);\n        var ciphertext = bytes_1.arrayify(aesCtr.encrypt(privateKeyBytes)); // Compute the message authentication code, used to check the password\n\n        var mac = keccak256_1.keccak256(bytes_1.concat([macPrefix, ciphertext])); // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n\n        var data = {\n          address: address.substring(2).toLowerCase(),\n          id: uuid_1.default.v4({\n            random: uuidRandom\n          }),\n          version: 3,\n          Crypto: {\n            cipher: 'aes-128-ctr',\n            cipherparams: {\n              iv: bytes_1.hexlify(iv).substring(2)\n            },\n            ciphertext: bytes_1.hexlify(ciphertext).substring(2),\n            kdf: 'scrypt',\n            kdfparams: {\n              salt: bytes_1.hexlify(salt).substring(2),\n              n: N,\n              dklen: 32,\n              p: p,\n              r: r\n            },\n            mac: mac.substring(2)\n          }\n        }; // If we have a mnemonic, encrypt it into the JSON wallet\n\n        if (entropy) {\n          var mnemonicIv = random_bytes_1.randomBytes(16);\n          var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);\n          var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n          var mnemonicCiphertext = bytes_1.arrayify(mnemonicAesCtr.encrypt(entropy));\n          var now = new Date();\n          var timestamp = now.getUTCFullYear() + '-' + zpad(now.getUTCMonth() + 1, 2) + '-' + zpad(now.getUTCDate(), 2) + 'T' + zpad(now.getUTCHours(), 2) + '-' + zpad(now.getUTCMinutes(), 2) + '-' + zpad(now.getUTCSeconds(), 2) + '.0Z';\n          data['x-ethers'] = {\n            client: client,\n            gethFilename: 'UTC--' + timestamp + '--' + data.address,\n            mnemonicCounter: bytes_1.hexlify(mnemonicIv).substring(2),\n            mnemonicCiphertext: bytes_1.hexlify(mnemonicCiphertext).substring(2),\n            path: path,\n            version: \"0.1\"\n          };\n        }\n\n        if (progressCallback) {\n          progressCallback(1);\n        }\n\n        resolve(JSON.stringify(data));\n      } else if (progressCallback) {\n        return progressCallback(progress);\n      }\n    });\n  });\n}\n\nexports.encrypt = encrypt;","map":null,"metadata":{},"sourceType":"script"}