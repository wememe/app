{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar pMap = require('p-map');\n\nvar Entry = require('./entry');\n\nvar EntryIO = require('./entry-io');\n\nvar Clock = require('./lamport-clock');\n\nvar LogError = require('./log-errors');\n\nvar isDefined = require('./utils/is-defined');\n\nvar _uniques = require('./utils/uniques');\n\nvar intersection = require('./utils/intersection');\n\nvar difference = require('./utils/difference');\n\nvar last = function last(arr, n) {\n  return arr.slice(arr.length - n, arr.length);\n};\n\nvar LogIO =\n/*#__PURE__*/\nfunction () {\n  function LogIO() {\n    _classCallCheck(this, LogIO);\n  }\n\n  _createClass(LogIO, null, [{\n    key: \"toMultihash\",\n    value: function toMultihash(immutabledb, log) {\n      if (!isDefined(immutabledb)) throw LogError.ImmutableDBNotDefinedError();\n      if (!isDefined(log)) throw LogError.LogNotDefinedError();\n      if (log.values.length < 1) throw new Error(\"Can't serialize an empty log\"); // return this._storage.put(this.toBuffer())\n\n      return immutabledb.object.put(log.toBuffer()).then(function (dagNode) {\n        return dagNode.toJSON().multihash;\n      });\n    }\n    /**\n     * Create a log from multihash\n     * @param {IPFS} ipfs - An IPFS instance\n     * @param {string} hash - Multihash (as a Base58 encoded string) to create the log from\n     * @param {Number} [length=-1] - How many items to include in the log\n     * @param {function(hash, entry, parent, depth)} onProgressCallback\n     * @returns {Promise<Log>}\n     */\n\n  }, {\n    key: \"fromMultihash\",\n    value: function fromMultihash(immutabledb, hash) {\n      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var exclude = arguments.length > 3 ? arguments[3] : undefined;\n      var onProgressCallback = arguments.length > 4 ? arguments[4] : undefined;\n      if (!isDefined(immutabledb)) throw LogError.ImmutableDBNotDefinedError();\n      if (!isDefined(hash)) throw new Error(\"Invalid hash: \".concat(hash));\n      return immutabledb.object.get(hash, {\n        enc: 'base58'\n      }).then(function (dagNode) {\n        return JSON.parse(dagNode.toJSON().data);\n      }) // return immutabledb.get(hash)\n      .then(function (logData) {\n        if (!logData.heads || !logData.id) throw LogError.NotALogError();\n        return EntryIO.fetchAll(immutabledb, logData.heads, length, exclude, null, onProgressCallback).then(function (entries) {\n          // Find latest clock\n          var clock = entries.reduce(function (clock, entry) {\n            if (entry.clock.time > clock.time) {\n              return new Clock(entry.clock.id, entry.clock.time);\n            }\n\n            return clock;\n          }, new Clock(logData.id));\n          var finalEntries = entries.slice().sort(Entry.compare);\n          var heads = finalEntries.filter(function (e) {\n            return logData.heads.includes(e.hash);\n          });\n          return {\n            id: logData.id,\n            values: finalEntries,\n            heads: heads,\n            clock: clock\n          };\n        });\n      });\n    }\n  }, {\n    key: \"fromEntryHash\",\n    value: function fromEntryHash(ipfs, entryHash, id) {\n      var length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n      var exclude = arguments.length > 4 ? arguments[4] : undefined;\n      var onProgressCallback = arguments.length > 5 ? arguments[5] : undefined;\n      if (!isDefined(ipfs)) throw LogError.IpfsNotDefinedError();\n      if (!isDefined(entryHash)) throw new Error(\"'entryHash' must be defined\"); // Fetch given length, return size at least the given input entries\n\n      length = length > -1 ? Math.max(length, 1) : length; // Make sure we pass hashes instead of objects to the fetcher function\n\n      var excludeHashes = exclude; // ? exclude.map(e => e.hash ? e.hash : e) : exclude\n\n      return EntryIO.fetchParallel(ipfs, [entryHash], length, excludeHashes, null, null, onProgressCallback).then(function (entries) {\n        // Cap the result at the right size by taking the last n entries,\n        // or if given length is -1, then take all\n        var sliced = length > -1 ? last(entries, length) : entries;\n        return {\n          values: sliced\n        };\n      });\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(ipfs, json) {\n      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var key = arguments.length > 3 ? arguments[3] : undefined;\n      var timeout = arguments.length > 4 ? arguments[4] : undefined;\n      var onProgressCallback = arguments.length > 5 ? arguments[5] : undefined;\n      if (!isDefined(ipfs)) throw LogError.ImmutableDBNotDefinedError();\n      return EntryIO.fetchParallel(ipfs, json.heads.map(function (e) {\n        return e.hash;\n      }), length, [], 16, timeout, onProgressCallback).then(function (entries) {\n        var finalEntries = entries.slice().sort(Entry.compare);\n        var heads = entries.filter(function (e) {\n          return json.heads.includes(e.hash);\n        });\n        return {\n          id: json.id,\n          values: finalEntries,\n          heads: json.heads\n        };\n      });\n    }\n    /**\n     * Create a new log starting from an entry\n     * @param {IPFS} ipfs An IPFS instance\n     * @param {Array<Entry>} entries An entry or an array of entries to fetch a log from\n     * @param {Number} [length=-1] How many entries to include. Default: infinite.\n     * @param {Array<Entry|string>} [exclude] Entries to not fetch (cached)\n     * @param {function(hash, entry, parent, depth)} [onProgressCallback]\n     * @returns {Promise<Log>}\n     */\n\n  }, {\n    key: \"fromEntry\",\n    value: function fromEntry(immutabledb, sourceEntries) {\n      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var exclude = arguments.length > 3 ? arguments[3] : undefined;\n      var key = arguments.length > 4 ? arguments[4] : undefined;\n      var keys = arguments.length > 5 ? arguments[5] : undefined;\n      var onProgressCallback = arguments.length > 6 ? arguments[6] : undefined;\n      if (!isDefined(immutabledb)) throw LogError.ImmutableDBNotDefinedError();\n      if (!isDefined(sourceEntries)) throw new Error(\"'sourceEntries' must be defined\"); // Make sure we only have Entry objects as input\n\n      if (!Array.isArray(sourceEntries) && !Entry.isEntry(sourceEntries)) {\n        throw new Error(\"'sourceEntries' argument must be an array of Entry instances or a single Entry\");\n      }\n\n      if (!Array.isArray(sourceEntries)) {\n        sourceEntries = [sourceEntries];\n      } // Fetch given length, return size at least the given input entries\n\n\n      length = length > -1 ? Math.max(length, sourceEntries.length) : length; // Make sure we pass hashes instead of objects to the fetcher function\n\n      var excludeHashes = exclude ? exclude.map(function (e) {\n        return e.hash ? e.hash : e;\n      }) : exclude;\n      var hashes = sourceEntries.map(function (e) {\n        return e.hash;\n      });\n      return EntryIO.fetchParallel(immutabledb, hashes, length, excludeHashes, null, null, onProgressCallback).then(function (entries) {\n        var combined = sourceEntries.concat(entries);\n\n        var uniques = _uniques(combined, 'hash').sort(Entry.compare); // Cap the result at the right size by taking the last n entries\n\n\n        var sliced = uniques.slice(length > -1 ? -length : -uniques.length); // Make sure that the given input entries are present in the result\n        // in order to not lose references\n\n        var missingSourceEntries = difference(sliced, sourceEntries, 'hash');\n\n        var replaceInFront = function replaceInFront(a, withEntries) {\n          var sliced = a.slice(withEntries.length, a.length);\n          return withEntries.concat(sliced);\n        }; // Add the input entries at the beginning of the array and remove\n        // as many elements from the array before inserting the original entries\n\n\n        var result = replaceInFront(sliced, missingSourceEntries);\n        return {\n          id: result[result.length - 1].id,\n          values: result\n        };\n      });\n    }\n  }]);\n\n  return LogIO;\n}();\n\nmodule.exports = LogIO;","map":null,"metadata":{},"sourceType":"script"}