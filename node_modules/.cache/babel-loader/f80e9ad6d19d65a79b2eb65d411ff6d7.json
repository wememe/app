{"ast":null,"code":"/* globals window, exports, define */\n(function (window) {\n  'use strict';\n\n  var re = {\n    not_string: /[^s]/,\n    not_bool: /[^t]/,\n    not_type: /[^T]/,\n    not_primitive: /[^v]/,\n    number: /[diefg]/,\n    numeric_arg: /[bcdiefguxX]/,\n    json: /[j]/,\n    not_json: /[^j]/,\n    text: /^[^\\x25]+/,\n    modulo: /^\\x25{2}/,\n    placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n    key: /^([a-z_][a-z_\\d]*)/i,\n    key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n    index_access: /^\\[(\\d+)\\]/,\n    sign: /^[\\+\\-]/\n  };\n\n  function sprintf() {\n    var key = arguments[0],\n        cache = sprintf.cache;\n\n    if (!cache[key]) {\n      cache[key] = sprintf.parse(key);\n    }\n\n    return sprintf.format.call(null, cache[key], arguments);\n  }\n\n  sprintf.format = function (parse_tree, argv) {\n    var cursor = 1,\n        tree_length = parse_tree.length,\n        node_type = '',\n        arg,\n        output = [],\n        i,\n        k,\n        match,\n        pad,\n        pad_character,\n        pad_length,\n        is_positive = true,\n        sign = '';\n\n    for (i = 0; i < tree_length; i++) {\n      node_type = get_type(parse_tree[i]);\n\n      if (node_type === 'string') {\n        output[output.length] = parse_tree[i];\n      } else if (node_type === 'array') {\n        match = parse_tree[i]; // convenience purposes only\n\n        if (match[2]) {\n          // keyword argument\n          arg = argv[cursor];\n\n          for (k = 0; k < match[2].length; k++) {\n            if (!arg.hasOwnProperty(match[2][k])) {\n              throw new Error(sprintf('[sprintf] property \"%s\" does not exist', match[2][k]));\n            }\n\n            arg = arg[match[2][k]];\n          }\n        } else if (match[1]) {\n          // positional argument (explicit)\n          arg = argv[match[1]];\n        } else {\n          // positional argument (implicit)\n          arg = argv[cursor++];\n        }\n\n        if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && get_type(arg) == 'function') {\n          arg = arg();\n        }\n\n        if (re.numeric_arg.test(match[8]) && get_type(arg) != 'number' && isNaN(arg)) {\n          throw new TypeError(sprintf(\"[sprintf] expecting number but found %s\", get_type(arg)));\n        }\n\n        if (re.number.test(match[8])) {\n          is_positive = arg >= 0;\n        }\n\n        switch (match[8]) {\n          case 'b':\n            arg = parseInt(arg, 10).toString(2);\n            break;\n\n          case 'c':\n            arg = String.fromCharCode(parseInt(arg, 10));\n            break;\n\n          case 'd':\n          case 'i':\n            arg = parseInt(arg, 10);\n            break;\n\n          case 'j':\n            arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0);\n            break;\n\n          case 'e':\n            arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential();\n            break;\n\n          case 'f':\n            arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);\n            break;\n\n          case 'g':\n            arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg);\n            break;\n\n          case 'o':\n            arg = arg.toString(8);\n            break;\n\n          case 's':\n            arg = String(arg);\n            arg = match[7] ? arg.substring(0, match[7]) : arg;\n            break;\n\n          case 't':\n            arg = String(!!arg);\n            arg = match[7] ? arg.substring(0, match[7]) : arg;\n            break;\n\n          case 'T':\n            arg = get_type(arg);\n            arg = match[7] ? arg.substring(0, match[7]) : arg;\n            break;\n\n          case 'u':\n            arg = parseInt(arg, 10) >>> 0;\n            break;\n\n          case 'v':\n            arg = arg.valueOf();\n            arg = match[7] ? arg.substring(0, match[7]) : arg;\n            break;\n\n          case 'x':\n            arg = parseInt(arg, 10).toString(16);\n            break;\n\n          case 'X':\n            arg = parseInt(arg, 10).toString(16).toUpperCase();\n            break;\n        }\n\n        if (re.json.test(match[8])) {\n          output[output.length] = arg;\n        } else {\n          if (re.number.test(match[8]) && (!is_positive || match[3])) {\n            sign = is_positive ? '+' : '-';\n            arg = arg.toString().replace(re.sign, '');\n          } else {\n            sign = '';\n          }\n\n          pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' ';\n          pad_length = match[6] - (sign + arg).length;\n          pad = match[6] ? pad_length > 0 ? str_repeat(pad_character, pad_length) : '' : '';\n          output[output.length] = match[5] ? sign + arg + pad : pad_character === '0' ? sign + pad + arg : pad + sign + arg;\n        }\n      }\n    }\n\n    return output.join('');\n  };\n\n  sprintf.cache = Object.create(null);\n\n  sprintf.parse = function (fmt) {\n    var _fmt = fmt,\n        match = [],\n        parse_tree = [],\n        arg_names = 0;\n\n    while (_fmt) {\n      if ((match = re.text.exec(_fmt)) !== null) {\n        parse_tree[parse_tree.length] = match[0];\n      } else if ((match = re.modulo.exec(_fmt)) !== null) {\n        parse_tree[parse_tree.length] = '%';\n      } else if ((match = re.placeholder.exec(_fmt)) !== null) {\n        if (match[2]) {\n          arg_names |= 1;\n          var field_list = [],\n              replacement_field = match[2],\n              field_match = [];\n\n          if ((field_match = re.key.exec(replacement_field)) !== null) {\n            field_list[field_list.length] = field_match[1];\n\n            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n              if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                field_list[field_list.length] = field_match[1];\n              } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                field_list[field_list.length] = field_match[1];\n              } else {\n                throw new SyntaxError(\"[sprintf] failed to parse named argument key\");\n              }\n            }\n          } else {\n            throw new SyntaxError(\"[sprintf] failed to parse named argument key\");\n          }\n\n          match[2] = field_list;\n        } else {\n          arg_names |= 2;\n        }\n\n        if (arg_names === 3) {\n          throw new Error(\"[sprintf] mixing positional and named placeholders is not (yet) supported\");\n        }\n\n        parse_tree[parse_tree.length] = match;\n      } else {\n        throw new SyntaxError(\"[sprintf] unexpected placeholder\");\n      }\n\n      _fmt = _fmt.substring(match[0].length);\n    }\n\n    return parse_tree;\n  };\n\n  var vsprintf = function vsprintf(fmt, argv, _argv) {\n    _argv = (argv || []).slice(0);\n\n    _argv.splice(0, 0, fmt);\n\n    return sprintf.apply(null, _argv);\n  };\n  /**\n   * helpers\n   */\n\n\n  function get_type(variable) {\n    if (typeof variable === 'number') {\n      return 'number';\n    } else if (typeof variable === 'string') {\n      return 'string';\n    } else {\n      return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();\n    }\n  }\n\n  var preformattedPadding = {\n    '0': ['', '0', '00', '000', '0000', '00000', '000000', '0000000'],\n    ' ': ['', ' ', '  ', '   ', '    ', '     ', '      ', '       '],\n    '_': ['', '_', '__', '___', '____', '_____', '______', '_______']\n  };\n\n  function str_repeat(input, multiplier) {\n    if (multiplier >= 0 && multiplier <= 7 && preformattedPadding[input]) {\n      return preformattedPadding[input][multiplier];\n    }\n\n    return Array(multiplier + 1).join(input);\n  }\n  /**\n   * export to either browser or node.js\n   */\n\n\n  if (typeof exports !== 'undefined') {\n    exports.sprintf = sprintf;\n    exports.vsprintf = vsprintf;\n  }\n\n  if (typeof window !== 'undefined') {\n    window.sprintf = sprintf;\n    window.vsprintf = vsprintf;\n\n    if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return {\n          sprintf: sprintf,\n          vsprintf: vsprintf\n        };\n      });\n    }\n  }\n})(typeof window === 'undefined' ? this : window);","map":null,"metadata":{},"sourceType":"script"}