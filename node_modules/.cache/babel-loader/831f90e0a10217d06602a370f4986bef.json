{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar map = require('async/map');\n\nvar debug = require('debug');\n\nvar once = require('once');\n\nvar log = debug('libp2p:swarm:dialer');\n\nvar DialQueue = require('./queue');\n/**\n * Track dials per peer and limited them.\n */\n\n\nvar LimitDialer =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Create a new dialer.\n   *\n   * @param {number} perPeerLimit\n   * @param {number} dialTimeout\n   */\n  function LimitDialer(perPeerLimit, dialTimeout) {\n    _classCallCheck(this, LimitDialer);\n\n    log('create: %s peer limit, %s dial timeout', perPeerLimit, dialTimeout);\n    this.perPeerLimit = perPeerLimit;\n    this.dialTimeout = dialTimeout;\n    this.queues = new Map();\n  }\n  /**\n   * Dial a list of multiaddrs on the given transport.\n   *\n   * @param {PeerId} peer\n   * @param {SwarmTransport} transport\n   * @param {Array<Multiaddr>} addrs\n   * @param {function(Error, Connection)} callback\n   * @returns {void}\n   */\n\n\n  _createClass(LimitDialer, [{\n    key: \"dialMany\",\n    value: function dialMany(peer, transport, addrs, callback) {\n      var _this = this;\n\n      log('dialMany:start'); // we use a token to track if we want to cancel following dials\n\n      var token = {\n        cancel: false\n      };\n      callback = once(callback); // only call callback once\n\n      map(addrs, function (m, cb) {\n        _this.dialSingle(peer, transport, m, token, cb);\n      }, function (err, results) {\n        if (err) {\n          return callback(err);\n        }\n\n        var success = results.filter(function (res) {\n          return res.conn;\n        });\n\n        if (success.length > 0) {\n          log('dialMany:success');\n          return callback(null, success[0]);\n        }\n\n        log('dialMany:error');\n        var error = new Error('Failed to dial any provided address');\n        error.errors = results.filter(function (res) {\n          return res.error;\n        }).map(function (res) {\n          return res.error;\n        });\n        return callback(error);\n      });\n    }\n    /**\n     * Dial a single multiaddr on the given transport.\n     *\n     * @param {PeerId} peer\n     * @param {SwarmTransport} transport\n     * @param {Multiaddr} addr\n     * @param {CancelToken} token\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"dialSingle\",\n    value: function dialSingle(peer, transport, addr, token, callback) {\n      var ps = peer.toB58String();\n      log('dialSingle: %s:%s', ps, addr.toString());\n      var q;\n\n      if (this.queues.has(ps)) {\n        q = this.queues.get(ps);\n      } else {\n        q = new DialQueue(this.perPeerLimit, this.dialTimeout);\n        this.queues.set(ps, q);\n      }\n\n      q.push(transport, addr, token, callback);\n    }\n  }]);\n\n  return LimitDialer;\n}();\n\nmodule.exports = LimitDialer;","map":null,"metadata":{},"sourceType":"script"}