{"ast":null,"code":"'use strict';\n\nvar multihashes = require('multihashes');\n\nvar CID = require('cids');\n\nvar protobuf = require('protons');\n\nvar fnv1a = require('fnv1a');\n\nvar varint = require('varint');\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode,\n    DAGLink = _require.DAGLink;\n\nvar some = require('async/some');\n\nvar eachOf = require('async/eachOf');\n\nvar pbSchema = require('./pin.proto');\n\nvar emptyKeyHash = 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n';\nvar emptyKey = multihashes.fromB58String(emptyKeyHash);\nvar defaultFanout = 256;\nvar maxItems = 8192;\nvar pb = protobuf(pbSchema);\n\nfunction toB58String(hash) {\n  return new CID(hash).toBaseEncodedString();\n}\n\nfunction readHeader(rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  var rootData = rootNode.data;\n  var hdrLength = varint.decode(rootData);\n  var vBytes = varint.decode.bytes;\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length');\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length');\n  }\n\n  var hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);\n  var header = pb.Set.decode(hdrSlice);\n\n  if (header.version !== 1) {\n    throw new Error(\"Unsupported Set version: \".concat(header.version));\n  }\n\n  if (header.fanout > rootNode.links.length) {\n    throw new Error('Impossibly large fanout');\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  };\n}\n\nfunction hash(seed, key) {\n  var buf = Buffer.alloc(4);\n  buf.writeUInt32LE(seed, 0);\n  var data = Buffer.concat([buf, Buffer.from(toB58String(key))]);\n  return fnv1a(data.toString('binary'));\n}\n\nexports = module.exports = function (dag) {\n  var pinSet = {\n    // should this be part of `object` API?\n    hasDescendant: function hasDescendant(root, childhash, callback) {\n      var seen = {};\n\n      if (CID.isCID(childhash) || Buffer.isBuffer(childhash)) {\n        childhash = toB58String(childhash);\n      }\n\n      return searchChildren(root, callback);\n\n      function searchChildren(root, cb) {\n        some(root.links, function (_ref, someCb) {\n          var multihash = _ref.multihash;\n          var bs58Link = toB58String(multihash);\n\n          if (bs58Link === childhash) {\n            return someCb(null, true);\n          }\n\n          if (bs58Link in seen) {\n            return someCb(null, false);\n          }\n\n          seen[bs58Link] = true;\n          dag.get(multihash, '', {\n            preload: false\n          }, function (err, res) {\n            if (err) {\n              return someCb(err);\n            }\n\n            searchChildren(res.value, someCb);\n          });\n        }, cb);\n      }\n    },\n    storeSet: function storeSet(keys, callback) {\n      var pins = keys.map(function (key) {\n        return {\n          key: key,\n          data: null\n        };\n      });\n      pinSet.storeItems(pins, function (err, rootNode) {\n        if (err) {\n          return callback(err);\n        }\n\n        var opts = {\n          cid: new CID(rootNode.multihash),\n          preload: false\n        };\n        dag.put(rootNode, opts, function (err, cid) {\n          if (err) {\n            return callback(err);\n          }\n\n          callback(null, rootNode);\n        });\n      });\n    },\n    storeItems: function storeItems(items, callback) {\n      return storePins(items, 0, callback);\n\n      function storePins(pins, depth, storePinsCb) {\n        var pbHeader = pb.Set.encode({\n          version: 1,\n          fanout: defaultFanout,\n          seed: depth\n        });\n        var headerBuf = Buffer.concat([Buffer.from(varint.encode(pbHeader.length)), pbHeader]);\n        var fanoutLinks = [];\n\n        for (var i = 0; i < defaultFanout; i++) {\n          fanoutLinks.push(new DAGLink('', 1, emptyKey));\n        }\n\n        if (pins.length <= maxItems) {\n          var nodes = pins.map(function (item) {\n            return {\n              link: new DAGLink('', 1, item.key),\n              data: item.data || Buffer.alloc(0)\n            };\n          }) // sorting makes any ordering of `pins` produce the same DAGNode\n          .sort(function (a, b) {\n            return Buffer.compare(a.link.multihash, b.link.multihash);\n          });\n          var rootLinks = fanoutLinks.concat(nodes.map(function (item) {\n            return item.link;\n          }));\n          var rootData = Buffer.concat([headerBuf].concat(nodes.map(function (item) {\n            return item.data;\n          })));\n          DAGNode.create(rootData, rootLinks, function (err, rootNode) {\n            if (err) {\n              return storePinsCb(err);\n            }\n\n            return storePinsCb(null, rootNode);\n          });\n        } else {\n          // If the array of pins is > maxItems, we:\n          //  - distribute the pins among `defaultFanout` bins\n          //    - create a DAGNode for each bin\n          //      - add each pin as a DAGLink to that bin\n          //  - create a root DAGNode\n          //    - add each bin as a DAGLink\n          //  - send that root DAGNode via callback\n          // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n          // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n          var bins = pins.reduce(function (bins, pin) {\n            var n = hash(depth, pin.key) % defaultFanout;\n            bins[n] = n in bins ? bins[n].concat([pin]) : [pin];\n            return bins;\n          }, {});\n          eachOf(bins, function (bin, idx, eachCb) {\n            storePins(bin, depth + 1, function (err, child) {\n              return storeChild(err, child, idx, eachCb);\n            });\n          }, function (err) {\n            if (err) {\n              return storePinsCb(err);\n            }\n\n            DAGNode.create(headerBuf, fanoutLinks, function (err, rootNode) {\n              if (err) {\n                return storePinsCb(err);\n              }\n\n              return storePinsCb(null, rootNode);\n            });\n          });\n        }\n\n        function storeChild(err, child, binIdx, cb) {\n          if (err) {\n            return cb(err);\n          }\n\n          var opts = {\n            cid: new CID(child.multihash),\n            preload: false\n          };\n          dag.put(child, opts, function (err) {\n            if (err) {\n              return cb(err);\n            }\n\n            fanoutLinks[binIdx] = new DAGLink('', child.size, child.multihash);\n            cb(null);\n          });\n        }\n      }\n    },\n    loadSet: function loadSet(rootNode, name, callback) {\n      var link = rootNode.links.find(function (l) {\n        return l.name === name;\n      });\n\n      if (!link) {\n        return callback(new Error('No link found with name ' + name));\n      }\n\n      dag.get(link.multihash, '', {\n        preload: false\n      }, function (err, res) {\n        if (err) {\n          return callback(err);\n        }\n\n        var keys = [];\n\n        var step = function step(link) {\n          return keys.push(link.multihash);\n        };\n\n        pinSet.walkItems(res.value, step, function (err) {\n          if (err) {\n            return callback(err);\n          }\n\n          return callback(null, keys);\n        });\n      });\n    },\n    walkItems: function walkItems(node, step, callback) {\n      var pbh;\n\n      try {\n        pbh = readHeader(node);\n      } catch (err) {\n        return callback(err);\n      }\n\n      eachOf(node.links, function (link, idx, eachCb) {\n        if (idx < pbh.header.fanout) {\n          // the first pbh.header.fanout links are fanout bins\n          // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n          var linkHash = link.multihash;\n\n          if (!emptyKey.equals(linkHash)) {\n            // walk the links of this fanout bin\n            return dag.get(linkHash, '', {\n              preload: false\n            }, function (err, res) {\n              if (err) {\n                return eachCb(err);\n              }\n\n              pinSet.walkItems(res.value, step, eachCb);\n            });\n          }\n        } else {\n          // otherwise, the link is a pin\n          step(link, idx, pbh.data);\n        }\n\n        eachCb(null);\n      }, callback);\n    }\n  };\n  return pinSet;\n};","map":null,"metadata":{},"sourceType":"script"}