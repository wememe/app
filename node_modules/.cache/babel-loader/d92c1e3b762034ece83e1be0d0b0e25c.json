{"ast":null,"code":"'use strict';\n\nvar CID = require('cids');\n\nvar log = require('debug')('ipfs:mfs:utils:traverse-to');\n\nvar UnixFS = require('ipfs-unixfs');\n\nvar waterfall = require('async/waterfall');\n\nvar reduce = require('async/reduce');\n\nvar withMfsRoot = require('./with-mfs-root');\n\nvar validatePath = require('./validate-path');\n\nvar addLink = require('./add-link');\n\nvar _require = require('./constants'),\n    FILE_SEPARATOR = _require.FILE_SEPARATOR;\n\nvar createNode = require('./create-node');\n\nvar _require2 = require('./errors'),\n    NonFatalError = _require2.NonFatalError;\n\nvar defaultOptions = {\n  parents: false,\n  flush: true,\n  createLastComponent: false,\n  withCreateHint: true\n};\n\nvar traverseTo = function traverseTo(ipfs, path, options, callback) {\n  options = Object.assign({}, defaultOptions, options);\n  log('Traversing to', path);\n  waterfall([function (cb) {\n    return validatePath(path, cb);\n  }, function (path, cb) {\n    if (path.type === 'mfs') {\n      return traverseToMfsObject(ipfs, path, options, cb);\n    }\n\n    return traverseToIpfsObject(ipfs, path, options, cb);\n  }], callback);\n};\n\nvar traverseToIpfsObject = function traverseToIpfsObject(ipfs, path, options, callback) {\n  log('IPFS', path);\n  waterfall([function (cb) {\n    return ipfs.dag.get(path.path, cb);\n  }, function (result, cb) {\n    return cb(null, {\n      name: path.name,\n      node: result && result.value,\n      parent: null\n    });\n  }], callback);\n};\n\nvar traverseToMfsObject = function traverseToMfsObject(ipfs, path, options, callback) {\n  waterfall([function (done) {\n    return withMfsRoot(ipfs, done);\n  }, function (root, done) {\n    var pathSegments = path.path.split(FILE_SEPARATOR).filter(Boolean);\n    var trail = [];\n    waterfall([function (cb) {\n      return ipfs.dag.get(root, cb);\n    }, function (result, cb) {\n      var rootNode = result.value;\n      trail.push({\n        name: FILE_SEPARATOR,\n        node: rootNode,\n        parent: null\n      });\n      reduce(pathSegments.map(function (pathSegment, index) {\n        return {\n          pathSegment: pathSegment,\n          index: index\n        };\n      }), {\n        name: FILE_SEPARATOR,\n        node: rootNode,\n        parent: null\n      }, function (parent, _ref, done) {\n        var pathSegment = _ref.pathSegment,\n            index = _ref.index;\n        var existingLink = parent.node.links.find(function (link) {\n          return link.name === pathSegment;\n        });\n\n        if (!existingLink) {\n          var lastComponent = index === pathSegments.length - 1;\n          log(\"index \".concat(index, \" pathSegments.length \").concat(pathSegments.length, \" pathSegment \").concat(pathSegment, \" lastComponent \").concat(lastComponent), options);\n\n          if (lastComponent && !options.createLastComponent) {\n            log(\"Last segment of \".concat(path.path, \" did not exist\"));\n            return done(new NonFatalError('file does not exist'));\n          } else if (!lastComponent && !options.parents) {\n            log(\"Cannot traverse to \".concat(path.path, \" - \").concat(pathSegment, \" did not exist\"));\n            return done(new NonFatalError('file does not exist'));\n          }\n\n          log(\"Adding empty directory '\".concat(pathSegment, \"' to parent \").concat(parent.name));\n          return waterfall([function (next) {\n            return createNode(ipfs, new UnixFS('directory').marshal(), [], options, next);\n          }, function (emptyDirectory, next) {\n            addLink(ipfs, {\n              parent: parent.node,\n              child: emptyDirectory,\n              name: pathSegment,\n              flush: options.flush\n            }, function (error, updatedParent) {\n              parent.node = updatedParent;\n              next(error, {\n                name: pathSegment,\n                node: emptyDirectory,\n                cid: new CID(emptyDirectory.multihash),\n                parent: parent\n              });\n            });\n          }], function (error, child) {\n            trail.push(child);\n            done(error, child);\n          });\n        }\n\n        var hash = existingLink.hash || existingLink.multihash;\n        var cid = new CID(hash); // child existed, fetch it\n\n        ipfs.dag.get(cid, function (error, result) {\n          if (error) {\n            return done(error);\n          }\n\n          var node = result.value;\n          var child = {\n            name: pathSegment,\n            node: node,\n            parent: parent\n          };\n          trail.push(child);\n          done(null, child);\n        });\n      }, cb);\n    }], done);\n  }], callback);\n};\n\nmodule.exports = traverseTo;","map":null,"metadata":{},"sourceType":"script"}