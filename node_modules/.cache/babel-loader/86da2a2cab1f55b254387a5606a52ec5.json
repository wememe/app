{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar whilst = require('async/whilst');\n\nvar ConsumableBuffer = require('./consumable-buffer');\n\nmodule.exports = function wrapHash(hashFn) {\n  return function hashing(value) {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value;\n    } else {\n      return new InfiniteHash(value, hashFn);\n    }\n  };\n};\n\nvar InfiniteHash =\n/*#__PURE__*/\nfunction () {\n  function InfiniteHash(value, hashFn) {\n    _classCallCheck(this, InfiniteHash);\n\n    if (typeof value !== 'string' && !Buffer.isBuffer(value)) {\n      throw new Error('can only hash strings or buffers');\n    }\n\n    this._value = value;\n    this._hashFn = hashFn;\n    this._depth = -1;\n    this._availableBits = 0;\n    this._currentBufferIndex = 0;\n    this._buffers = [];\n  }\n\n  _createClass(InfiniteHash, [{\n    key: \"take\",\n    value: function take(bits, callback) {\n      var _this = this;\n\n      var pendingBits = bits;\n      whilst(function () {\n        return _this._availableBits < pendingBits;\n      }, function (callback) {\n        _this._produceMoreBits(callback);\n      }, function (err) {\n        if (err) {\n          callback(err);\n          return; // early\n        }\n\n        var result = 0; // TODO: this is sync, no need to use whilst\n\n        whilst(function () {\n          return pendingBits > 0;\n        }, function (callback) {\n          var hash = _this._buffers[_this._currentBufferIndex];\n          var available = Math.min(hash.availableBits(), pendingBits);\n          var took = hash.take(available);\n          result = (result << available) + took;\n          pendingBits -= available;\n          _this._availableBits -= available;\n\n          if (hash.availableBits() === 0) {\n            _this._currentBufferIndex++;\n          }\n\n          callback();\n        }, function (err) {\n          if (err) {\n            callback(err);\n            return; // early\n          }\n\n          process.nextTick(function () {\n            return callback(null, result);\n          });\n        });\n      });\n    }\n  }, {\n    key: \"untake\",\n    value: function untake(bits) {\n      var pendingBits = bits;\n\n      while (pendingBits > 0) {\n        var hash = this._buffers[this._currentBufferIndex];\n        var availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);\n        hash.untake(availableForUntake);\n        pendingBits -= availableForUntake;\n        this._availableBits += availableForUntake;\n\n        if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n          this._depth--;\n          this._currentBufferIndex--;\n        }\n      }\n    }\n  }, {\n    key: \"_produceMoreBits\",\n    value: function _produceMoreBits(callback) {\n      var _this2 = this;\n\n      this._depth++;\n      var value = this._depth ? this._value + this._depth : this._value;\n\n      this._hashFn(value, function (err, hashValue) {\n        if (err) {\n          callback(err);\n          return; // early\n        }\n\n        var buffer = new ConsumableBuffer(hashValue);\n\n        _this2._buffers.push(buffer);\n\n        _this2._availableBits += buffer.availableBits();\n        callback();\n      });\n    }\n  }]);\n\n  return InfiniteHash;\n}();","map":null,"metadata":{},"sourceType":"script"}