{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar EventEmitter = require('events');\n\nvar Big = require('big.js').Big;\n\nvar MovingAverage = require('moving-average');\n/**\n * A queue based manager for stat processing\n *\n * @param {Array<string>} initialCounters\n * @param {any} options\n */\n\n\nvar Stats =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(Stats, _EventEmitter);\n\n  function Stats(initialCounters, options) {\n    var _this;\n\n    _classCallCheck(this, Stats);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Stats).call(this));\n    _this._options = options;\n    _this._queue = [];\n    _this._stats = {};\n    _this._frequencyLastTime = Date.now();\n    _this._frequencyAccumulators = {};\n    _this._movingAverages = {};\n    _this._update = _this._update.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    initialCounters.forEach(function (key) {\n      _this._stats[key] = Big(0);\n      _this._movingAverages[key] = {};\n\n      _this._options.movingAverageIntervals.forEach(function (interval) {\n        var ma = _this._movingAverages[key][interval] = MovingAverage(interval);\n        ma.push(_this._frequencyLastTime, 0);\n      });\n    });\n    return _this;\n  }\n  /**\n   * Initializes the internal timer if there are items in the queue. This\n   * should only need to be called if `Stats.stop` was previously called, as\n   * `Stats.push` will also start the processing.\n   *\n   * @returns {void}\n   */\n\n\n  _createClass(Stats, [{\n    key: \"start\",\n    value: function start() {\n      if (this._queue.length) {\n        this._resetComputeTimeout();\n      }\n    }\n    /**\n     * Stops processing and computing of stats by clearing the internal\n     * timer.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this._timeout) {\n        clearTimeout(this._timeout);\n      }\n    }\n    /**\n     * Returns a clone of the current stats.\n     *\n     * @returns {Map<string, Stat>}\n     */\n\n  }, {\n    key: \"push\",\n\n    /**\n     * Pushes the given operation data to the queue, along with the\n     * current Timestamp, then resets the update timer.\n     *\n     * @param {string} counter\n     * @param {number} inc\n     * @returns {void}\n     */\n    value: function push(counter, inc) {\n      this._queue.push([counter, inc, Date.now()]);\n\n      this._resetComputeTimeout();\n    }\n    /**\n     * Resets the timeout for triggering updates.\n     *\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_resetComputeTimeout\",\n    value: function _resetComputeTimeout() {\n      if (this._timeout) {\n        clearTimeout(this._timeout);\n      }\n\n      this._timeout = setTimeout(this._update, this._nextTimeout());\n    }\n    /**\n     * Calculates and returns the timeout for the next update based on\n     * the urgency of the update.\n     *\n     * @private\n     * @returns {number}\n     */\n\n  }, {\n    key: \"_nextTimeout\",\n    value: function _nextTimeout() {\n      // calculate the need for an update, depending on the queue length\n      var urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;\n      var timeout = Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);\n      return timeout;\n    }\n    /**\n     * If there are items in the queue, they will will be processed and\n     * the frequency for all items will be updated based on the Timestamp\n     * of the last item in the queue. The `update` event will also be emitted\n     * with the latest stats.\n     *\n     * If there are no items in the queue, no action is taken.\n     *\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_update\",\n    value: function _update() {\n      this._timeout = null;\n\n      if (this._queue.length) {\n        var last;\n\n        while (this._queue.length) {\n          var op = last = this._queue.shift();\n\n          this._applyOp(op);\n        }\n\n        this._updateFrequency(last[2]); // contains timestamp of last op\n\n\n        this.emit('update', this._stats);\n      }\n    }\n    /**\n     * For each key in the stats, the frequncy and moving averages\n     * will be updated via Stats._updateFrequencyFor based on the time\n     * difference between calls to this method.\n     *\n     * @private\n     * @param {Timestamp} latestTime\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_updateFrequency\",\n    value: function _updateFrequency(latestTime) {\n      var _this2 = this;\n\n      var timeDiff = latestTime - this._frequencyLastTime;\n      Object.keys(this._stats).forEach(function (key) {\n        _this2._updateFrequencyFor(key, timeDiff, latestTime);\n      });\n      this._frequencyLastTime = latestTime;\n    }\n    /**\n     * Updates the `movingAverages` for the given `key` and also\n     * resets the `frequencyAccumulator` for the `key`.\n     *\n     * @private\n     * @param {string} key\n     * @param {number} timeDiffMS Time in milliseconds\n     * @param {Timestamp} latestTime Time in ticks\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_updateFrequencyFor\",\n    value: function _updateFrequencyFor(key, timeDiffMS, latestTime) {\n      var count = this._frequencyAccumulators[key] || 0;\n      this._frequencyAccumulators[key] = 0;\n      var hz = count / timeDiffMS * 1000;\n      var movingAverages = this._movingAverages[key];\n\n      if (!movingAverages) {\n        movingAverages = this._movingAverages[key] = {};\n      }\n\n      this._options.movingAverageIntervals.forEach(function (movingAverageInterval) {\n        var movingAverage = movingAverages[movingAverageInterval];\n\n        if (!movingAverage) {\n          movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval);\n        }\n\n        movingAverage.push(latestTime, hz);\n      });\n    }\n    /**\n     * For the given operation, `op`, the stats and `frequencyAccumulator`\n     * will be updated or initialized if they don't already exist.\n     *\n     * @private\n     * @param {Array<string, number>} op\n     * @throws {InvalidNumber}\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_applyOp\",\n    value: function _applyOp(op) {\n      var key = op[0];\n      var inc = op[1];\n\n      if (typeof inc !== 'number') {\n        throw new Error('invalid increment number:', inc);\n      }\n\n      var n;\n\n      if (!this._stats.hasOwnProperty(key)) {\n        n = this._stats[key] = Big(0);\n      } else {\n        n = this._stats[key];\n      }\n\n      this._stats[key] = n.plus(inc);\n\n      if (!this._frequencyAccumulators[key]) {\n        this._frequencyAccumulators[key] = 0;\n      }\n\n      this._frequencyAccumulators[key] += inc;\n    }\n  }, {\n    key: \"snapshot\",\n    get: function get() {\n      return Object.assign({}, this._stats);\n    }\n    /**\n     * Returns a clone of the internal movingAverages\n     *\n     * @returns {Array<MovingAverage>}\n     */\n\n  }, {\n    key: \"movingAverages\",\n    get: function get() {\n      return Object.assign({}, this._movingAverages);\n    }\n  }]);\n\n  return Stats;\n}(EventEmitter);\n\nmodule.exports = Stats;","map":null,"metadata":{},"sourceType":"script"}