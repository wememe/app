{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Block = require('ipfs-block');\n\nvar pull = require('pull-stream');\n\nvar CID = require('cids');\n\nvar doUntil = require('async/doUntil');\n\nvar IPFSRepo = require('ipfs-repo');\n\nvar BlockService = require('ipfs-block-service');\n\nvar joinPath = require('path').join;\n\nvar osPathSep = require('path').sep;\n\nvar pullDeferSource = require('pull-defer').source;\n\nvar pullTraverse = require('pull-traverse');\n\nvar map = require('async/map');\n\nvar series = require('async/series');\n\nvar waterfall = require('async/waterfall');\n\nvar MemoryStore = require('interface-datastore').MemoryDatastore;\n\nvar mergeOptions = require('merge-options');\n\nvar ipldDagCbor = require('ipld-dag-cbor');\n\nvar ipldDagPb = require('ipld-dag-pb');\n\nvar ipldRaw = require('ipld-raw');\n\nfunction noop() {}\n\nvar IPLDResolver =\n/*#__PURE__*/\nfunction () {\n  function IPLDResolver(userOptions) {\n    var _this = this;\n\n    _classCallCheck(this, IPLDResolver);\n\n    var options = mergeOptions(IPLDResolver.defaultOptions, userOptions);\n\n    if (!options.blockService) {\n      throw new Error('Missing blockservice');\n    }\n\n    this.bs = options.blockService; // Object with current list of active resolvers\n\n    this.resolvers = {}; // API entry point\n\n    this.support = {}; // Adds support for an IPLD format\n\n    this.support.add = function (multicodec, resolver, util) {\n      if (_this.resolvers[multicodec]) {\n        throw new Error('Resolver already exists for codec \"' + multicodec + '\"');\n      }\n\n      _this.resolvers[multicodec] = {\n        resolver: resolver,\n        util: util\n      };\n    };\n\n    this.support.load = options.loadFormat || function (codec, callback) {\n      callback(new Error(\"No resolver found for codec \\\"\".concat(codec, \"\\\"\")));\n    };\n\n    this.support.rm = function (multicodec) {\n      if (_this.resolvers[multicodec]) {\n        delete _this.resolvers[multicodec];\n      }\n    }; // Enable all supplied formats\n\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = options.formats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var format = _step.value;\n        var resolver = format.resolver,\n            util = format.util;\n        var multicodec = resolver.multicodec;\n        this.support.add(multicodec, resolver, util);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  _createClass(IPLDResolver, [{\n    key: \"get\",\n    value: function get(cid, path, options, callback) {\n      var _this2 = this;\n\n      if (typeof path === 'function') {\n        callback = path;\n        path = undefined;\n      }\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      } // this removes occurrences of ./, //, ../\n      // makes sure that path never starts with ./ or /\n      // path.join is OS specific. Need to convert back to POSIX format.\n\n\n      if (typeof path === 'string') {\n        path = joinPath('/', path).substr(1).split(osPathSep).join('/');\n      }\n\n      if (path === '' || !path) {\n        return this._get(cid, function (err, node) {\n          if (err) {\n            return callback(err);\n          }\n\n          callback(null, {\n            value: node,\n            remainderPath: ''\n          });\n        });\n      }\n\n      var value;\n      doUntil(function (cb) {\n        _this2._getFormat(cid.codec, function (err, format) {\n          if (err) return cb(err); // get block\n          // use local resolver\n          // update path value\n\n          _this2.bs.get(cid, function (err, block) {\n            if (err) {\n              return cb(err);\n            }\n\n            format.resolver.resolve(block.data, path, function (err, result) {\n              if (err) {\n                return cb(err);\n              }\n\n              value = result.value;\n              path = result.remainderPath;\n              cb();\n            });\n          });\n        });\n      }, function () {\n        var endReached = !path || path === '' || path === '/';\n        var isTerminal = value && !IPLDResolver._maybeCID(value);\n\n        if (endReached && isTerminal || options.localResolve) {\n          return true;\n        } else {\n          value = IPLDResolver._maybeCID(value); // continue traversing\n\n          if (value) {\n            cid = value;\n          }\n\n          return false;\n        }\n      }, function (err, results) {\n        if (err) {\n          return callback(err);\n        }\n\n        return callback(null, {\n          value: value,\n          remainderPath: path\n        });\n      });\n    }\n  }, {\n    key: \"getStream\",\n    value: function getStream(cid, path, options) {\n      var deferred = pullDeferSource();\n      this.get(cid, path, options, function (err, result) {\n        if (err) {\n          return deferred.resolve(pull.error(err));\n        }\n\n        deferred.resolve(pull.values([result]));\n      });\n      return deferred;\n    }\n    /**\n     * Get multiple nodes back from an array of CIDs.\n     *\n     * @param {Array<CID>} cids\n     * @param {function(Error, Array)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"getMany\",\n    value: function getMany(cids, callback) {\n      var _this3 = this;\n\n      if (!Array.isArray(cids)) {\n        return callback(new Error('Argument must be an array of CIDs'));\n      }\n\n      this.bs.getMany(cids, function (err, blocks) {\n        if (err) {\n          return callback(err);\n        }\n\n        map(blocks, function (block, mapCallback) {\n          _this3._getFormat(block.cid.codec, function (err, format) {\n            if (err) return mapCallback(err);\n            format.util.deserialize(block.data, mapCallback);\n          });\n        }, callback);\n      });\n    }\n  }, {\n    key: \"put\",\n    value: function put(node, options, callback) {\n      var _this4 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        return setImmediate(function () {\n          return callback(new Error('IPLDResolver.put requires options'));\n        });\n      }\n\n      callback = callback || noop;\n\n      if (options.cid && CID.isCID(options.cid)) {\n        if (options.onlyHash) {\n          return setImmediate(function () {\n            return callback(null, options.cid);\n          });\n        }\n\n        return this._put(options.cid, node, callback);\n      }\n\n      this._getFormat(options.format, function (err, format) {\n        if (err) return callback(err);\n        format.util.cid(node, options, function (err, cid) {\n          if (err) {\n            return callback(err);\n          }\n\n          if (options.onlyHash) {\n            return callback(null, cid);\n          }\n\n          _this4._put(cid, node, callback);\n        });\n      });\n    }\n  }, {\n    key: \"treeStream\",\n    value: function treeStream(cid, path, options) {\n      var _this5 = this;\n\n      if (typeof path === 'object') {\n        options = path;\n        path = undefined;\n      }\n\n      options = options || {};\n      var p;\n\n      if (!options.recursive) {\n        p = pullDeferSource();\n        waterfall([function (cb) {\n          return _this5._getFormat(cid.codec, cb);\n        }, function (format, cb) {\n          return _this5.bs.get(cid, function (err, block) {\n            if (err) return cb(err);\n            cb(null, format, block);\n          });\n        }, function (format, block, cb) {\n          return format.resolver.tree(block.data, cb);\n        }], function (err, paths) {\n          if (err) {\n            p.abort(err);\n            return p;\n          }\n\n          p.resolve(pull.values(paths));\n        });\n      } // recursive\n\n\n      if (options.recursive) {\n        p = pull(pullTraverse.widthFirst({\n          basePath: null,\n          cid: cid\n        }, function (el) {\n          // pass the paths through the pushable pull stream\n          // continue traversing the graph by returning\n          // the next cids with deferred\n          if (typeof el === 'string') {\n            return pull.empty();\n          }\n\n          var deferred = pullDeferSource();\n          var cid = el.cid;\n          waterfall([function (cb) {\n            return _this5._getFormat(cid.codec, cb);\n          }, function (format, cb) {\n            return _this5.bs.get(cid, function (err, block) {\n              if (err) return cb(err);\n              cb(null, format, block);\n            });\n          }, function (format, block, cb) {\n            return format.resolver.tree(block.data, function (err, paths) {\n              if (err) {\n                return cb(err);\n              }\n\n              map(paths, function (p, cb) {\n                format.resolver.isLink(block.data, p, function (err, link) {\n                  if (err) {\n                    return cb(err);\n                  }\n\n                  cb(null, {\n                    path: p,\n                    link: link\n                  });\n                });\n              }, cb);\n            });\n          }], function (err, paths) {\n            if (err) {\n              deferred.abort(err);\n              return deferred;\n            }\n\n            deferred.resolve(pull.values(paths.map(function (p) {\n              var base = el.basePath ? el.basePath + '/' + p.path : p.path;\n\n              if (p.link) {\n                return {\n                  basePath: base,\n                  cid: IPLDResolver._maybeCID(p.link)\n                };\n              }\n\n              return base;\n            })));\n          });\n          return deferred;\n        }), pull.map(function (e) {\n          if (typeof e === 'string') {\n            return e;\n          }\n\n          return e.basePath;\n        }), pull.filter(Boolean));\n      } // filter out by path\n\n\n      if (path) {\n        return pull(p, pull.map(function (el) {\n          if (el.indexOf(path) === 0) {\n            el = el.slice(path.length + 1);\n            return el;\n          }\n        }), pull.filter(Boolean));\n      }\n\n      return p;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(cids, callback) {\n      this.bs.delete(cids, callback);\n    }\n    /*           */\n\n    /* internals */\n\n    /*           */\n\n  }, {\n    key: \"_get\",\n    value: function _get(cid, callback) {\n      var _this6 = this;\n\n      waterfall([function (cb) {\n        return _this6._getFormat(cid.codec, cb);\n      }, function (format, cb) {\n        return _this6.bs.get(cid, function (err, block) {\n          if (err) return cb(err);\n          cb(null, format, block);\n        });\n      }, function (format, block, cb) {\n        format.util.deserialize(block.data, function (err, deserialized) {\n          if (err) {\n            return cb(err);\n          }\n\n          cb(null, deserialized);\n        });\n      }], callback);\n    }\n  }, {\n    key: \"_getFormat\",\n    value: function _getFormat(codec, callback) {\n      var _this7 = this;\n\n      if (this.resolvers[codec]) {\n        return callback(null, this.resolvers[codec]);\n      } // If not supported, attempt to dynamically load this format\n\n\n      this.support.load(codec, function (err, format) {\n        if (err) return callback(err);\n        _this7.resolvers[codec] = format;\n        callback(null, format);\n      });\n    }\n  }, {\n    key: \"_put\",\n    value: function _put(cid, node, callback) {\n      var _this8 = this;\n\n      callback = callback || noop;\n      waterfall([function (cb) {\n        return _this8._getFormat(cid.codec, cb);\n      }, function (format, cb) {\n        return format.util.serialize(node, cb);\n      }, function (buf, cb) {\n        return _this8.bs.put(new Block(buf, cid), cb);\n      }], function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, cid);\n      });\n    }\n    /**\n     * Return a CID instance if it is a link.\n     *\n     * If something is a link `{\"/\": \"baseencodedcid\"}` or a CID, then return\n     * a CID object, else return `null`.\n     *\n     * @param {*} link - The object to check\n     * @returns {?CID} - A CID instance\n     */\n\n  }], [{\n    key: \"_maybeCID\",\n    value: function _maybeCID(link) {\n      if (CID.isCID(link)) {\n        return link;\n      }\n\n      if (link && link['/'] !== undefined) {\n        return new CID(link['/']);\n      }\n\n      return null;\n    }\n  }]);\n\n  return IPLDResolver;\n}();\n/**\n * Default options for IPLD.\n */\n\n\nIPLDResolver.defaultOptions = {\n  formats: [ipldDagCbor, ipldDagPb, ipldRaw]\n  /**\n   * Create an IPLD resolver with an in memory blockservice and\n   * repo.\n   *\n   * @param {function(Error, IPLDResolver)} callback\n   * @returns {void}\n   */\n\n};\n\nIPLDResolver.inMemory = function (callback) {\n  var repo = new IPFSRepo('in-memory', {\n    storageBackends: {\n      root: MemoryStore,\n      blocks: MemoryStore,\n      datastore: MemoryStore\n    },\n    lock: 'memory'\n  });\n  var blockService = new BlockService(repo);\n  series([function (cb) {\n    return repo.init({}, cb);\n  }, function (cb) {\n    return repo.open(cb);\n  }], function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new IPLDResolver({\n      blockService: blockService\n    }));\n  });\n};\n\nmodule.exports = IPLDResolver;","map":null,"metadata":{},"sourceType":"script"}