{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar bs58 = require('bs58');\n\nvar PeerId = require('peer-id');\n\nvar PeerInfo = require('peer-info');\n\nfunction getB58Str(peer) {\n  var b58Str;\n\n  if (typeof peer === 'string') {\n    b58Str = peer;\n  } else if (Buffer.isBuffer(peer)) {\n    b58Str = bs58.encode(peer).toString();\n  } else if (PeerId.isPeerId(peer)) {\n    b58Str = peer.toB58String();\n  } else if (PeerInfo.isPeerInfo(peer)) {\n    b58Str = peer.id.toB58String();\n  } else {\n    throw new Error('not valid PeerId or PeerInfo, or B58Str');\n  }\n\n  return b58Str;\n}\n\nvar PeerBook =\n/*#__PURE__*/\nfunction () {\n  function PeerBook() {\n    _classCallCheck(this, PeerBook);\n\n    this._peers = {};\n  } // checks if peer exists\n  // peer can be PeerId, b58String or PeerInfo\n\n\n  _createClass(PeerBook, [{\n    key: \"has\",\n    value: function has(peer) {\n      var b58Str = getB58Str(peer);\n      return Boolean(this._peers[b58Str]);\n    }\n    /**\n     * Stores a peerInfo, if already exist, merges the new into the old.\n     *\n     * @param {PeerInfo} peerInfo\n     * @param {Boolean} replace\n     * @returns {PeerInfo}\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(peerInfo, replace) {\n      var localPeerInfo = this._peers[peerInfo.id.toB58String()]; // insert if doesn't exist or replace if replace flag is true\n\n\n      if (!localPeerInfo || replace) {\n        this._peers[peerInfo.id.toB58String()] = peerInfo;\n        return peerInfo;\n      } // peerInfo.replace merges by default if none to replace are passed\n\n\n      peerInfo.multiaddrs.forEach(function (ma) {\n        return localPeerInfo.multiaddrs.add(ma);\n      }); // pass active connection state\n\n      var ma = peerInfo.isConnected();\n\n      if (ma) {\n        localPeerInfo.connect(ma);\n      } // pass known protocols\n\n\n      peerInfo.protocols.forEach(function (p) {\n        return localPeerInfo.protocols.add(p);\n      });\n\n      if (!localPeerInfo.id.privKey && peerInfo.id.privKey) {\n        localPeerInfo.id.privKey = peerInfo.id.privKey;\n      }\n\n      if (!localPeerInfo.id.pubKey && peerInfo.id.pubKey) {\n        localPeerInfo.id.pubKey = peerInfo.id.pubKey;\n      }\n\n      return localPeerInfo;\n    }\n    /**\n     * Get the info to the given PeerId, PeerInfo or b58Str id\n     *\n     * @param {PeerId} peer\n     * @returns {PeerInfo}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(peer) {\n      var b58Str = getB58Str(peer);\n      var peerInfo = this._peers[b58Str];\n\n      if (peerInfo) {\n        return peerInfo;\n      }\n\n      throw new Error('PeerInfo not found');\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      return this._peers;\n    }\n  }, {\n    key: \"getAllArray\",\n    value: function getAllArray() {\n      var _this = this;\n\n      return Object.keys(this._peers).map(function (b58Str) {\n        return _this._peers[b58Str];\n      });\n    }\n  }, {\n    key: \"getMultiaddrs\",\n    value: function getMultiaddrs(peer) {\n      var info = this.get(peer);\n      return info.multiaddrs.toArray();\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(peer) {\n      var b58Str = getB58Str(peer);\n\n      if (this._peers[b58Str]) {\n        delete this._peers[b58Str];\n      }\n    }\n  }]);\n\n  return PeerBook;\n}();\n\nmodule.exports = PeerBook;","map":null,"metadata":{},"sourceType":"script"}