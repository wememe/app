{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar nextTick = require('async/nextTick');\n\nvar Message = require('../types/message');\n\nvar Wantlist = require('../types/wantlist');\n\nvar CONSTANTS = require('../constants');\n\nvar MsgQueue = require('./msg-queue');\n\nvar logger = require('../utils').logger;\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function WantManager(peerId, network, stats) {\n    _classCallCheck(this, WantManager);\n\n    this.peers = new Map();\n    this.wantlist = new Wantlist(stats);\n    this.network = network;\n    this._stats = stats;\n    this._peerId = peerId;\n    this._log = logger(peerId, 'want');\n  }\n\n  _createClass(WantManager, [{\n    key: \"_addEntries\",\n    value: function _addEntries(cids, cancel, force) {\n      var _this = this;\n\n      var entries = cids.map(function (cid, i) {\n        return new Message.Entry(cid, CONSTANTS.kMaxPriority - i, cancel);\n      });\n      entries.forEach(function (e) {\n        // add changes to our wantlist\n        if (e.cancel) {\n          if (force) {\n            _this.wantlist.removeForce(e.cid);\n          } else {\n            _this.wantlist.remove(e.cid);\n          }\n        } else {\n          _this._log('adding to wl');\n\n          _this.wantlist.add(e.cid, e.priority);\n        }\n      }); // broadcast changes\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.peers.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var p = _step.value;\n          p.addEntries(entries);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_startPeerHandler\",\n    value: function _startPeerHandler(peerId) {\n      var mq = this.peers.get(peerId.toB58String());\n\n      if (mq) {\n        mq.refcnt++;\n        return;\n      }\n\n      mq = new MsgQueue(this._peerId, peerId, this.network); // new peer, give them the full wantlist\n\n      var fullwantlist = new Message(true);\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.wantlist.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var entry = _step2.value;\n          fullwantlist.addEntry(entry[1].cid, entry[1].priority);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      mq.addMessage(fullwantlist);\n      this.peers.set(peerId.toB58String(), mq);\n      return mq;\n    }\n  }, {\n    key: \"_stopPeerHandler\",\n    value: function _stopPeerHandler(peerId) {\n      var mq = this.peers.get(peerId.toB58String());\n\n      if (!mq) {\n        return;\n      }\n\n      mq.refcnt--;\n\n      if (mq.refcnt > 0) {\n        return;\n      }\n\n      this.peers.delete(peerId.toB58String());\n    } // add all the cids to the wantlist\n\n  }, {\n    key: \"wantBlocks\",\n    value: function wantBlocks(cids) {\n      this._addEntries(cids, false);\n    } // remove blocks of all the given keys without respecting refcounts\n\n  }, {\n    key: \"unwantBlocks\",\n    value: function unwantBlocks(cids) {\n      this._log('unwant blocks: %s', cids.length);\n\n      this._addEntries(cids, true, true);\n    } // cancel wanting all of the given keys\n\n  }, {\n    key: \"cancelWants\",\n    value: function cancelWants(cids) {\n      this._log('cancel wants: %s', cids.length);\n\n      this._addEntries(cids, true);\n    } // Returns a list of all currently connected peers\n\n  }, {\n    key: \"connectedPeers\",\n    value: function connectedPeers() {\n      return Array.from(this.peers.keys());\n    }\n  }, {\n    key: \"connected\",\n    value: function connected(peerId) {\n      this._startPeerHandler(peerId);\n    }\n  }, {\n    key: \"disconnected\",\n    value: function disconnected(peerId) {\n      this._stopPeerHandler(peerId);\n    }\n  }, {\n    key: \"start\",\n    value: function start(callback) {\n      var _this2 = this;\n\n      // resend entire wantlist every so often\n      this.timer = setInterval(function () {\n        _this2._log('resend full-wantlist');\n\n        var fullwantlist = new Message(true);\n\n        _this2.wantlist.forEach(function (entry) {\n          fullwantlist.addEntry(entry.cid, entry.priority);\n        });\n\n        _this2.peers.forEach(function (p) {\n          return p.addMessage(fullwantlist);\n        });\n      }, 60 * 1000);\n      nextTick(function () {\n        return callback();\n      });\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      var _this3 = this;\n\n      this.peers.forEach(function (mq) {\n        return _this3.disconnected(mq.peerId);\n      });\n      clearInterval(this.timer);\n      nextTick(function () {\n        return callback();\n      });\n    }\n  }]);\n\n  return WantManager;\n}();","map":null,"metadata":{},"sourceType":"script"}