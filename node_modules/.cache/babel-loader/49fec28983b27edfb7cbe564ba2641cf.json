{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar protons = require('protons');\n\nvar Block = require('ipfs-block');\n\nvar isEqualWith = require('lodash.isequalwith');\n\nvar assert = require('assert');\n\nvar each = require('async/each');\n\nvar nextTick = require('async/nextTick');\n\nvar CID = require('cids');\n\nvar codecName = require('multicodec/src/name-table');\n\nvar vd = require('varint-decoder');\n\nvar multihashing = require('multihashing-async');\n\nvar pbm = protons(require('./message.proto'));\n\nvar Entry = require('./entry');\n\nvar BitswapMessage =\n/*#__PURE__*/\nfunction () {\n  function BitswapMessage(full) {\n    _classCallCheck(this, BitswapMessage);\n\n    this.full = full;\n    this.wantlist = new Map();\n    this.blocks = new Map();\n  }\n\n  _createClass(BitswapMessage, [{\n    key: \"addEntry\",\n    value: function addEntry(cid, priority, cancel) {\n      assert(cid && CID.isCID(cid), 'must be a valid cid');\n      var cidStr = cid.buffer.toString();\n      var entry = this.wantlist.get(cidStr);\n\n      if (entry) {\n        entry.priority = priority;\n        entry.cancel = Boolean(cancel);\n      } else {\n        this.wantlist.set(cidStr, new Entry(cid, priority, cancel));\n      }\n    }\n  }, {\n    key: \"addBlock\",\n    value: function addBlock(block) {\n      assert(Block.isBlock(block), 'must be a valid cid');\n      var cidStr = block.cid.buffer.toString();\n      this.blocks.set(cidStr, block);\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel(cid) {\n      assert(CID.isCID(cid), 'must be a valid cid');\n      var cidStr = cid.buffer.toString();\n      this.wantlist.delete(cidStr);\n      this.addEntry(cid, 0, true);\n    }\n    /*\n     * Serializes to Bitswap Message protobuf of\n     * version 1.0.0\n     */\n\n  }, {\n    key: \"serializeToBitswap100\",\n    value: function serializeToBitswap100() {\n      var msg = {\n        wantlist: {\n          entries: Array.from(this.wantlist.values()).map(function (entry) {\n            return {\n              block: entry.cid.buffer,\n              // cid\n              priority: Number(entry.priority),\n              cancel: Boolean(entry.cancel)\n            };\n          })\n        },\n        blocks: Array.from(this.blocks.values()).map(function (block) {\n          return block.data;\n        })\n      };\n\n      if (this.full) {\n        msg.wantlist.full = true;\n      }\n\n      return pbm.Message.encode(msg);\n    }\n    /*\n     * Serializes to Bitswap Message protobuf of\n     * version 1.1.0\n     */\n\n  }, {\n    key: \"serializeToBitswap110\",\n    value: function serializeToBitswap110() {\n      var msg = {\n        wantlist: {\n          entries: Array.from(this.wantlist.values()).map(function (entry) {\n            return {\n              block: entry.cid.buffer,\n              // cid\n              priority: Number(entry.priority),\n              cancel: Boolean(entry.cancel)\n            };\n          })\n        },\n        payload: []\n      };\n\n      if (this.full) {\n        msg.wantlist.full = true;\n      }\n\n      this.blocks.forEach(function (block) {\n        msg.payload.push({\n          prefix: block.cid.prefix,\n          data: block.data\n        });\n      });\n      return pbm.Message.encode(msg);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      var cmp = function cmp(a, b) {\n        if (a.equals && typeof a.equals === 'function') {\n          return a.equals(b);\n        }\n      };\n\n      if (this.full !== other.full || !isEqualWith(this.wantlist, other.wantlist, cmp) || !isEqualWith(this.blocks, other.blocks, cmp)) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"empty\",\n    get: function get() {\n      return this.blocks.size === 0 && this.wantlist.size === 0;\n    }\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      var list = Array.from(this.wantlist.keys());\n      var blocks = Array.from(this.blocks.keys());\n      return \"BitswapMessage <full: \".concat(this.full, \", list: \").concat(list, \", blocks: \").concat(blocks, \">\");\n    }\n  }]);\n\n  return BitswapMessage;\n}();\n\nBitswapMessage.deserialize = function (raw, callback) {\n  var decoded;\n\n  try {\n    decoded = pbm.Message.decode(raw);\n  } catch (err) {\n    return nextTick(function () {\n      return callback(err);\n    });\n  }\n\n  var isFull = decoded.wantlist && decoded.wantlist.full || false;\n  var msg = new BitswapMessage(isFull);\n\n  if (decoded.wantlist) {\n    decoded.wantlist.entries.forEach(function (entry) {\n      // note: entry.block is the CID here\n      var cid;\n\n      try {\n        cid = new CID(entry.block);\n      } catch (err) {\n        return callback(err);\n      }\n\n      msg.addEntry(cid, entry.priority, entry.cancel);\n    });\n  } // Bitswap 1.0.0\n  // decoded.blocks are just the byte arrays\n\n\n  if (decoded.blocks.length > 0) {\n    return each(decoded.blocks, function (b, cb) {\n      multihashing(b, 'sha2-256', function (err, hash) {\n        if (err) {\n          return cb(err);\n        }\n\n        var cid;\n\n        try {\n          cid = new CID(hash);\n        } catch (err) {\n          return callback(err);\n        }\n\n        msg.addBlock(new Block(b, cid));\n        cb();\n      });\n    }, function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, msg);\n    });\n  } // Bitswap 1.1.0\n\n\n  if (decoded.payload.length > 0) {\n    return each(decoded.payload, function (p, cb) {\n      if (!p.prefix || !p.data) {\n        return nextTick(cb);\n      }\n\n      var values = vd(p.prefix);\n      var cidVersion = values[0];\n      var multicodec = values[1];\n      var hashAlg = values[2]; // const hashLen = values[3] // We haven't need to use this so far\n\n      multihashing(p.data, hashAlg, function (err, hash) {\n        if (err) {\n          return cb(err);\n        }\n\n        var cid;\n\n        try {\n          cid = new CID(cidVersion, codecName[multicodec.toString('16')], hash);\n        } catch (err) {\n          return cb(err);\n        }\n\n        msg.addBlock(new Block(p.data, cid));\n        cb();\n      });\n    }, function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, msg);\n    });\n  }\n\n  callback(null, msg);\n};\n\nBitswapMessage.Entry = Entry;\nmodule.exports = BitswapMessage;","map":null,"metadata":{},"sourceType":"script"}