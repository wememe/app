{"ast":null,"code":"/* Copyright (c) 2017 Rod Vagg, MIT License */\nvar xtend = require('xtend');\n\nvar AbstractIterator = require('./abstract-iterator');\n\nvar AbstractChainedBatch = require('./abstract-chained-batch');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar rangeOptions = 'start end gt gte lt lte'.split(' ');\n\nfunction AbstractLevelDOWN(location) {\n  if (!arguments.length || location === undefined) {\n    throw new Error('constructor requires at least a location argument');\n  }\n\n  if (typeof location !== 'string') {\n    throw new Error('constructor requires a location string argument');\n  }\n\n  this.location = location;\n  this.status = 'new';\n}\n\nAbstractLevelDOWN.prototype.open = function (options, callback) {\n  var self = this;\n  var oldStatus = this.status;\n\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  if (typeof callback !== 'function') {\n    throw new Error('open() requires a callback argument');\n  }\n\n  if (typeof options !== 'object') {\n    options = {};\n  }\n\n  options.createIfMissing = options.createIfMissing !== false;\n  options.errorIfExists = !!options.errorIfExists;\n  this.status = 'opening';\n\n  this._open(options, function (err) {\n    if (err) {\n      self.status = oldStatus;\n      return callback(err);\n    }\n\n    self.status = 'open';\n    callback();\n  });\n};\n\nAbstractLevelDOWN.prototype._open = function (options, callback) {\n  process.nextTick(callback);\n};\n\nAbstractLevelDOWN.prototype.close = function (callback) {\n  var self = this;\n  var oldStatus = this.status;\n\n  if (typeof callback !== 'function') {\n    throw new Error('close() requires a callback argument');\n  }\n\n  this.status = 'closing';\n\n  this._close(function (err) {\n    if (err) {\n      self.status = oldStatus;\n      return callback(err);\n    }\n\n    self.status = 'closed';\n    callback();\n  });\n};\n\nAbstractLevelDOWN.prototype._close = function (callback) {\n  process.nextTick(callback);\n};\n\nAbstractLevelDOWN.prototype.get = function (key, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  if (typeof callback !== 'function') {\n    throw new Error('get() requires a callback argument');\n  }\n\n  var err = this._checkKey(key, 'key');\n\n  if (err) return process.nextTick(callback, err);\n  key = this._serializeKey(key);\n\n  if (typeof options !== 'object') {\n    options = {};\n  }\n\n  options.asBuffer = options.asBuffer !== false;\n\n  this._get(key, options, callback);\n};\n\nAbstractLevelDOWN.prototype._get = function (key, options, callback) {\n  process.nextTick(function () {\n    callback(new Error('NotFound'));\n  });\n};\n\nAbstractLevelDOWN.prototype.put = function (key, value, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  if (typeof callback !== 'function') {\n    throw new Error('put() requires a callback argument');\n  }\n\n  var err = this._checkKey(key, 'key');\n\n  if (err) return process.nextTick(callback, err);\n  key = this._serializeKey(key);\n  value = this._serializeValue(value);\n\n  if (typeof options !== 'object') {\n    options = {};\n  }\n\n  this._put(key, value, options, callback);\n};\n\nAbstractLevelDOWN.prototype._put = function (key, value, options, callback) {\n  process.nextTick(callback);\n};\n\nAbstractLevelDOWN.prototype.del = function (key, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  if (typeof callback !== 'function') {\n    throw new Error('del() requires a callback argument');\n  }\n\n  var err = this._checkKey(key, 'key');\n\n  if (err) return process.nextTick(callback, err);\n  key = this._serializeKey(key);\n\n  if (typeof options !== 'object') {\n    options = {};\n  }\n\n  this._del(key, options, callback);\n};\n\nAbstractLevelDOWN.prototype._del = function (key, options, callback) {\n  process.nextTick(callback);\n};\n\nAbstractLevelDOWN.prototype.batch = function (array, options, callback) {\n  if (!arguments.length) {\n    return this._chainedBatch();\n  }\n\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  if (typeof array === 'function') {\n    callback = array;\n  }\n\n  if (typeof callback !== 'function') {\n    throw new Error('batch(array) requires a callback argument');\n  }\n\n  if (!Array.isArray(array)) {\n    return process.nextTick(callback, new Error('batch(array) requires an array argument'));\n  }\n\n  if (!options || typeof options !== 'object') {\n    options = {};\n  }\n\n  var serialized = new Array(array.length);\n\n  for (var i = 0; i < array.length; i++) {\n    if (typeof array[i] !== 'object' || array[i] === null) {\n      return process.nextTick(callback, new Error('batch(array) element must be an object and not `null`'));\n    }\n\n    var e = xtend(array[i]);\n\n    if (e.type !== 'put' && e.type !== 'del') {\n      return process.nextTick(callback, new Error(\"`type` must be 'put' or 'del'\"));\n    }\n\n    var err = this._checkKey(e.key, 'key');\n\n    if (err) return process.nextTick(callback, err);\n    e.key = this._serializeKey(e.key);\n\n    if (e.type === 'put') {\n      e.value = this._serializeValue(e.value);\n    }\n\n    serialized[i] = e;\n  }\n\n  this._batch(serialized, options, callback);\n};\n\nAbstractLevelDOWN.prototype._batch = function (array, options, callback) {\n  process.nextTick(callback);\n};\n\nAbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {\n  options = cleanRangeOptions(options);\n  options.reverse = !!options.reverse;\n  options.keys = options.keys !== false;\n  options.values = options.values !== false;\n  options.limit = 'limit' in options ? options.limit : -1;\n  options.keyAsBuffer = options.keyAsBuffer !== false;\n  options.valueAsBuffer = options.valueAsBuffer !== false;\n  return options;\n};\n\nfunction cleanRangeOptions(options) {\n  var result = {};\n\n  for (var k in options) {\n    if (!hasOwnProperty.call(options, k)) continue;\n    if (isRangeOption(k) && isEmptyRangeOption(options[k])) continue;\n    result[k] = options[k];\n  }\n\n  return result;\n}\n\nfunction isRangeOption(k) {\n  return rangeOptions.indexOf(k) !== -1;\n}\n\nfunction isEmptyRangeOption(v) {\n  return v === '' || v == null || isEmptyBuffer(v);\n}\n\nfunction isEmptyBuffer(v) {\n  return Buffer.isBuffer(v) && v.length === 0;\n}\n\nAbstractLevelDOWN.prototype.iterator = function (options) {\n  if (typeof options !== 'object') {\n    options = {};\n  }\n\n  options = this._setupIteratorOptions(options);\n  return this._iterator(options);\n};\n\nAbstractLevelDOWN.prototype._iterator = function (options) {\n  return new AbstractIterator(this);\n};\n\nAbstractLevelDOWN.prototype._chainedBatch = function () {\n  return new AbstractChainedBatch(this);\n};\n\nAbstractLevelDOWN.prototype._serializeKey = function (key) {\n  return Buffer.isBuffer(key) ? key : String(key);\n};\n\nAbstractLevelDOWN.prototype._serializeValue = function (value) {\n  if (value == null) return '';\n  return Buffer.isBuffer(value) || process.browser ? value : String(value);\n};\n\nAbstractLevelDOWN.prototype._checkKey = function (obj, type) {\n  if (obj === null || obj === undefined) {\n    return new Error(type + ' cannot be `null` or `undefined`');\n  }\n\n  if (Buffer.isBuffer(obj) && obj.length === 0) {\n    return new Error(type + ' cannot be an empty Buffer');\n  }\n\n  if (String(obj) === '') {\n    return new Error(type + ' cannot be an empty String');\n  }\n};\n\nmodule.exports = AbstractLevelDOWN;","map":null,"metadata":{},"sourceType":"script"}