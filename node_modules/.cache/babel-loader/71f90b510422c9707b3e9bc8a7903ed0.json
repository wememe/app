{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('peer-id'),\n    createFromPrivKey = _require.createFromPrivKey;\n\nvar series = require('async/series');\n\nvar Receptacle = require('receptacle');\n\nvar debug = require('debug');\n\nvar log = debug('jsipfs:ipns');\nlog.error = debug('jsipfs:ipns:error');\n\nvar IpnsPublisher = require('./publisher');\n\nvar IpnsRepublisher = require('./republisher');\n\nvar IpnsResolver = require('./resolver');\n\nvar path = require('./path');\n\nvar defaultRecordTtl = 60 * 1000;\n\nvar IPNS =\n/*#__PURE__*/\nfunction () {\n  function IPNS(routing, ipfs) {\n    _classCallCheck(this, IPNS);\n\n    this.publisher = new IpnsPublisher(routing, ipfs._repo);\n    this.republisher = new IpnsRepublisher(this.publisher, ipfs);\n    this.resolver = new IpnsResolver(routing, ipfs._repo);\n    this.cache = new Receptacle({\n      max: 1000\n    }); // Create an LRU cache with max 1000 items\n  } // Publish\n\n\n  _createClass(IPNS, [{\n    key: \"publish\",\n    value: function publish(privKey, value, lifetime, callback) {\n      var _this = this;\n\n      series([function (cb) {\n        return createFromPrivKey(privKey.bytes, cb);\n      }, function (cb) {\n        return _this.publisher.publishWithEOL(privKey, value, lifetime, cb);\n      }], function (err, results) {\n        if (err) {\n          log.error(err);\n          return callback(err);\n        }\n\n        log(\"IPNS value \".concat(value, \" was published correctly\")); // Add to cache\n\n        var id = results[0].toB58String();\n        var ttEol = parseFloat(lifetime);\n        var ttl = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;\n\n        _this.cache.set(id, value, {\n          ttl: ttl\n        });\n\n        log(\"IPNS value \".concat(value, \" was cached correctly\"));\n        callback(null, {\n          name: id,\n          value: value\n        });\n      });\n    } // Resolve\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(name, peerId, options, callback) {\n      // If recursive, we should not try to get the cached value\n      if (!options.nocache && !options.recursive) {\n        // Try to get the record from cache\n        var id = name.split('/')[2];\n        var result = this.cache.get(id);\n\n        if (result) {\n          return callback(null, {\n            path: result\n          });\n        }\n      }\n\n      this.resolver.resolve(name, peerId, options, function (err, result) {\n        if (err) {\n          log.error(err);\n          return callback(err);\n        }\n\n        log(\"IPNS record from \".concat(name, \" was resolved correctly\"));\n        callback(null, {\n          path: result\n        });\n      });\n    } // Initialize keyspace\n    // sets the ipns record for the given key to point to an empty directory\n\n  }, {\n    key: \"initializeKeyspace\",\n    value: function initializeKeyspace(privKey, value, callback) {\n      this.publisher.publish(privKey, value, callback);\n    }\n  }]);\n\n  return IPNS;\n}();\n\nexports = module.exports = IPNS;\nexports.path = path;","map":null,"metadata":{},"sourceType":"script"}