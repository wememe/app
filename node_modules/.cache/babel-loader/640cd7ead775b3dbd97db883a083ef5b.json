{"ast":null,"code":"'use strict';\n\nvar promisify = require('promisify-es6');\n\nvar CID = require('cids');\n\nvar pull = require('pull-stream');\n\nvar mapAsync = require('async/map');\n\nvar setImmediate = require('async/setImmediate');\n\nvar flattenDeep = require('lodash/flattenDeep');\n\nvar errCode = require('err-code');\n\nmodule.exports = function dag(self) {\n  return {\n    put: promisify(function (dagNode, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n\n      if (options.cid && (options.format || options.hashAlg)) {\n        return callback(new Error('Can\\'t put dag node. Please provide either `cid` OR `format` and `hashAlg` options.'));\n      } else if (options.format && !options.hashAlg || !options.format && options.hashAlg) {\n        return callback(new Error('Can\\'t put dag node. Please provide `format` AND `hashAlg` options.'));\n      }\n\n      var optionDefaults = {\n        format: 'dag-cbor',\n        hashAlg: 'sha2-256'\n      };\n      options = options.cid ? options : Object.assign({}, optionDefaults, options);\n\n      self._ipld.put(dagNode, options, function (err, cid) {\n        if (err) return callback(err);\n\n        if (options.preload !== false) {\n          self._preload(cid);\n        }\n\n        callback(null, cid);\n      });\n    }),\n    get: promisify(function (cid, path, options, callback) {\n      if (typeof path === 'function') {\n        callback = path;\n        path = undefined;\n      }\n\n      if (typeof options === 'function') {\n        callback = options; // Allow options in path position\n\n        if (typeof path !== 'string') {\n          options = path;\n          path = null;\n        } else {\n          options = {};\n        }\n      }\n\n      options = options || {};\n\n      if (typeof cid === 'string') {\n        var split = cid.split('/');\n\n        try {\n          cid = new CID(split[0]);\n        } catch (err) {\n          return setImmediate(function () {\n            return callback(errCode(err, 'ERR_INVALID_CID'));\n          });\n        }\n\n        split.shift();\n\n        if (split.length > 0) {\n          path = split.join('/');\n        } else {\n          path = '/';\n        }\n      } else if (Buffer.isBuffer(cid)) {\n        try {\n          cid = new CID(cid);\n        } catch (err) {\n          return setImmediate(function () {\n            return callback(errCode(err, 'ERR_INVALID_CID'));\n          });\n        }\n      }\n\n      if (options.preload !== false) {\n        self._preload(cid);\n      }\n\n      self._ipld.get(cid, path, options, callback);\n    }),\n    tree: promisify(function (cid, path, options, callback) {\n      if (typeof path === 'object') {\n        callback = options;\n        options = path;\n        path = undefined;\n      }\n\n      if (typeof path === 'function') {\n        callback = path;\n        path = undefined;\n      }\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n\n      if (typeof cid === 'string') {\n        var split = cid.split('/');\n\n        try {\n          cid = new CID(split[0]);\n        } catch (err) {\n          return setImmediate(function () {\n            return callback(errCode(err, 'ERR_INVALID_CID'));\n          });\n        }\n\n        split.shift();\n\n        if (split.length > 0) {\n          path = split.join('/');\n        } else {\n          path = undefined;\n        }\n      }\n\n      if (options.preload !== false) {\n        self._preload(cid);\n      }\n\n      pull(self._ipld.treeStream(cid, path, options), pull.collect(callback));\n    }),\n    // TODO - use IPLD selectors once they are implemented\n    _getRecursive: promisify(function (multihash, options, callback) {\n      // gets flat array of all DAGNodes in tree given by multihash\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      var cid;\n\n      try {\n        cid = new CID(multihash);\n      } catch (err) {\n        return setImmediate(function () {\n          return callback(errCode(err, 'ERR_INVALID_CID'));\n        });\n      }\n\n      self.dag.get(cid, '', options, function (err, res) {\n        if (err) {\n          return callback(err);\n        }\n\n        mapAsync(res.value.links, function (link, cb) {\n          self.dag._getRecursive(link.multihash, options, cb);\n        }, function (err, nodes) {\n          // console.log('nodes:', nodes)\n          if (err) return callback(err);\n          callback(null, flattenDeep([res.value, nodes]));\n        });\n      });\n    })\n  };\n};","map":null,"metadata":{},"sourceType":"script"}