{"ast":null,"code":"/* @flow */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar waterfall = require('async/waterfall');\n\nvar parallel = require('async/parallel');\n\nvar Key = require('interface-datastore').Key;\n\nvar sh = require('./shard');\n\nvar KeytransformStore = require('./keytransform');\n\nvar shardKey = new Key(sh.SHARDING_FN);\nvar shardReadmeKey = new Key(sh.README_FN);\n/* ::\nimport type {Datastore, Batch, Query, QueryResult, Callback} from 'interface-datastore'\n\nimport type {ShardV1} from './shard'\n*/\n\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\n\nvar ShardingDatastore =\n/*#__PURE__*/\nfunction () {\n  /* :: shard: ShardV1 */\n\n  /* :: child: Datastore<Buffer> */\n  function ShardingDatastore(store\n  /* : Datastore<Buffer> */\n  , shard\n  /* : ShardV1 */\n  ) {\n    _classCallCheck(this, ShardingDatastore);\n\n    this.child = new KeytransformStore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    });\n    this.shard = shard;\n  }\n\n  _createClass(ShardingDatastore, [{\n    key: \"open\",\n    value: function open(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.child.open(callback);\n    }\n  }, {\n    key: \"_convertKey\",\n    value: function _convertKey(key\n    /* : Key */\n    )\n    /* : Key */\n    {\n      var s = key.toString();\n\n      if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n        return key;\n      }\n\n      var parent = new Key(this.shard.fun(s));\n      return parent.child(key);\n    }\n  }, {\n    key: \"_invertKey\",\n    value: function _invertKey(key\n    /* : Key */\n    )\n    /* : Key */\n    {\n      var s = key.toString();\n\n      if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n        return key;\n      }\n\n      return Key.withNamespaces(key.list().slice(1));\n    }\n  }, {\n    key: \"put\",\n    value: function put(key\n    /* : Key */\n    , val\n    /* : Buffer */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.child.put(key, val, callback);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key\n    /* : Key */\n    , callback\n    /* : Callback<Buffer> */\n    )\n    /* : void */\n    {\n      this.child.get(key, callback);\n    }\n  }, {\n    key: \"has\",\n    value: function has(key\n    /* : Key */\n    , callback\n    /* : Callback<bool> */\n    )\n    /* : void */\n    {\n      this.child.has(key, callback);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key\n    /* : Key */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.child.delete(key, callback);\n    }\n  }, {\n    key: \"batch\",\n    value: function batch()\n    /* : Batch<Buffer> */\n    {\n      return this.child.batch();\n    }\n  }, {\n    key: \"query\",\n    value: function query(q\n    /* : Query<Buffer> */\n    )\n    /* : QueryResult<Buffer> */\n    {\n      var _this = this;\n\n      var tq\n      /* : Query<Buffer> */\n      = {\n        keysOnly: q.keysOnly,\n        offset: q.offset,\n        limit: q.limit,\n        filters: [function (e, cb) {\n          return cb(null, e.key.toString() !== shardKey.toString());\n        }, function (e, cb) {\n          return cb(null, e.key.toString() !== shardReadmeKey.toString());\n        }]\n      };\n\n      if (q.prefix != null) {\n        tq.filters.push(function (e, cb) {\n          cb(null, _this._invertKey(e.key).toString().startsWith(q.prefix));\n        });\n      }\n\n      if (q.filters != null) {\n        var filters = q.filters.map(function (f) {\n          return function (e, cb) {\n            f(Object.assign({}, e, {\n              key: _this._invertKey(e.key)\n            }), cb);\n          };\n        });\n        tq.filters = tq.filters.concat(filters);\n      }\n\n      if (q.orders != null) {\n        tq.orders = q.orders.map(function (o) {\n          return function (res, cb) {\n            res.forEach(function (e) {\n              e.key = _this._invertKey(e.key);\n            });\n            o(res, function (err, ordered) {\n              if (err) {\n                return cb(err);\n              }\n\n              ordered.forEach(function (e) {\n                e.key = _this._convertKey(e.key);\n              });\n              cb(null, ordered);\n            });\n          };\n        });\n      }\n\n      return this.child.query(tq);\n    }\n  }, {\n    key: \"close\",\n    value: function close(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.child.close(callback);\n    }\n  }], [{\n    key: \"createOrOpen\",\n    value: function createOrOpen(store\n    /* : Datastore<Buffer> */\n    , shard\n    /* : ShardV1 */\n    , callback\n    /* : Callback<ShardingDatastore> */\n    )\n    /* : void */\n    {\n      ShardingDatastore.create(store, shard, function (err) {\n        if (err && err.message !== 'datastore exists') {\n          return callback(err);\n        }\n\n        ShardingDatastore.open(store, callback);\n      });\n    }\n  }, {\n    key: \"open\",\n    value: function open(store\n    /* : Datastore<Buffer> */\n    , callback\n    /* : Callback<ShardingDatastore> */\n    )\n    /* : void */\n    {\n      waterfall([function (cb) {\n        return sh.readShardFun('/', store, cb);\n      }, function (shard, cb) {\n        cb(null, new ShardingDatastore(store, shard));\n      }], callback);\n    }\n  }, {\n    key: \"create\",\n    value: function create(store\n    /* : Datastore<Buffer> */\n    , shard\n    /* : ShardV1 */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      store.has(shardKey, function (err, exists) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!exists) {\n          var put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store);\n          return parallel([function (cb) {\n            return put(shardKey, Buffer.from(shard.toString() + '\\n'), cb);\n          }, function (cb) {\n            return put(shardReadmeKey, Buffer.from(sh.readme), cb);\n          }], function (err) {\n            return callback(err);\n          });\n        }\n\n        sh.readShardFun('/', store, function (err, diskShard) {\n          if (err) {\n            return callback(err);\n          }\n\n          var a = (diskShard || '').toString();\n          var b = shard.toString();\n\n          if (a !== b) {\n            return callback(new Error(\"specified fun \".concat(b, \" does not match repo shard fun \").concat(a)));\n          }\n\n          callback(new Error('datastore exists'));\n        });\n      });\n    }\n  }]);\n\n  return ShardingDatastore;\n}();\n\nmodule.exports = ShardingDatastore;","map":null,"metadata":{},"sourceType":"script"}