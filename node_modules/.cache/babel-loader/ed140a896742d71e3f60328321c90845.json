{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar EE = require('events').EventEmitter;\n\nvar each = require('async/each');\n\nvar series = require('async/series');\n\nvar TransportManager = require('./transport');\n\nvar ConnectionManager = require('./connection');\n\nvar getPeerInfo = require('./get-peer-info');\n\nvar dial = require('./dial');\n\nvar ProtocolMuxer = require('./protocol-muxer');\n\nvar plaintext = require('./plaintext');\n\nvar Observer = require('./observer');\n\nvar Stats = require('./stats');\n\nvar assert = require('assert');\n\nvar Errors = require('./errors');\n\nvar Switch =\n/*#__PURE__*/\nfunction (_EE) {\n  _inherits(Switch, _EE);\n\n  function Switch(peerInfo, peerBook, options) {\n    var _this;\n\n    _classCallCheck(this, Switch);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Switch).call(this));\n    assert(peerInfo, 'You must provide a `peerInfo`');\n    assert(peerBook, 'You must provide a `peerBook`');\n    _this._peerInfo = peerInfo;\n    _this._peerBook = peerBook;\n    _this._options = options || {};\n\n    _this.setMaxListeners(Infinity); // transports --\n    // { key: transport }; e.g { tcp: <tcp> }\n\n\n    _this.transports = {}; // connections --\n    // { peerIdB58: { conn: <conn> }}\n\n    _this.conns = {}; // {\n    //   peerIdB58: {\n    //     muxer: <muxer>\n    //     conn: <transport socket> // to extract info required for the Identify Protocol\n    //   }\n    // }\n\n    _this.muxedConns = {}; // { protocol: handler }\n\n    _this.protocols = {}; // { muxerCodec: <muxer> } e.g { '/spdy/0.3.1': spdy }\n\n    _this.muxers = {}; // is the Identify protocol enabled?\n\n    _this.identify = false; // Crypto details\n\n    _this.crypto = plaintext;\n    _this.protector = _this._options.protector || null;\n    _this.transport = new TransportManager(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.connection = new ConnectionManager(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.observer = Observer(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.stats = Stats(_this.observer, _this._options.stats);\n    _this.protocolMuxer = ProtocolMuxer(_this.protocols, _this.observer);\n\n    _this.handle(_this.crypto.tag, function (protocol, conn) {\n      var peerId = _this._peerInfo.id;\n\n      var wrapped = _this.crypto.encrypt(peerId, conn, undefined, function () {});\n\n      return _this.protocolMuxer(null)(wrapped);\n    }); // higher level (public) API\n\n\n    _this.dial = dial(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n  /**\n   * Returns a list of the transports peerInfo has addresses for\n   *\n   * @param {PeerInfo} peerInfo\n   * @returns {Array<Transport>}\n   */\n\n\n  _createClass(Switch, [{\n    key: \"availableTransports\",\n    value: function availableTransports(peerInfo) {\n      var _this2 = this;\n\n      var myAddrs = peerInfo.multiaddrs.toArray();\n      var myTransports = Object.keys(this.transports); // Only listen on transports we actually have addresses for\n\n      return myTransports.filter(function (ts) {\n        return _this2.transports[ts].filter(myAddrs).length > 0;\n      }) // push Circuit to be the last proto to be dialed\n      .sort(function (a) {\n        return a === 'Circuit' ? 1 : 0;\n      });\n    }\n    /**\n     * Starts the Switch listening on all available Transports\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(callback) {\n      var _this3 = this;\n\n      each(this.availableTransports(this._peerInfo), function (ts, cb) {\n        // Listen on the given transport\n        _this3.transport.listen(ts, {}, null, cb);\n      }, callback);\n    }\n    /**\n     * Stops all services and connections for the Switch\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      var _this4 = this;\n\n      this.stats.stop();\n      series([function (cb) {\n        return each(_this4.muxedConns, function (conn, cb) {\n          // If the connection was destroyed while we are hanging up, continue\n          if (!conn) {\n            return cb();\n          }\n\n          conn.muxer.end(function (err) {\n            // If OK things are fine, and someone just shut down\n            if (err && err.message !== 'Fatal error: OK') {\n              return cb(err);\n            }\n\n            cb();\n          });\n        }, cb);\n      }, function (cb) {\n        each(_this4.transports, function (transport, cb) {\n          each(transport.listeners, function (listener, cb) {\n            listener.close(cb);\n          }, cb);\n        }, cb);\n      }], callback);\n    }\n    /**\n     * Adds the `handlerFunc` and `matchFunc` to the Switch's protocol\n     * handler list for the given `protocol`. If the `matchFunc` returns\n     * true for a protocol check, the `handlerFunc` will be called.\n     *\n     * @param {string} protocol\n     * @param {function(string, Connection)} handlerFunc\n     * @param {function(string, string, function(Error, boolean))} matchFunc\n     * @returns {void}\n     */\n\n  }, {\n    key: \"handle\",\n    value: function handle(protocol, handlerFunc, matchFunc) {\n      this.protocols[protocol] = {\n        handlerFunc: handlerFunc,\n        matchFunc: matchFunc\n      };\n    }\n    /**\n     * Removes the given protocol from the Switch's protocol list\n     *\n     * @param {string} protocol\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unhandle\",\n    value: function unhandle(protocol) {\n      if (this.protocols[protocol]) {\n        delete this.protocols[protocol];\n      }\n    }\n    /**\n     * If a muxed Connection exists for the given peer, it will be closed\n     * and its reference on the Switch will be removed.\n     *\n     * @param {PeerInfo|Multiaddr|PeerId} peer\n     * @param {function()} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"hangUp\",\n    value: function hangUp(peer, callback) {\n      var _this5 = this;\n\n      var peerInfo = getPeerInfo(peer, this.peerBook);\n      var key = peerInfo.id.toB58String();\n\n      if (this.muxedConns[key]) {\n        var muxer = this.muxedConns[key].muxer;\n        muxer.once('close', function () {\n          delete _this5.muxedConns[key];\n          callback();\n        });\n        muxer.end();\n      } else {\n        callback();\n      }\n    }\n    /**\n     * Returns whether or not the switch has any transports\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"hasTransports\",\n    value: function hasTransports() {\n      var transports = Object.keys(this.transports).filter(function (t) {\n        return t !== 'Circuit';\n      });\n      return transports && transports.length > 0;\n    }\n  }]);\n\n  return Switch;\n}(EE);\n\nmodule.exports = Switch;\nmodule.exports.errors = Errors;","map":null,"metadata":{},"sourceType":"script"}