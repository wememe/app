{"ast":null,"code":"function each(obj, iter) {\n  for (var key in obj) {\n    var value = obj[key];\n    iter(value, key, obj);\n  }\n}\n\nfunction keys(obj) {\n  return Object.keys(obj).sort();\n}\n\nfunction contains(a, v) {\n  return ~a.indexOf(v);\n}\n\nfunction union(a, b) {\n  return a.filter(function (v) {\n    return contains(b, v);\n  });\n}\n\nfunction disunion1(a, b) {\n  return a.filter(function (v) {\n    return !contains(b, v);\n  });\n}\n\nfunction disunion(a, b) {\n  return a.filter(function (v) {\n    return !contains(b, v);\n  }).concat(b.filter(function (v) {\n    return !contains(a, v);\n  })).sort();\n}\n\nfunction equal(a, b) {\n  if (a.length != b.length) return false;\n\n  for (var i in a) {\n    if (b[i] !== a[i]) return false;\n  }\n}\n\nfunction empty(v) {\n  for (var k in v) {\n    return false;\n  }\n\n  return true;\n} //check that all transitions are to valid states.\n\n\nvar validate = exports.validate = function (fsm) {\n  var states = Object.keys(fsm);\n  each(fsm, function (state, name) {\n    each(state, function (_state, event) {\n      if (!fsm[_state]) throw new Error('invalid transition from state:' + name + ' to state:' + _state + ' on event:' + event);\n    });\n  });\n  return true;\n}; //get a list of all states that are reachable from any given state.\n//(with the shortest paths?)\n// returns object: {STATES: {REACHABLE_STATE: path}}\n\n\nvar reachable = exports.reachable = function (fsm) {\n  var reachable = {};\n  var added = false;\n\n  do {\n    added = false;\n    each(fsm, function (state, name) {\n      var reach = reachable[name] = reachable[name] || {}; //add any state that can be reached directly.\n\n      each(state, function (_name, event) {\n        if (!reach[_name]) reach[_name] = [event], added = true;\n      }); //add any state that can be reached from a state you can reach directly.\n\n      each(state, function (_name, event) {\n        var _state = reachable[_name];\n        each(_state, function (path, _name) {\n          if (!reach[_name]) reach[_name] = [event].concat(path), added = true;\n        });\n      });\n    });\n  } while (added);\n\n  return reachable;\n}; // deadlock: are there any dead ends that cannot reach another state?\n\n\nexports.terminal = exports.deadlock = function (fsm) {\n  var dead = [];\n  each(fsm, function (state, name) {\n    if (empty(state)) dead.push(name);\n  });\n  return dead;\n}; // livelock; are there any cycles that cannot reach a terminal state?\n// return any states that cannot reach the given terminal states,\n// unless they are themselves terminal states.\n\n\nvar livelock = exports.livelock = function (fsm, terminals) {\n  var reach = reachable(fsm),\n      locked = [];\n  each(reach, function (reaches, name) {\n    if (contains(terminals, name)) return;\n    each(terminals, function (_name) {\n      if (!reaches[_name] && !contains(locked, name)) locked.push(name);\n    });\n  });\n  return locked.sort();\n};\n\nfunction events(fsm) {\n  var events = [];\n  each(fsm, function (state, name) {\n    each(state, function (_state, event) {\n      if (!contains(events, event)) events.push(event);\n    });\n  });\n  return events.sort();\n}\n\nvar combine = exports.combine = function (fsm1, fsm2, start1, start2) {\n  var combined = {};\n  var events1 = events(fsm1);\n  var events2 = events(fsm2);\n  var independent = disunion(events1, events2);\n\n  function expand(name1, name2) {\n    var cName = name1 + '-' + name2,\n        state;\n    if (!combined[cName]) combined[cName] = {};\n    state = combined[cName]; //Q: what are the events which are allowed to occur from this state?\n    //A: independent events (used in only one fsm) or events that occur in both fsms in current state.\n\n    var trans1 = keys(fsm1[name1]),\n        trans2 = keys(fsm2[name2]);\n    var allowed = union(trans1, trans2); //expand to a new state\n\n    allowed.forEach(function (event) {\n      state[event] = fsm1[name1][event] + '-' + fsm2[name2][event];\n      if (!combined[state[event]]) expand(fsm1[name1][event], fsm2[name2][event]);\n    }); //only transition fsm1\n\n    union(independent, trans1).forEach(function (event) {\n      state[event] = fsm1[name1][event] + '-' + name2;\n      if (!combined[state[event]]) expand(fsm1[name1][event], name2);\n    });\n    union(independent, trans2).forEach(function (event) {\n      state[event] = name1 + '-' + fsm2[name2][event];\n      if (!combined[state[event]]) expand(name1, fsm2[name2][event]);\n    });\n    return combined[cName];\n  }\n\n  expand(start1, start2);\n  return combined;\n};","map":null,"metadata":{},"sourceType":"script"}