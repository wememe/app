{"ast":null,"code":"'use strict';\n\nvar protons = require('protons');\n\nvar PeerId = require('peer-id');\n\nvar crypto = require('libp2p-crypto');\n\nvar parallel = require('async/parallel');\n\nvar waterfall = require('async/waterfall');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:secio');\nlog.error = debug('libp2p:secio:error');\nvar pbm = protons(require('./secio.proto'));\n\nvar support = require('../support'); // nonceSize is the size of our nonces (in bytes)\n\n\nvar nonceSize = 16;\n\nexports.createProposal = function (state) {\n  state.proposal.out = {\n    rand: crypto.randomBytes(nonceSize),\n    pubkey: state.key.local.public.bytes,\n    exchanges: support.exchanges.join(','),\n    ciphers: support.ciphers.join(','),\n    hashes: support.hashes.join(',')\n  };\n  state.proposalEncoded.out = pbm.Propose.encode(state.proposal.out);\n  return state.proposalEncoded.out;\n};\n\nexports.createExchange = function (state, callback) {\n  crypto.keys.generateEphemeralKeyPair(state.protocols.local.curveT, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n\n    state.ephemeralKey.local = res.key;\n    state.shared.generate = res.genSharedKey; // Gather corpus to sign.\n\n    var selectionOut = Buffer.concat([state.proposalEncoded.out, state.proposalEncoded.in, state.ephemeralKey.local]);\n    state.key.local.sign(selectionOut, function (err, sig) {\n      if (err) {\n        return callback(err);\n      }\n\n      state.exchange.out = {\n        epubkey: state.ephemeralKey.local,\n        signature: sig\n      };\n      callback(null, pbm.Exchange.encode(state.exchange.out));\n    });\n  });\n};\n\nexports.identify = function (state, msg, callback) {\n  log('1.1 identify');\n  state.proposalEncoded.in = msg;\n  state.proposal.in = pbm.Propose.decode(msg);\n  var pubkey = state.proposal.in.pubkey;\n  state.key.remote = crypto.keys.unmarshalPublicKey(pubkey);\n  PeerId.createFromPubKey(pubkey.toString('base64'), function (err, remoteId) {\n    if (err) {\n      return callback(err);\n    } // If we know who we are dialing to, double check\n\n\n    if (state.id.remote) {\n      if (state.id.remote.toB58String() !== remoteId.toB58String()) {\n        return callback(new Error('dialed to the wrong peer, Ids do not match'));\n      }\n    } else {\n      state.id.remote = remoteId;\n    }\n\n    log('1.1 identify - %s - identified remote peer as %s', state.id.local.toB58String(), state.id.remote.toB58String());\n    callback();\n  });\n};\n\nexports.selectProtocols = function (state, callback) {\n  log('1.2 selection');\n  var local = {\n    pubKeyBytes: state.key.local.public.bytes,\n    exchanges: support.exchanges,\n    hashes: support.hashes,\n    ciphers: support.ciphers,\n    nonce: state.proposal.out.rand\n  };\n  var remote = {\n    pubKeyBytes: state.proposal.in.pubkey,\n    exchanges: state.proposal.in.exchanges.split(','),\n    hashes: state.proposal.in.hashes.split(','),\n    ciphers: state.proposal.in.ciphers.split(','),\n    nonce: state.proposal.in.rand\n  };\n  support.selectBest(local, remote, function (err, selected) {\n    if (err) {\n      return callback(err);\n    } // we use the same params for both directions (must choose same curve)\n    // WARNING: if they dont SelectBest the same way, this won't work...\n\n\n    state.protocols.remote = {\n      order: selected.order,\n      curveT: selected.curveT,\n      cipherT: selected.cipherT,\n      hashT: selected.hashT\n    };\n    state.protocols.local = {\n      order: selected.order,\n      curveT: selected.curveT,\n      cipherT: selected.cipherT,\n      hashT: selected.hashT\n    };\n    callback();\n  });\n};\n\nexports.verify = function (state, msg, callback) {\n  log('2.1. verify');\n  state.exchange.in = pbm.Exchange.decode(msg);\n  state.ephemeralKey.remote = state.exchange.in.epubkey;\n  var selectionIn = Buffer.concat([state.proposalEncoded.in, state.proposalEncoded.out, state.ephemeralKey.remote]);\n  state.key.remote.verify(selectionIn, state.exchange.in.signature, function (err, sigOk) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (!sigOk) {\n      return callback(new Error('Bad signature'));\n    }\n\n    log('2.1. verify - signature verified');\n    callback();\n  });\n};\n\nexports.generateKeys = function (state, callback) {\n  log('2.2. keys');\n  waterfall([function (cb) {\n    return state.shared.generate(state.exchange.in.epubkey, cb);\n  }, function (secret, cb) {\n    state.shared.secret = secret;\n    crypto.keys.keyStretcher(state.protocols.local.cipherT, state.protocols.local.hashT, state.shared.secret, cb);\n  }, function (keys, cb) {\n    // use random nonces to decide order.\n    if (state.protocols.local.order > 0) {\n      state.protocols.local.keys = keys.k1;\n      state.protocols.remote.keys = keys.k2;\n    } else if (state.protocols.local.order < 0) {\n      // swap\n      state.protocols.local.keys = keys.k2;\n      state.protocols.remote.keys = keys.k1;\n    } else {\n      // we should've bailed before state. but if not, bail here.\n      return cb(new Error('you are trying to talk to yourself'));\n    }\n\n    log('2.3. mac + cipher');\n    parallel([function (_cb) {\n      return support.makeMacAndCipher(state.protocols.local, _cb);\n    }, function (_cb) {\n      return support.makeMacAndCipher(state.protocols.remote, _cb);\n    }], cb);\n  }], callback);\n};\n\nexports.verifyNonce = function (state, n2) {\n  var n1 = state.proposal.out.rand;\n  if (n1.equals(n2)) return;\n  throw new Error(\"Failed to read our encrypted nonce: \".concat(n1.toString('hex'), \" != \").concat(n2.toString('hex')));\n};","map":null,"metadata":{},"sourceType":"script"}