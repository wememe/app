{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar each = require('async/each');\n\nvar eachSeries = require('async/eachSeries');\n\nvar waterfall = require('async/waterfall');\n\nvar nextTick = require('async/nextTick');\n\nvar map = require('async/map');\n\nvar debounce = require('lodash.debounce');\n\nvar uniqWith = require('lodash.uniqwith');\n\nvar find = require('lodash.find');\n\nvar values = require('lodash.values');\n\nvar groupBy = require('lodash.groupby');\n\nvar pullAllWith = require('lodash.pullallwith');\n\nvar Message = require('../types/message');\n\nvar Wantlist = require('../types/wantlist');\n\nvar Ledger = require('./ledger');\n\nvar logger = require('../utils').logger;\n\nvar MAX_MESSAGE_SIZE = 512 * 1024;\n\nvar DecisionEngine =\n/*#__PURE__*/\nfunction () {\n  function DecisionEngine(peerId, blockstore, network, stats) {\n    _classCallCheck(this, DecisionEngine);\n\n    this._log = logger(peerId, 'engine');\n    this.blockstore = blockstore;\n    this.network = network;\n    this._stats = stats; // A list of of ledgers by their partner id\n\n    this.ledgerMap = new Map();\n    this._running = false; // List of tasks to be processed\n\n    this._tasks = [];\n    this._outbox = debounce(this._processTasks.bind(this), 100);\n  }\n\n  _createClass(DecisionEngine, [{\n    key: \"_sendBlocks\",\n    value: function _sendBlocks(peer, blocks, cb) {\n      var _this = this;\n\n      // split into messges of max 512 * 1024 bytes\n      var total = blocks.reduce(function (acc, b) {\n        return acc + b.data.byteLength;\n      }, 0);\n\n      if (total < MAX_MESSAGE_SIZE) {\n        return this._sendSafeBlocks(peer, blocks, cb);\n      }\n\n      var size = 0;\n      var batch = [];\n      var outstanding = blocks.length;\n      eachSeries(blocks, function (b, cb) {\n        outstanding--;\n        batch.push(b);\n        size += b.data.byteLength;\n\n        if (size >= MAX_MESSAGE_SIZE || // need to ensure the last remaining items get sent\n        outstanding === 0) {\n          size = 0;\n          var nextBatch = batch.slice();\n          batch = [];\n\n          _this._sendSafeBlocks(peer, nextBatch, function (err) {\n            if (err) {\n              _this._log('sendblock error: %s', err.message);\n            } // not returning the error, so we send as much as we can\n            // as otherwise `eachSeries` would cancel\n\n\n            cb();\n          });\n        } else {\n          nextTick(cb);\n        }\n      }, cb);\n    }\n  }, {\n    key: \"_sendSafeBlocks\",\n    value: function _sendSafeBlocks(peer, blocks, cb) {\n      var msg = new Message(false);\n      blocks.forEach(function (b) {\n        return msg.addBlock(b);\n      });\n      this.network.sendMessage(peer, msg, cb);\n    }\n  }, {\n    key: \"_processTasks\",\n    value: function _processTasks() {\n      var _this2 = this;\n\n      if (!this._running || !this._tasks.length) {\n        return;\n      }\n\n      var tasks = this._tasks;\n      this._tasks = [];\n      var entries = tasks.map(function (t) {\n        return t.entry;\n      });\n      var cids = entries.map(function (e) {\n        return e.cid;\n      });\n      var uniqCids = uniqWith(cids, function (a, b) {\n        return a.equals(b);\n      });\n      var groupedTasks = groupBy(tasks, function (task) {\n        return task.target.toB58String();\n      });\n      waterfall([function (callback) {\n        return map(uniqCids, function (cid, cb) {\n          _this2.blockstore.get(cid, cb);\n        }, callback);\n      }, function (blocks, callback) {\n        return each(values(groupedTasks), function (tasks, cb) {\n          // all tasks have the same target\n          var peer = tasks[0].target;\n          var blockList = cids.map(function (cid) {\n            return find(blocks, function (b) {\n              return b.cid.equals(cid);\n            });\n          });\n\n          _this2._sendBlocks(peer, blockList, function (err) {\n            if (err) {\n              // `_sendBlocks` actually doesn't return any errors\n              _this2._log.error('should never happen: ', err);\n            } else {\n              blockList.forEach(function (block) {\n                return _this2.messageSent(peer, block);\n              });\n            }\n\n            cb();\n          });\n        }, callback);\n      }], function (err) {\n        _this2._tasks = [];\n\n        if (err) {\n          _this2._log.error(err);\n        }\n      });\n    }\n  }, {\n    key: \"wantlistForPeer\",\n    value: function wantlistForPeer(peerId) {\n      var peerIdStr = peerId.toB58String();\n\n      if (!this.ledgerMap.has(peerIdStr)) {\n        return new Map();\n      }\n\n      return this.ledgerMap.get(peerIdStr).wantlist.sortedEntries();\n    }\n  }, {\n    key: \"ledgerForPeer\",\n    value: function ledgerForPeer(peerId) {\n      var peerIdStr = peerId.toB58String();\n      var ledger = this.ledgerMap.get(peerIdStr);\n\n      if (!ledger) {\n        return null;\n      }\n\n      return {\n        peer: ledger.partner.toPrint(),\n        value: ledger.debtRatio(),\n        sent: ledger.accounting.bytesSent,\n        recv: ledger.accounting.bytesRecv,\n        exchanged: ledger.exchangeCount\n      };\n    }\n  }, {\n    key: \"peers\",\n    value: function peers() {\n      return Array.from(this.ledgerMap.values()).map(function (l) {\n        return l.partner;\n      });\n    }\n  }, {\n    key: \"receivedBlocks\",\n    value: function receivedBlocks(cids) {\n      var _this3 = this;\n\n      if (!cids.length) {\n        return;\n      } // Check all connected peers if they want the block we received\n\n\n      this.ledgerMap.forEach(function (ledger) {\n        cids.map(function (cid) {\n          return ledger.wantlistContains(cid);\n        }).filter(Boolean).forEach(function (entry) {\n          _this3._tasks.push({\n            entry: entry,\n            target: ledger.partner\n          });\n        });\n      });\n\n      this._outbox();\n    } // Handle incoming messages\n\n  }, {\n    key: \"messageReceived\",\n    value: function messageReceived(peerId, msg, cb) {\n      var ledger = this._findOrCreate(peerId);\n\n      if (msg.empty) {\n        return nextTick(cb);\n      } // If the message was a full wantlist clear the current one\n\n\n      if (msg.full) {\n        ledger.wantlist = new Wantlist();\n      }\n\n      this._processBlocks(msg.blocks, ledger);\n\n      if (msg.wantlist.size === 0) {\n        return nextTick(cb);\n      }\n\n      var cancels = [];\n      var wants = [];\n      msg.wantlist.forEach(function (entry) {\n        if (entry.cancel) {\n          ledger.cancelWant(entry.cid);\n          cancels.push(entry);\n        } else {\n          ledger.wants(entry.cid, entry.priority);\n          wants.push(entry);\n        }\n      });\n\n      this._cancelWants(ledger, peerId, cancels);\n\n      this._addWants(ledger, peerId, wants, cb);\n    }\n  }, {\n    key: \"_cancelWants\",\n    value: function _cancelWants(ledger, peerId, entries) {\n      var id = peerId.toB58String();\n      pullAllWith(this._tasks, entries, function (t, e) {\n        var sameTarget = t.target.toB58String() === id;\n        var sameCid = t.entry.cid.equals(e.cid);\n        return sameTarget && sameCid;\n      });\n    }\n  }, {\n    key: \"_addWants\",\n    value: function _addWants(ledger, peerId, entries, callback) {\n      var _this4 = this;\n\n      each(entries, function (entry, cb) {\n        // If we already have the block, serve it\n        _this4.blockstore.has(entry.cid, function (err, exists) {\n          if (err) {\n            _this4._log.error('failed existence check');\n          } else if (exists) {\n            _this4._tasks.push({\n              entry: entry.entry,\n              target: peerId\n            });\n          }\n\n          cb();\n        });\n      }, function () {\n        _this4._outbox();\n\n        callback();\n      });\n    }\n  }, {\n    key: \"_processBlocks\",\n    value: function _processBlocks(blocks, ledger, callback) {\n      var _this5 = this;\n\n      var cids = [];\n      blocks.forEach(function (b, cidStr) {\n        _this5._log('got block (%s bytes)', b.data.length);\n\n        ledger.receivedBytes(b.data.length);\n        cids.push(b.cid);\n      });\n      this.receivedBlocks(cids);\n    } // Clear up all accounting things after message was sent\n\n  }, {\n    key: \"messageSent\",\n    value: function messageSent(peerId, block) {\n      var ledger = this._findOrCreate(peerId);\n\n      ledger.sentBytes(block ? block.data.length : 0);\n\n      if (block && block.cid) {\n        ledger.wantlist.remove(block.cid);\n      }\n    }\n  }, {\n    key: \"numBytesSentTo\",\n    value: function numBytesSentTo(peerId) {\n      return this._findOrCreate(peerId).accounting.bytesSent;\n    }\n  }, {\n    key: \"numBytesReceivedFrom\",\n    value: function numBytesReceivedFrom(peerId) {\n      return this._findOrCreate(peerId).accounting.bytesRecv;\n    }\n  }, {\n    key: \"peerDisconnected\",\n    value: function peerDisconnected(peerId) {// if (this.ledgerMap.has(peerId.toB58String())) {\n      //   this.ledgerMap.delete(peerId.toB58String())\n      // }\n      //\n      // TODO: figure out how to remove all other references\n      // in the peer request queue\n    }\n  }, {\n    key: \"_findOrCreate\",\n    value: function _findOrCreate(peerId) {\n      var peerIdStr = peerId.toB58String();\n\n      if (this.ledgerMap.has(peerIdStr)) {\n        return this.ledgerMap.get(peerIdStr);\n      }\n\n      var l = new Ledger(peerId);\n      this.ledgerMap.set(peerIdStr, l);\n\n      if (this._stats) {\n        this._stats.push(peerIdStr, 'peerCount', 1);\n      }\n\n      return l;\n    }\n  }, {\n    key: \"start\",\n    value: function start(callback) {\n      this._running = true;\n      nextTick(function () {\n        return callback();\n      });\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      this._running = false;\n      nextTick(function () {\n        return callback();\n      });\n    }\n  }]);\n\n  return DecisionEngine;\n}();\n\nmodule.exports = DecisionEngine;","map":null,"metadata":{},"sourceType":"script"}