{"ast":null,"code":"'use strict';\n\nvar base32Encode = require('base32-encode');\n\nvar Big = require('big.js');\n\nvar NanoDate = require('nano-date').default;\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar crypto = require('libp2p-crypto');\n\nvar PeerId = require('peer-id');\n\nvar multihash = require('multihashes');\n\nvar debug = require('debug');\n\nvar log = debug('jsipns');\nlog.error = debug('jsipns:error');\n\nvar ipnsEntryProto = require('./pb/ipns.proto');\n\nvar _require2 = require('./utils'),\n    parseRFC3339 = _require2.parseRFC3339;\n\nvar ERRORS = require('./errors');\n\nvar ID_MULTIHASH_CODE = multihash.names.id;\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {string} lifetime lifetime of the record (in milliseconds).\n * @param {function(Error, entry)} [callback]\n * @return {Void}\n */\n\nvar create = function create(privateKey, value, seq, lifetime, callback) {\n  // Calculate eol with nanoseconds precision\n  var bnLifetime = new Big(lifetime);\n  var bnCurrentDate = new Big(new NanoDate());\n  var bnEol = bnCurrentDate.plus(bnLifetime).times('10e+6');\n  var nanoDateEol = new NanoDate(bnEol.toString()); // Validity in ISOString with nanoseconds precision and validity type EOL\n\n  var isoValidity = nanoDateEol.toISOStringFull();\n  var validityType = ipnsEntryProto.ValidityType.EOL;\n\n  _create(privateKey, value, seq, isoValidity, validityType, callback);\n};\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {string} expiration expiration time of the record (in nanoseconds).\n * @param {function(Error, entry)} [callback]\n * @return {Void}\n */\n\n\nvar createWithExpiration = function createWithExpiration(privateKey, value, seq, expiration, callback) {\n  var bnExpiration = new NanoDate(new Big(expiration).toString()).toISOStringFull();\n  var validityType = ipnsEntryProto.ValidityType.EOL;\n\n  _create(privateKey, value, seq, bnExpiration, validityType, callback);\n};\n\nvar _create = function _create(privateKey, value, seq, isoValidity, validityType, callback) {\n  sign(privateKey, value, validityType, isoValidity, function (error, signature) {\n    if (error) {\n      log.error('record signature creation failed');\n      return callback(Object.assign(new Error('record signature verification failed'), {\n        code: ERRORS.ERR_SIGNATURE_CREATION\n      }));\n    }\n\n    var entry = {\n      value: value,\n      signature: signature,\n      validityType: validityType,\n      validity: isoValidity,\n      sequence: seq\n    };\n    log(\"ipns entry for \".concat(value, \" created\"));\n    return callback(null, entry);\n  });\n};\n/**\n * Validates the given ipns entry against the given public key.\n *\n * @param {Object} publicKey public key for validating the record.\n * @param {Object} entry ipns entry record.\n * @param {function(Error)} [callback]\n * @return {Void}\n */\n\n\nvar _validate = function validate(publicKey, entry, callback) {\n  var value = entry.value,\n      validityType = entry.validityType,\n      validity = entry.validity;\n  var dataForSignature = ipnsEntryDataForSig(value, validityType, validity); // Validate Signature\n\n  publicKey.verify(dataForSignature, entry.signature, function (err, isValid) {\n    if (err || !isValid) {\n      log.error('record signature verification failed');\n      return callback(Object.assign(new Error('record signature verification failed'), {\n        code: ERRORS.ERR_SIGNATURE_VERIFICATION\n      }));\n    } // Validate according to the validity type\n\n\n    if (validityType === ipnsEntryProto.ValidityType.EOL) {\n      var validityDate;\n\n      try {\n        validityDate = parseRFC3339(validity.toString());\n      } catch (e) {\n        log.error('unrecognized validity format (not an rfc3339 format)');\n        return callback(Object.assign(new Error('unrecognized validity format (not an rfc3339 format)'), {\n          code: ERRORS.ERR_UNRECOGNIZED_FORMAT\n        }));\n      }\n\n      if (validityDate < Date.now()) {\n        log.error('record has expired');\n        return callback(Object.assign(new Error('record has expired'), {\n          code: ERRORS.ERR_IPNS_EXPIRED_RECORD\n        }));\n      }\n    } else if (validityType) {\n      log.error('unrecognized validity type');\n      return callback(Object.assign(new Error('unrecognized validity type'), {\n        code: ERRORS.ERR_UNRECOGNIZED_VALIDITY\n      }));\n    }\n\n    log(\"ipns entry for \".concat(value, \" is valid\"));\n    return callback(null, null);\n  });\n};\n/**\n * Embed the given public key in the given entry. While not strictly required,\n * some nodes (eg. DHT servers) may reject IPNS entries that don't embed their\n * public keys as they may not be able to validate them efficiently.\n * As a consequence of nodes needing to validade a record upon receipt, they need\n * the public key associated with it. For olde RSA keys, it is easier if we just\n * send this as part of the record itself. For newer ed25519 keys, the public key\n * can be embedded in the peerId.\n *\n * @param {Object} publicKey public key to embed.\n * @param {Object} entry ipns entry record.\n * @param {function(Error)} [callback]\n * @return {Void}\n */\n\n\nvar embedPublicKey = function embedPublicKey(publicKey, entry, callback) {\n  if (!publicKey || !publicKey.bytes || !entry) {\n    var error = 'one or more of the provided parameters are not defined';\n    log.error(error);\n    return callback(Object.assign(new Error(error), {\n      code: ERRORS.ERR_UNDEFINED_PARAMETER\n    }));\n  } // Create a peer id from the public key.\n\n\n  PeerId.createFromPubKey(publicKey.bytes, function (err, peerId) {\n    if (err) {\n      log.error(err);\n      return callback(Object.assign(new Error(err), {\n        code: ERRORS.ERR_PEER_ID_FROM_PUBLIC_KEY\n      }));\n    } // Try to extract the public key from the ID. If we can, no need to embed it\n\n\n    var extractedPublicKey;\n\n    try {\n      extractedPublicKey = extractPublicKeyFromId(peerId);\n    } catch (err) {\n      log.error(err);\n      return callback(Object.assign(new Error(err), {\n        code: ERRORS.ERR_PUBLIC_KEY_FROM_ID\n      }));\n    }\n\n    if (extractedPublicKey) {\n      return callback(null, null);\n    } // If we failed to extract the public key from the peer ID, embed it in the record.\n\n\n    try {\n      entry.pubKey = crypto.keys.marshalPublicKey(publicKey);\n    } catch (err) {\n      log.error(err);\n      return callback(err);\n    }\n\n    callback(null, entry);\n  });\n};\n/**\n * Extracts a public key matching `pid` from the ipns record.\n *\n * @param {Object} peerId peer identifier object.\n * @param {Object} entry ipns entry record.\n * @param {function(Error)} [callback]\n * @return {Void}\n */\n\n\nvar extractPublicKey = function extractPublicKey(peerId, entry, callback) {\n  if (!entry || !peerId) {\n    var error = 'one or more of the provided parameters are not defined';\n    log.error(error);\n    return callback(Object.assign(new Error(error), {\n      code: ERRORS.ERR_UNDEFINED_PARAMETER\n    }));\n  }\n\n  if (entry.pubKey) {\n    var pubKey;\n\n    try {\n      pubKey = crypto.keys.unmarshalPublicKey(entry.pubKey);\n    } catch (err) {\n      log.error(err);\n      return callback(err);\n    }\n\n    return callback(null, pubKey);\n  }\n\n  callback(null, peerId.pubKey);\n}; // rawStdEncoding with RFC4648\n\n\nvar rawStdEncoding = function rawStdEncoding(key) {\n  return base32Encode(key, 'RFC4648', {\n    padding: false\n  });\n};\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Buffer} key peer identifier object.\n * @returns {string}\n */\n\n\nvar getLocalKey = function getLocalKey(key) {\n  return new Key(\"/ipns/\".concat(rawStdEncoding(key)));\n};\n/**\n * Get key for sharing the record in the routing mechanism.\n * Format: ${base32(/ipns/<HASH>)}, ${base32(/pk/<HASH>)}\n *\n * @param {Buffer} pid peer identifier represented by the multihash of the public key as Buffer.\n * @returns {Object} containing the `nameKey` and the `ipnsKey`.\n */\n\n\nvar getIdKeys = function getIdKeys(pid) {\n  var pkBuffer = Buffer.from('/pk/');\n  var ipnsBuffer = Buffer.from('/ipns/');\n  return {\n    routingPubKey: new Key(Buffer.concat([pkBuffer, pid])),\n    // Added on https://github.com/ipfs/js-ipns/pull/8#issue-213857876 (pkKey will be deprecated in a future release)\n    pkKey: new Key(rawStdEncoding(Buffer.concat([pkBuffer, pid]))),\n    routingKey: new Key(Buffer.concat([ipnsBuffer, pid])),\n    // Added on https://github.com/ipfs/js-ipns/pull/6#issue-213631461 (ipnsKey will be deprecated in a future release)\n    ipnsKey: new Key(rawStdEncoding(Buffer.concat([ipnsBuffer, pid])))\n  };\n}; // Sign ipns record data\n\n\nvar sign = function sign(privateKey, value, validityType, validity, callback) {\n  var dataForSignature = ipnsEntryDataForSig(value, validityType, validity);\n  privateKey.sign(dataForSignature, function (err, signature) {\n    if (err) {\n      return callback(err);\n    }\n\n    return callback(null, signature);\n  });\n}; // Utility for getting the validity type code name of a validity\n\n\nvar getValidityType = function getValidityType(validityType) {\n  if (validityType.toString() === '0') {\n    return 'EOL';\n  } else {\n    var error = \"unrecognized validity type \".concat(validityType.toString());\n    log.error(error);\n    throw Object.assign(new Error(error), {\n      code: ERRORS.ERR_UNRECOGNIZED_VALIDITY\n    });\n  }\n}; // Utility for creating the record data for being signed\n\n\nvar ipnsEntryDataForSig = function ipnsEntryDataForSig(value, validityType, validity) {\n  var valueBuffer = Buffer.from(value);\n  var validityTypeBuffer = Buffer.from(getValidityType(validityType));\n  var validityBuffer = Buffer.from(validity);\n  return Buffer.concat([valueBuffer, validityBuffer, validityTypeBuffer]);\n}; // Utility for extracting the public key from a peer-id\n\n\nvar extractPublicKeyFromId = function extractPublicKeyFromId(peerId) {\n  var decodedId = multihash.decode(peerId.id);\n\n  if (decodedId.code !== ID_MULTIHASH_CODE) {\n    return null;\n  }\n\n  return crypto.keys.unmarshalPublicKey(decodedId.digest);\n};\n\nvar marshal = ipnsEntryProto.encode;\nvar unmarshal = ipnsEntryProto.decode;\nvar validator = {\n  validate: function validate(marshalledData, peerId, callback) {\n    var receivedEntry = unmarshal(marshalledData); // extract public key\n\n    extractPublicKey(peerId, receivedEntry, function (err, pubKey) {\n      if (err) {\n        return callback(err);\n      } // Record validation\n\n\n      _validate(pubKey, receivedEntry, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, true);\n      });\n    });\n  },\n  select: function select(dataA, dataB, callback) {\n    var entryA = unmarshal(dataA);\n    var entryB = unmarshal(dataB);\n    callback(null, entryA.sequence > entryB.sequence ? 0 : 1);\n  }\n};\nmodule.exports = {\n  // create ipns entry record\n  create: create,\n  // create ipns entry record specifying the expiration time\n  createWithExpiration: createWithExpiration,\n  // validate ipns entry record\n  validate: _validate,\n  // embed public key in the record\n  embedPublicKey: embedPublicKey,\n  // extract public key from the record\n  extractPublicKey: extractPublicKey,\n  // get key for storing the entry locally\n  getLocalKey: getLocalKey,\n  // get keys for routing\n  getIdKeys: getIdKeys,\n  // marshal\n  marshal: marshal,\n  // unmarshal\n  unmarshal: unmarshal,\n  // validator\n  validator: validator\n};","map":null,"metadata":{},"sourceType":"script"}