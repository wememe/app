{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:webrtc-star');\n\nvar multiaddr = require('multiaddr');\n\nvar mafmt = require('mafmt');\n\nvar withIs = require('class-is');\n\nvar io = require('socket.io-client');\n\nvar EE = require('events').EventEmitter;\n\nvar SimplePeer = require('simple-peer');\n\nvar PeerId = require('peer-id');\n\nvar PeerInfo = require('peer-info');\n\nvar Connection = require('interface-connection').Connection;\n\nvar toPull = require('stream-to-pull-stream');\n\nvar once = require('once');\n\nvar setImmediate = require('async/setImmediate');\n\nvar webrtcSupport = require('webrtcsupport');\n\nvar utils = require('./utils');\n\nvar cleanUrlSIO = utils.cleanUrlSIO;\nvar cleanMultiaddr = utils.cleanMultiaddr;\nvar noop = once(function () {});\nvar sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true\n};\n\nvar WebRTCStar =\n/*#__PURE__*/\nfunction () {\n  function WebRTCStar(options) {\n    _classCallCheck(this, WebRTCStar);\n\n    options = options || {};\n    this.maSelf = undefined;\n    this.sioOptions = {\n      transports: ['websocket'],\n      'force new connection': true\n    };\n\n    if (options.wrtc) {\n      this.wrtc = options.wrtc;\n    }\n\n    this.discovery = new EE();\n    this.discovery.tag = 'webRTCStar';\n\n    this.discovery.start = function (callback) {\n      setImmediate(callback);\n    };\n\n    this.discovery.stop = function (callback) {\n      setImmediate(callback);\n    };\n\n    this.listenersRefs = {};\n    this._peerDiscovered = this._peerDiscovered.bind(this);\n  }\n\n  _createClass(WebRTCStar, [{\n    key: \"dial\",\n    value: function dial(ma, options, callback) {\n      var _this = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      callback = callback ? once(callback) : noop;\n      var intentId = (~~(Math.random() * 1e9)).toString(36) + Date.now();\n      var sioClient = this.listenersRefs[Object.keys(this.listenersRefs)[0]].io;\n      var spOptions = {\n        initiator: true,\n        trickle: false // Use custom WebRTC implementation\n\n      };\n\n      if (this.wrtc) {\n        spOptions.wrtc = this.wrtc;\n      }\n\n      var channel;\n\n      try {\n        channel = new SimplePeer(spOptions);\n      } catch (err) {\n        log('Could not create connection:', err);\n        return callback(err);\n      }\n\n      var conn = new Connection(toPull.duplex(channel));\n      var connected = false;\n      channel.on('signal', function (signal) {\n        sioClient.emit('ss-handshake', {\n          intentId: intentId,\n          srcMultiaddr: _this.maSelf.toString(),\n          dstMultiaddr: ma.toString(),\n          signal: signal\n        });\n      });\n      channel.once('timeout', function () {\n        return callback(new Error('timeout'));\n      });\n      channel.once('error', function (err) {\n        if (!connected) {\n          callback(err);\n        }\n      }); // NOTE: aegir segfaults if we do .once on the socket.io event emitter and we\n      // are clueless as to why.\n\n      sioClient.on('ws-handshake', function (offer) {\n        if (offer.intentId === intentId && offer.err) {\n          return callback(new Error(offer.err));\n        }\n\n        if (offer.intentId !== intentId || !offer.answer) {\n          return;\n        }\n\n        channel.once('connect', function () {\n          connected = true;\n          conn.destroy = channel.destroy.bind(channel);\n          channel.once('close', function () {\n            return conn.destroy();\n          });\n\n          conn.getObservedAddrs = function (callback) {\n            return callback(null, [ma]);\n          };\n\n          callback(null, conn);\n        });\n        channel.signal(offer.signal);\n      });\n      return conn;\n    }\n  }, {\n    key: \"createListener\",\n    value: function createListener(options, handler) {\n      var _this2 = this;\n\n      if (typeof options === 'function') {\n        handler = options;\n        options = {};\n      }\n\n      var listener = new EE();\n\n      listener.listen = function (ma, callback) {\n        callback = callback ? once(callback) : noop;\n\n        if (!webrtcSupport.support && !_this2.wrtc) {\n          return setImmediate(function () {\n            return callback(new Error('no WebRTC support'));\n          });\n        }\n\n        _this2.maSelf = ma;\n        var sioUrl = cleanUrlSIO(ma);\n        log('Dialing to Signalling Server on: ' + sioUrl);\n        listener.io = io.connect(sioUrl, sioOptions);\n        listener.io.once('connect_error', callback);\n        listener.io.once('error', function (err) {\n          listener.emit('error', err);\n          listener.emit('close');\n        });\n        listener.io.on('ws-handshake', incommingDial);\n        listener.io.on('ws-peer', _this2._peerDiscovered);\n        listener.io.on('connect', function () {\n          listener.io.emit('ss-join', ma.toString());\n        });\n        listener.io.once('connect', function () {\n          listener.emit('listening');\n          callback();\n        });\n        var self = _this2;\n\n        function incommingDial(offer) {\n          if (offer.answer || offer.err) {\n            return;\n          }\n\n          var spOptions = {\n            trickle: false // Use custom WebRTC implementation\n\n          };\n\n          if (self.wrtc) {\n            spOptions.wrtc = self.wrtc;\n          }\n\n          var channel;\n\n          try {\n            channel = new SimplePeer(spOptions);\n          } catch (err) {\n            log('Could not create incoming connection:', err);\n            return callback(err);\n          }\n\n          var conn = new Connection(toPull.duplex(channel));\n          channel.once('connect', function () {\n            conn.getObservedAddrs = function (callback) {\n              return callback(null, [offer.srcMultiaddr]);\n            };\n\n            listener.emit('connection', conn);\n            handler(conn);\n          });\n          channel.once('signal', function (signal) {\n            offer.signal = signal;\n            offer.answer = true;\n            listener.io.emit('ss-handshake', offer);\n          });\n          channel.signal(offer.signal);\n        }\n      };\n\n      listener.close = function (callback) {\n        callback = callback ? once(callback) : noop;\n        listener.io.emit('ss-leave');\n        setImmediate(function () {\n          listener.emit('close');\n          callback();\n        });\n      };\n\n      listener.getAddrs = function (callback) {\n        setImmediate(function () {\n          return callback(null, [_this2.maSelf]);\n        });\n      };\n\n      this.listenersRefs[multiaddr.toString()] = listener;\n      return listener;\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(multiaddrs) {\n      if (!Array.isArray(multiaddrs)) {\n        multiaddrs = [multiaddrs];\n      }\n\n      return multiaddrs.filter(function (ma) {\n        if (ma.protoNames().indexOf('p2p-circuit') > -1) {\n          return false;\n        }\n\n        return mafmt.WebRTCStar.matches(ma);\n      });\n    }\n  }, {\n    key: \"_peerDiscovered\",\n    value: function _peerDiscovered(maStr) {\n      log('Peer Discovered:', maStr);\n      maStr = cleanMultiaddr(maStr);\n      var split = maStr.split('/ipfs/');\n      var peerIdStr = split[split.length - 1];\n      var peerId = PeerId.createFromB58String(peerIdStr);\n      var peerInfo = new PeerInfo(peerId);\n      peerInfo.multiaddrs.add(multiaddr(maStr));\n      this.discovery.emit('peer', peerInfo);\n    }\n  }]);\n\n  return WebRTCStar;\n}();\n\nmodule.exports = withIs(WebRTCStar, {\n  className: 'WebRTCStar',\n  symbolName: '@libp2p/js-libp2p-webrtc-star/webrtcstar'\n});","map":null,"metadata":{},"sourceType":"script"}