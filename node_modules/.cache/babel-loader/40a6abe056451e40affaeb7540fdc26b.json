{"ast":null,"code":"'use strict';\n\nvar peerId = require('peer-id');\n\nvar PeerInfo = require('peer-info');\n\nvar multiaddr = require('multiaddr');\n\nvar waterfall = require('async/waterfall');\n\nvar Keychain = require('libp2p-keychain');\n\nvar extend = require('deep-extend');\n\nvar NoKeychain = require('./no-keychain');\n/*\n * Load stuff from Repo into memory\n */\n\n\nmodule.exports = function preStart(self) {\n  return function (callback) {\n    self.log('pre-start');\n    var pass = self._options.pass;\n    waterfall([function (cb) {\n      return self._repo.config.get(cb);\n    }, function (config, cb) {\n      if (!self._options.config) {\n        return cb(null, config);\n      }\n\n      extend(config, self._options.config);\n      self.config.replace(config, function (err) {\n        if (err) {\n          return cb(err);\n        }\n\n        cb(null, config);\n      });\n    }, function (config, cb) {\n      // Create keychain configuration, if needed.\n      if (config.Keychain) {\n        return cb(null, config);\n      }\n\n      config.Keychain = Keychain.generateOptions();\n      self.config.set('Keychain', config.Keychain, function (err) {\n        self.log('using default keychain options');\n        cb(err, config);\n      });\n    }, function (config, cb) {\n      // Construct the keychain\n      if (self._keychain) {// most likely an init or upgrade has happened\n      } else if (pass) {\n        var keychainOptions = Object.assign({\n          passPhrase: pass\n        }, config.Keychain);\n        self._keychain = new Keychain(self._repo.keys, keychainOptions);\n        self.log('keychain constructed');\n      } else {\n        self._keychain = new NoKeychain();\n        self.log('no keychain, use --pass');\n      }\n\n      cb(null, config);\n    }, function (config, cb) {\n      var privKey = config.Identity.PrivKey;\n      peerId.createFromPrivKey(privKey, function (err, id) {\n        cb(err, config, id);\n      });\n    }, function (config, id, cb) {\n      // Import the private key as 'self', if needed.\n      if (!pass) {\n        return cb(null, config, id);\n      }\n\n      self._keychain.findKeyByName('self', function (err) {\n        if (err) {\n          self.log('Creating \"self\" key');\n          return self._keychain.importPeer('self', id, function (err) {\n            return cb(err, config, id);\n          });\n        }\n\n        cb(null, config, id);\n      });\n    }, function (config, id, cb) {\n      self.log('peer created');\n      self._peerInfo = new PeerInfo(id);\n\n      if (config.Addresses && config.Addresses.Swarm) {\n        config.Addresses.Swarm.forEach(function (addr) {\n          var ma = multiaddr(addr);\n\n          if (ma.getPeerId()) {\n            ma = ma.encapsulate('/ipfs/' + self._peerInfo.id.toB58String());\n          }\n\n          self._peerInfo.multiaddrs.add(ma);\n        });\n      }\n\n      cb();\n    }, function (cb) {\n      return self.pin._load(cb);\n    }], callback);\n  };\n};","map":null,"metadata":{},"sourceType":"script"}