{"ast":null,"code":"/*\nall pull streams have these states:\n\n{\n  START: {\n    read: READING,\n    abort: ABORTING\n  },\n  READY: {\n    read: READING,\n    abort: ABORTING\n  },\n  READING: {\n    cb: READY,\n    err: ERROR,\n    end: END\n  },\n  ABORTING: {\n    cb: END\n  },\n  ERROR: {},\n  END: {}\n}\n\nthis module takes a collection of pull-streams,\nand interleaves their states.\nif all the streams have ended, it ends.\nIf it is in reading state, and one stream goes has READING->cb\nit goes into READY\n\non read, trigger read on every stream in START or READY\n\non abort, trigger abort on all streams immediately***\n\nif a stream is in READY, and big stream is in ABORT,\ntrigger abort\n\nif every stream is in END or ERROR, trigger end or error\n\ncould you describe this declaritively or something?\n*/\nmodule.exports = function (ary) {\n  var capped = !!ary;\n  var inputs = (ary || []).map(create),\n      i = 0,\n      abort,\n      cb;\n\n  function create(stream) {\n    return {\n      ready: false,\n      reading: false,\n      ended: false,\n      read: stream,\n      data: null\n    };\n  }\n\n  function check() {\n    if (!cb) return;\n    clean();\n    var l = inputs.length;\n    var _cb = cb;\n\n    if (l === 0 && (abort || capped)) {\n      cb = null;\n\n      _cb(abort || true);\n\n      return;\n    } //scan the inputs to check whether there is one we can use.\n\n\n    for (var j = 0; j < l; j++) {\n      var current = inputs[(i + j) % l];\n\n      if (current.ready && !current.ended) {\n        var data = current.data;\n        current.ready = false;\n        current.data = null;\n        i++;\n        cb = null;\n        return _cb(null, data);\n      }\n    }\n  }\n\n  function clean() {\n    var l = inputs.length; //iterate backwards so that we can remove items.\n\n    while (l--) {\n      if (inputs[l].ended) inputs.splice(l, 1);\n    }\n  }\n\n  function next() {\n    var l = inputs.length;\n\n    while (l--) {\n      (function (current) {\n        //read the next item if we aren't already\n        if (l > inputs.length) throw new Error('this should never happen');\n        if (current.reading || current.ended || current.ready) return;\n        current.reading = true;\n        var sync = true;\n        current.read(abort, function next(end, data) {\n          current.data = data;\n          current.ready = true;\n          current.reading = false;\n          if (end === true || abort) current.ended = true;else if (end) abort = current.ended = end; //check whether we need to abort this stream.\n\n          if (abort && !end) current.read(abort, next);\n          if (!sync) check();\n        });\n        sync = false;\n      })(inputs[l]);\n    } //scan the feed\n\n\n    check();\n  }\n\n  function read(_abort, _cb) {\n    abort = abort || _abort;\n    cb = _cb;\n    next();\n  }\n\n  read.add = function (stream) {\n    if (!stream) {\n      //the stream will now end when all the streams end.\n      capped = true; //we just changed state, so we may need to cb\n\n      return next();\n    }\n\n    inputs.push(create(stream));\n    next();\n  };\n\n  read.cap = function (err) {\n    read.add(null);\n  };\n\n  return read;\n};","map":null,"metadata":{},"sourceType":"script"}