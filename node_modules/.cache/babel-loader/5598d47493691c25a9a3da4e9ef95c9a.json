{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar multistream = require('multistream-select');\n\nvar Connection = require('interface-connection').Connection;\n\nvar setImmediate = require('async/setImmediate');\n\nvar Circuit = require('libp2p-circuit');\n\nvar waterfall = require('async/waterfall');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:switch:dial');\n\nvar getPeerInfo = require('./get-peer-info');\n\nvar observeConnection = require('./observe-connection');\n\nvar UNEXPECTED_END = 'Unexpected end of input from reader.';\n/**\n * Uses the given MultistreamDialer to select the protocol matching the given key\n *\n * A helper method to catch errors from pull streams ending unexpectedly\n * Needed until https://github.com/dignifiedquire/pull-length-prefixed/pull/8 is merged.\n *\n * @param {MultistreamDialer} msDialer a multistream.Dialer\n * @param {string} key The key type to select\n * @param {function(Error)} callback Used for standard async flow\n * @param {function(Error)} abort A callback to be used for ending the connection outright\n * @returns {void}\n */\n\nfunction selectSafe(msDialer, key, callback, abort) {\n  msDialer.select(key, function (err, conn) {\n    if (err === true) {\n      return abort(new Error(UNEXPECTED_END));\n    }\n\n    callback(err, conn);\n  });\n}\n/**\n * Uses the given MultistreamDialer to handle the given connection\n *\n * A helper method to catch errors from pull streams ending unexpectedly\n * Needed until https://github.com/dignifiedquire/pull-length-prefixed/pull/8 is merged\n *\n * @param {MultistreamDialer} msDialer\n * @param {Connection} connection The connection to handle\n * @param {function(Error)} callback Used for standard async flow\n * @param {function(Error)} abort A callback to be used for ending the connection outright\n * @returns {void}\n */\n\n\nfunction handleSafe(msDialer, connection, callback, abort) {\n  msDialer.handle(connection, function (err) {\n    // Repackage errors from pull-streams ending unexpectedly.\n    // Needed until https://github.com/dignifiedquire/pull-length-prefixed/pull/8 is merged.\n    if (err === true) {\n      return abort(new Error(UNEXPECTED_END));\n    }\n\n    callback(err);\n  });\n}\n/**\n * Manages dialing to another peer, including muxer upgrades\n * and crypto management. The main entry point for dialing is\n * Dialer.dial\n *\n * @param {Switch} _switch\n * @param {PeerInfo} peerInfo\n * @param {string} protocol\n * @param {function(Error, Connection)} callback\n */\n\n\nvar Dialer =\n/*#__PURE__*/\nfunction () {\n  function Dialer(_switch, peerInfo, ourPeerInfo, protocol, callback) {\n    _classCallCheck(this, Dialer);\n\n    this.switch = _switch;\n    this.peerInfo = peerInfo;\n    this.ourPeerInfo = ourPeerInfo;\n    this.protocol = protocol;\n    this.callback = callback;\n  }\n  /**\n   * Initializes a proxy connection and returns it. The connection is also immediately\n   * dialed. This will include establishing the base connection, crypto, muxing and the\n   * protocol handshake if all needed components have already been set.\n   *\n   * @returns {Connection}\n   */\n\n\n  _createClass(Dialer, [{\n    key: \"dial\",\n    value: function dial() {\n      var _this = this;\n\n      var proxyConnection = new Connection();\n      proxyConnection.setPeerInfo(this.peerInfo);\n      waterfall([function (cb) {\n        _this._establishConnection(cb);\n      }, function (connection, cb) {\n        if (connection) {\n          proxyConnection.setPeerInfo(_this.peerInfo);\n          proxyConnection.setInnerConn(connection);\n          return cb(null, proxyConnection);\n        }\n\n        cb(null);\n      }], function (err, connection) {\n        if (err && err.message === UNEXPECTED_END || err === true) {\n          log('Connection dropped for %s', _this.peerInfo.id.toB58String());\n          return _this.callback(null, null);\n        }\n\n        _this.callback(err, connection);\n      });\n      return proxyConnection;\n    }\n    /**\n     * Establishes a base connection and then continues to upgrade that connection\n     * including: crypto, muxing and the protocol handshake. If any upgrade is not\n     * yet available, or already exists, the upgrade will continue where it left off.\n     *\n     * @private\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_establishConnection\",\n    value: function _establishConnection(callback) {\n      var _this2 = this;\n\n      var b58Id = this.peerInfo.id.toB58String();\n      log('dialing %s', b58Id);\n\n      if (b58Id === this.ourPeerInfo.id.toB58String()) {\n        return callback(new Error('A node cannot dial itself'));\n      }\n\n      waterfall([function (cb) {\n        // Start with a base connection, which includes encryption\n        _this2._createBaseConnection(b58Id, cb);\n      }, function (baseConnection, cb) {\n        // Upgrade the connection with a muxer\n        _this2._createMuxedConnection(baseConnection, b58Id, cb);\n      }, function (muxer, cb) {\n        // If we have no protocol, dont continue with the handshake\n        if (!_this2.protocol) {\n          return cb();\n        } // If we have a muxer, create a new stream, otherwise it's a standard connection\n\n\n        if (muxer.newStream) {\n          muxer.newStream(function (err, conn) {\n            if (err) return cb(err);\n\n            _this2._performProtocolHandshake(conn, cb);\n          });\n          return;\n        }\n\n        _this2._performProtocolHandshake(muxer, cb);\n      }], function (err, connection) {\n        callback(err, connection);\n      });\n    }\n    /**\n     * If the base connection already exists to the PeerId key, `b58Id`,\n     * it will be returned in the callback. If no connection exists, one will\n     * be attempted via Dialer.attemptDial.\n     *\n     * @private\n     * @param {string} b58Id\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_createBaseConnection\",\n    value: function _createBaseConnection(b58Id, callback) {\n      var _this3 = this;\n\n      var baseConnection = this.switch.conns[b58Id];\n      var muxedConnection = this.switch.muxedConns[b58Id]; // if the muxed connection exists, dont return a connection,\n      // _createMuxedConnection will get the connection\n\n      if (muxedConnection) {\n        return callback(null, null);\n      }\n\n      if (baseConnection) {\n        this.switch.conns[b58Id] = undefined;\n        return callback(null, baseConnection);\n      }\n\n      waterfall([function (cb) {\n        _this3._attemptDial(cb);\n      }, function (baseConnection, cb) {\n        // Create a private connection if it's needed\n        _this3._createPrivateConnection(baseConnection, cb);\n      }, function (connection, cb) {\n        // Add the Switch's crypt encryption to the connection\n        _this3._encryptConnection(connection, cb);\n      }], function (err, encryptedConnection) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, encryptedConnection);\n      });\n    }\n    /**\n     * If the switch has a private network protector, `switch.protector`, its `protect`\n     * method will be called with the given connection. The resulting, wrapped connection\n     * will be returned via the callback.\n     *\n     * @param {Connection} connection The connection to protect\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_createPrivateConnection\",\n    value: function _createPrivateConnection(connection, callback) {\n      var _this4 = this;\n\n      if (this.switch.protector === null) {\n        return callback(null, connection);\n      } // If the switch has a protector, be private\n\n\n      var protectedConnection = this.switch.protector.protect(connection, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        protectedConnection.setPeerInfo(_this4.peerInfo);\n        callback(null, protectedConnection);\n      });\n    }\n    /**\n     * If the given PeerId key, `b58Id`, has an existing muxed connection\n     * it will be returned via the callback, otherwise the connection\n     * upgrade will be initiated via Dialer.attemptMuxerUpgrade.\n     *\n     * @private\n     * @param {Connection} connection\n     * @param {string} b58Id\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_createMuxedConnection\",\n    value: function _createMuxedConnection(connection, b58Id, callback) {\n      var _this5 = this;\n\n      var muxedConnection = this.switch.muxedConns[b58Id];\n\n      if (muxedConnection) {\n        return callback(null, muxedConnection.muxer);\n      }\n\n      connection.setPeerInfo(this.peerInfo);\n\n      this._attemptMuxerUpgrade(connection, b58Id, function (err, muxer) {\n        if (err && !_this5.protocol) {\n          _this5.switch.conns[b58Id] = connection;\n          return callback(null, null);\n        }\n\n        if (err) {\n          log('muxer upgrade failed with error', err); // couldn't upgrade to Muxer, it is ok, use the existing connection\n\n          return callback(null, connection);\n        }\n\n        callback(null, muxer);\n      }, callback);\n    }\n    /**\n     * Iterates over each Muxer on the Switch and attempts to upgrade\n     * the given `connection`. Successful muxed connections will be stored\n     * on the Switch.muxedConns with `b58Id` as their key for future reference.\n     *\n     * @private\n     * @param {Connection} connection\n     * @param {string} b58Id\n     * @param {function(Error, Connection)} callback\n     * @param {function(Error, Connection)} abort A callback to be used for ending the connection outright\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_attemptMuxerUpgrade\",\n    value: function _attemptMuxerUpgrade(connection, b58Id, callback, abort) {\n      var _this6 = this;\n\n      var muxers = Object.keys(this.switch.muxers);\n\n      if (muxers.length === 0) {\n        return callback(new Error('no muxers available'));\n      }\n\n      var msDialer = new multistream.Dialer();\n      handleSafe(msDialer, connection, function (err) {\n        if (err) {\n          return callback(new Error('multistream not supported'));\n        } // 1. try to handshake in one of the muxers available\n        // 2. if succeeds\n        //  - add the muxedConn to the list of muxedConns\n        //  - add incomming new streams to connHandler\n\n\n        var nextMuxer = function nextMuxer(key) {\n          log('selecting %s', key);\n          selectSafe(msDialer, key, function (err, _conn) {\n            if (err) {\n              if (muxers.length === 0) {\n                return callback(new Error('could not upgrade to stream muxing'));\n              }\n\n              return nextMuxer(muxers.shift());\n            } // observe muxed connections\n\n\n            var conn = observeConnection(null, key, _conn, _this6.switch.observer);\n\n            var muxedConn = _this6.switch.muxers[key].dialer(conn);\n\n            _this6.switch.muxedConns[b58Id] = {\n              muxer: muxedConn\n            };\n            muxedConn.once('close', function () {\n              delete _this6.switch.muxedConns[b58Id];\n\n              _this6.peerInfo.disconnect();\n\n              _this6.switch._peerInfo.disconnect();\n\n              log(\"closed connection to \".concat(b58Id));\n              setImmediate(function () {\n                return _this6.switch.emit('peer-mux-closed', _this6.peerInfo);\n              });\n            }); // For incoming streams, in case identify is on\n\n            muxedConn.on('stream', function (conn) {\n              conn.setPeerInfo(_this6.peerInfo);\n\n              _this6.switch.protocolMuxer(null)(conn);\n            });\n            setImmediate(function () {\n              return _this6.switch.emit('peer-mux-established', _this6.peerInfo);\n            });\n            callback(null, muxedConn);\n          }, abort);\n        };\n\n        nextMuxer(muxers.shift());\n      }, abort);\n    }\n    /**\n     * Iterates over each Transport on the Switch and attempts to connect\n     * to the peer. Once a Transport succeeds, no additional Transports will\n     * be dialed.\n     *\n     * @private\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_attemptDial\",\n    value: function _attemptDial(callback) {\n      var _this7 = this;\n\n      if (!this.switch.hasTransports()) {\n        return callback(new Error('No transports registered, dial not possible'));\n      }\n\n      var tKeys = this.switch.availableTransports(this.peerInfo);\n      var circuitEnabled = Boolean(this.switch.transports[Circuit.tag]);\n      var circuitTried = false;\n\n      var nextTransport = function nextTransport(key) {\n        var transport = key;\n\n        var b58Id = _this7.peerInfo.id.toB58String();\n\n        if (!transport) {\n          if (!circuitEnabled) {\n            var msg = \"Circuit not enabled and all transports failed to dial peer \".concat(b58Id, \"!\");\n            return callback(new Error(msg));\n          }\n\n          if (circuitTried) {\n            return callback(new Error(\"No available transports to dial peer \".concat(b58Id, \"!\")));\n          }\n\n          log(\"Falling back to dialing over circuit\");\n\n          _this7.peerInfo.multiaddrs.add(\"/p2p-circuit/ipfs/\".concat(b58Id));\n\n          circuitTried = true;\n          transport = Circuit.tag;\n        }\n\n        log(\"dialing transport \".concat(transport));\n\n        _this7.switch.transport.dial(transport, _this7.peerInfo, function (err, _conn) {\n          if (err) {\n            log(err);\n            return nextTransport(tKeys.shift());\n          }\n\n          var conn = observeConnection(transport, null, _conn, _this7.switch.observer);\n          callback(null, conn);\n        });\n      };\n\n      nextTransport(tKeys.shift());\n    }\n    /**\n     * Attempts to encrypt the given `connection` with the Switch's crypto.\n     *\n     * @private\n     * @param {Connection} connection\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_encryptConnection\",\n    value: function _encryptConnection(connection, callback) {\n      var _this8 = this;\n\n      var msDialer = new multistream.Dialer();\n      handleSafe(msDialer, connection, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        var myId = _this8.switch._peerInfo.id;\n        log('selecting crypto: %s', _this8.switch.crypto.tag);\n        selectSafe(msDialer, _this8.switch.crypto.tag, function (err, _conn) {\n          if (err) {\n            return callback(err);\n          }\n\n          var conn = observeConnection(null, _this8.switch.crypto.tag, _conn, _this8.switch.observer);\n\n          var encryptedConnection = _this8.switch.crypto.encrypt(myId, conn, _this8.peerInfo.id, function (err) {\n            if (err) {\n              return callback(err);\n            }\n\n            encryptedConnection.setPeerInfo(_this8.peerInfo);\n            callback(null, encryptedConnection);\n          });\n        }, callback);\n      }, callback);\n    }\n    /**\n     * Initiates a handshake for the Dialer's set protocol\n     *\n     * @private\n     * @param {Connection} connection\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_performProtocolHandshake\",\n    value: function _performProtocolHandshake(connection, callback) {\n      var _this9 = this;\n\n      // If there is no protocol set yet, don't perform the handshake\n      if (!this.protocol) {\n        callback();\n      }\n\n      var msDialer = new multistream.Dialer();\n      handleSafe(msDialer, connection, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        selectSafe(msDialer, _this9.protocol, function (err, _conn) {\n          if (err) {\n            log(\"could not perform protocol handshake: \", err);\n            return callback(err);\n          }\n\n          var conn = observeConnection(null, _this9.protocol, _conn, _this9.switch.observer);\n          callback(null, conn);\n        }, callback);\n      }, callback);\n    }\n  }]);\n\n  return Dialer;\n}();\n/**\n * Returns a Dialer generator that when called, will immediately begin dialing\n * fo the given `peer`.\n *\n * @param {Switch} _switch\n * @returns {function(PeerInfo, string, function(Error, Connection))}\n */\n\n\nfunction dial(_switch) {\n  /**\n   * Creates a new dialer and immediately begins dialing to the given `peer`\n   *\n   * @param {PeerInfo} peer\n   * @param {string} protocol\n   * @param {function(Error, Connection)} callback\n   * @returns {Connection}\n   */\n  return function (peer, protocol, callback) {\n    if (typeof protocol === 'function') {\n      callback = protocol;\n      protocol = null;\n    }\n\n    callback = callback || function noop() {};\n\n    var peerInfo = getPeerInfo(peer, _switch._peerBook);\n    var dialer = new Dialer(_switch, peerInfo, _switch._peerInfo, protocol, callback);\n    return dialer.dial();\n  };\n}\n\nmodule.exports = dial;","map":null,"metadata":{},"sourceType":"script"}