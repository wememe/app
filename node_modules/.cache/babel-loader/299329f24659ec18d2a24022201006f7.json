{"ast":null,"code":"'use strict';\n\nvar aes = require('aes-js');\n\nvar scrypt = require('scrypt-js');\n\nvar uuid = require('uuid');\n\nvar hmac = require('../utils/hmac');\n\nvar pbkdf2 = require('../utils/pbkdf2');\n\nvar utils = require('../utils');\n\nvar SigningKey = require('./signing-key');\n\nvar HDNode = require('./hdnode'); // @TODO: Maybe move this to HDNode?\n\n\nvar defaultPath = \"m/44'/60'/0'/0/0\";\n\nfunction arrayify(hexString) {\n  if (typeof hexString === 'string' && hexString.substring(0, 2) !== '0x') {\n    hexString = '0x' + hexString;\n  }\n\n  return utils.arrayify(hexString);\n}\n\nfunction zpad(value, length) {\n  value = String(value);\n\n  while (value.length < length) {\n    value = '0' + value;\n  }\n\n  return value;\n}\n\nfunction getPassword(password) {\n  if (typeof password === 'string') {\n    return utils.toUtf8Bytes(password, 'NFKC');\n  }\n\n  return utils.arrayify(password, 'password');\n} // Search an Object and its children recursively, caselessly.\n\n\nfunction searchPath(object, path) {\n  var currentChild = object;\n  var comps = path.toLowerCase().split('/');\n\n  for (var i = 0; i < comps.length; i++) {\n    // Search for a child object with a case-insensitive matching key\n    var matchingChild = null;\n\n    for (var key in currentChild) {\n      if (key.toLowerCase() === comps[i]) {\n        matchingChild = currentChild[key];\n        break;\n      }\n    } // Didn't find one. :'(\n\n\n    if (matchingChild === null) {\n      return null;\n    } // Now check this child...\n\n\n    currentChild = matchingChild;\n  }\n\n  return currentChild;\n}\n\nvar secretStorage = {};\nutils.defineProperty(secretStorage, 'isCrowdsaleWallet', function (json) {\n  try {\n    var data = JSON.parse(json);\n  } catch (error) {\n    return false;\n  }\n\n  return data.encseed && data.ethaddr;\n});\nutils.defineProperty(secretStorage, 'isValidWallet', function (json) {\n  try {\n    var data = JSON.parse(json);\n  } catch (error) {\n    return false;\n  }\n\n  if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {\n    return false;\n  } // @TODO: Put more checks to make sure it has kdf, iv and all that good stuff\n\n\n  return true;\n}); // See: https://github.com/ethereum/pyethsaletool\n\nutils.defineProperty(secretStorage, 'decryptCrowdsale', function (json, password) {\n  var data = JSON.parse(json);\n  password = getPassword(password); // Ethereum Address\n\n  var ethaddr = utils.getAddress(searchPath(data, 'ethaddr')); // Encrypted Seed\n\n  var encseed = arrayify(searchPath(data, 'encseed'));\n\n  if (!encseed || encseed.length % 16 !== 0) {\n    throw new Error('invalid encseed');\n  }\n\n  var key = pbkdf2(password, password, 2000, 32, hmac.createSha256Hmac).slice(0, 16);\n  var iv = encseed.slice(0, 16);\n  var encryptedSeed = encseed.slice(16); // Decrypt the seed\n\n  var aesCbc = new aes.ModeOfOperation.cbc(key, iv);\n  var seed = utils.arrayify(aesCbc.decrypt(encryptedSeed));\n  seed = aes.padding.pkcs7.strip(seed); // This wallet format is weird... Convert the binary encoded hex to a string.\n\n  var seedHex = '';\n\n  for (var i = 0; i < seed.length; i++) {\n    seedHex += String.fromCharCode(seed[i]);\n  }\n\n  var seedHexBytes = utils.toUtf8Bytes(seedHex);\n  var signingKey = new SigningKey(utils.keccak256(seedHexBytes));\n\n  if (signingKey.address !== ethaddr) {\n    throw new Error('corrupt crowdsale wallet');\n  }\n\n  return signingKey;\n});\nutils.defineProperty(secretStorage, 'decrypt', function (json, password, progressCallback) {\n  var data = JSON.parse(json);\n  password = getPassword(password);\n\n  var decrypt = function decrypt(key, ciphertext) {\n    var cipher = searchPath(data, 'crypto/cipher');\n\n    if (cipher === 'aes-128-ctr') {\n      var iv = arrayify(searchPath(data, 'crypto/cipherparams/iv'), 'crypto/cipherparams/iv');\n      var counter = new aes.Counter(iv);\n      var aesCtr = new aes.ModeOfOperation.ctr(key, counter);\n      return arrayify(aesCtr.decrypt(ciphertext));\n    }\n\n    return null;\n  };\n\n  var computeMAC = function computeMAC(derivedHalf, ciphertext) {\n    return utils.keccak256(utils.concat([derivedHalf, ciphertext]));\n  };\n\n  var getSigningKey = function getSigningKey(key, reject) {\n    var ciphertext = arrayify(searchPath(data, 'crypto/ciphertext'));\n    var computedMAC = utils.hexlify(computeMAC(key.slice(16, 32), ciphertext)).substring(2);\n\n    if (computedMAC !== searchPath(data, 'crypto/mac').toLowerCase()) {\n      reject(new Error('invalid password'));\n      return null;\n    }\n\n    var privateKey = decrypt(key.slice(0, 16), ciphertext);\n    var mnemonicKey = key.slice(32, 64);\n\n    if (!privateKey) {\n      reject(new Error('unsupported cipher'));\n      return null;\n    }\n\n    var signingKey = new SigningKey(privateKey);\n\n    if (signingKey.address !== utils.getAddress(data.address)) {\n      reject(new Error('address mismatch'));\n      return null;\n    } // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n\n\n    if (searchPath(data, 'x-ethers/version') === '0.1') {\n      var mnemonicCiphertext = arrayify(searchPath(data, 'x-ethers/mnemonicCiphertext'), 'x-ethers/mnemonicCiphertext');\n      var mnemonicIv = arrayify(searchPath(data, 'x-ethers/mnemonicCounter'), 'x-ethers/mnemonicCounter');\n      var mnemonicCounter = new aes.Counter(mnemonicIv);\n      var mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n      var path = searchPath(data, 'x-ethers/path') || defaultPath;\n      var entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\n      var mnemonic = HDNode.entropyToMnemonic(entropy);\n\n      if (HDNode.fromMnemonic(mnemonic).derivePath(path).privateKey != utils.hexlify(privateKey)) {\n        reject(new Error('mnemonic mismatch'));\n        return null;\n      }\n\n      signingKey.mnemonic = mnemonic;\n      signingKey.path = path;\n    }\n\n    return signingKey;\n  };\n\n  return new Promise(function (resolve, reject) {\n    var kdf = searchPath(data, 'crypto/kdf');\n\n    if (kdf && typeof kdf === 'string') {\n      if (kdf.toLowerCase() === 'scrypt') {\n        var salt = arrayify(searchPath(data, 'crypto/kdfparams/salt'), 'crypto/kdfparams/salt');\n        var N = parseInt(searchPath(data, 'crypto/kdfparams/n'));\n        var r = parseInt(searchPath(data, 'crypto/kdfparams/r'));\n        var p = parseInt(searchPath(data, 'crypto/kdfparams/p'));\n\n        if (!N || !r || !p) {\n          reject(new Error('unsupported key-derivation function parameters'));\n          return;\n        } // Make sure N is a power of 2\n\n\n        if ((N & N - 1) !== 0) {\n          reject(new Error('unsupported key-derivation function parameter value for N'));\n          return;\n        }\n\n        var dkLen = parseInt(searchPath(data, 'crypto/kdfparams/dklen'));\n\n        if (dkLen !== 32) {\n          reject(new Error('unsupported key-derivation derived-key length'));\n          return;\n        }\n\n        scrypt(password, salt, N, r, p, 64, function (error, progress, key) {\n          if (error) {\n            error.progress = progress;\n            reject(error);\n          } else if (key) {\n            key = arrayify(key);\n            var signingKey = getSigningKey(key, reject);\n\n            if (!signingKey) {\n              return;\n            }\n\n            if (progressCallback) {\n              progressCallback(1);\n            }\n\n            resolve(signingKey);\n          } else if (progressCallback) {\n            return progressCallback(progress);\n          }\n        });\n      } else if (kdf.toLowerCase() === 'pbkdf2') {\n        var salt = arrayify(searchPath(data, 'crypto/kdfparams/salt'), 'crypto/kdfparams/salt');\n        var prfFunc = null;\n        var prf = searchPath(data, 'crypto/kdfparams/prf');\n\n        if (prf === 'hmac-sha256') {\n          prfFunc = hmac.createSha256Hmac;\n        } else if (prf === 'hmac-sha512') {\n          prfFunc = hmac.createSha512Hmac;\n        } else {\n          reject(new Error('unsupported prf'));\n          return;\n        }\n\n        var c = parseInt(searchPath(data, 'crypto/kdfparams/c'));\n        var dkLen = parseInt(searchPath(data, 'crypto/kdfparams/dklen'));\n\n        if (dkLen !== 32) {\n          reject(new Error('unsupported key-derivation derived-key length'));\n          return;\n        }\n\n        var key = pbkdf2(password, salt, c, dkLen, prfFunc);\n        var signingKey = getSigningKey(key, reject);\n\n        if (!signingKey) {\n          return;\n        }\n\n        resolve(signingKey);\n      } else {\n        reject(new Error('unsupported key-derivation function'));\n      }\n    } else {\n      reject(new Error('unsupported key-derivation function'));\n    }\n  });\n});\nutils.defineProperty(secretStorage, 'encrypt', function (privateKey, password, options, progressCallback) {\n  // the options are optional, so adjust the call as needed\n  if (typeof options === 'function' && !progressCallback) {\n    progressCallback = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  } // Check the private key\n\n\n  if (privateKey instanceof SigningKey) {\n    privateKey = privateKey.privateKey;\n  }\n\n  privateKey = arrayify(privateKey, 'private key');\n\n  if (privateKey.length !== 32) {\n    throw new Error('invalid private key');\n  }\n\n  password = getPassword(password);\n  var entropy = options.entropy;\n\n  if (options.mnemonic) {\n    if (entropy) {\n      if (HDNode.entropyToMnemonic(entropy) !== options.mnemonic) {\n        throw new Error('entropy and mnemonic mismatch');\n      }\n    } else {\n      entropy = HDNode.mnemonicToEntropy(options.mnemonic);\n    }\n  }\n\n  if (entropy) {\n    entropy = arrayify(entropy, 'entropy');\n  }\n\n  var path = options.path;\n\n  if (entropy && !path) {\n    path = defaultPath;\n  }\n\n  var client = options.client;\n\n  if (!client) {\n    client = \"ethers.js\";\n  } // Check/generate the salt\n\n\n  var salt = options.salt;\n\n  if (salt) {\n    salt = arrayify(salt, 'salt');\n  } else {\n    salt = utils.randomBytes(32);\n    ;\n  } // Override initialization vector\n\n\n  var iv = null;\n\n  if (options.iv) {\n    iv = arrayify(options.iv, 'iv');\n\n    if (iv.length !== 16) {\n      throw new Error('invalid iv');\n    }\n  } else {\n    iv = utils.randomBytes(16);\n  } // Override the uuid\n\n\n  var uuidRandom = options.uuid;\n\n  if (uuidRandom) {\n    uuidRandom = arrayify(uuidRandom, 'uuid');\n\n    if (uuidRandom.length !== 16) {\n      throw new Error('invalid uuid');\n    }\n  } else {\n    uuidRandom = utils.randomBytes(16);\n  } // Override the scrypt password-based key derivation function parameters\n\n\n  var N = 1 << 17,\n      r = 8,\n      p = 1;\n\n  if (options.scrypt) {\n    if (options.scrypt.N) {\n      N = options.scrypt.N;\n    }\n\n    if (options.scrypt.r) {\n      r = options.scrypt.r;\n    }\n\n    if (options.scrypt.p) {\n      p = options.scrypt.p;\n    }\n  }\n\n  return new Promise(function (resolve, reject) {\n    // We take 64 bytes:\n    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n    scrypt(password, salt, N, r, p, 64, function (error, progress, key) {\n      if (error) {\n        error.progress = progress;\n        reject(error);\n      } else if (key) {\n        key = arrayify(key); // This will be used to encrypt the wallet (as per Web3 secret storage)\n\n        var derivedKey = key.slice(0, 16);\n        var macPrefix = key.slice(16, 32); // This will be used to encrypt the mnemonic phrase (if any)\n\n        var mnemonicKey = key.slice(32, 64); // Get the address for this private key\n\n        var address = new SigningKey(privateKey).address; // Encrypt the private key\n\n        var counter = new aes.Counter(iv);\n        var aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);\n        var ciphertext = utils.arrayify(aesCtr.encrypt(privateKey)); // Compute the message authentication code, used to check the password\n\n        var mac = utils.keccak256(utils.concat([macPrefix, ciphertext])); // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n\n        var data = {\n          address: address.substring(2).toLowerCase(),\n          id: uuid.v4({\n            random: uuidRandom\n          }),\n          version: 3,\n          Crypto: {\n            cipher: 'aes-128-ctr',\n            cipherparams: {\n              iv: utils.hexlify(iv).substring(2)\n            },\n            ciphertext: utils.hexlify(ciphertext).substring(2),\n            kdf: 'scrypt',\n            kdfparams: {\n              salt: utils.hexlify(salt).substring(2),\n              n: N,\n              dklen: 32,\n              p: p,\n              r: r\n            },\n            mac: mac.substring(2)\n          }\n        }; // If we have a mnemonic, encrypt it into the JSON wallet\n\n        if (entropy) {\n          var mnemonicIv = utils.randomBytes(16);\n          var mnemonicCounter = new aes.Counter(mnemonicIv);\n          var mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n          var mnemonicCiphertext = utils.arrayify(mnemonicAesCtr.encrypt(entropy));\n          var now = new Date();\n          var timestamp = now.getUTCFullYear() + '-' + zpad(now.getUTCMonth() + 1, 2) + '-' + zpad(now.getUTCDate(), 2) + 'T' + zpad(now.getUTCHours(), 2) + '-' + zpad(now.getUTCMinutes(), 2) + '-' + zpad(now.getUTCSeconds(), 2) + '.0Z';\n          data['x-ethers'] = {\n            client: client,\n            gethFilename: 'UTC--' + timestamp + '--' + data.address,\n            mnemonicCounter: utils.hexlify(mnemonicIv).substring(2),\n            mnemonicCiphertext: utils.hexlify(mnemonicCiphertext).substring(2),\n            version: \"0.1\"\n          };\n        }\n\n        if (progressCallback) {\n          progressCallback(1);\n        }\n\n        resolve(JSON.stringify(data));\n      } else if (progressCallback) {\n        return progressCallback(progress);\n      }\n    });\n  });\n});\nmodule.exports = secretStorage;","map":null,"metadata":{},"sourceType":"script"}