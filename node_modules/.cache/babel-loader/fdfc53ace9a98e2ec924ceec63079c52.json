{"ast":null,"code":"/* @flow */\n'use strict';\n/* :: import type {Callback, Batch, Query, QueryResult, QueryEntry} from 'interface-datastore' */\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar pull = require('pull-stream');\n\nvar levelup = require('levelup');\n\nvar asyncFilter = require('interface-datastore').utils.asyncFilter;\n\nvar asyncSort = require('interface-datastore').utils.asyncSort;\n\nvar Key = require('interface-datastore').Key;\n\nvar Errors = require('interface-datastore').Errors;\n\nvar encode = require('encoding-down');\n/**\n * A datastore backed by leveldb.\n */\n\n/* :: export type LevelOptions = {\n  createIfMissing?: bool,\n  errorIfExists?: bool,\n  compression?: bool,\n  cacheSize?: number,\n  db?: Object\n} */\n\n\nvar LevelDatastore =\n/*#__PURE__*/\nfunction () {\n  /* :: db: levelup */\n  function LevelDatastore(path\n  /* : string */\n  , opts\n  /* : ?LevelOptions */\n  ) {\n    _classCallCheck(this, LevelDatastore);\n\n    var database;\n\n    if (opts && opts.db) {\n      database = opts.db;\n      delete opts.db;\n    } else {\n      // Default to leveldown db\n      database = require('leveldown');\n    }\n\n    this.db = levelup(encode(database(path), {\n      valueEncoding: 'binary'\n    }), Object.assign({}, opts, {\n      compression: false // same default as go\n\n    }), function (err) {\n      // Prevent an uncaught exception error on duplicate locks\n      if (err) {\n        throw err;\n      }\n    });\n  }\n\n  _createClass(LevelDatastore, [{\n    key: \"open\",\n    value: function open(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.db.open(function (err) {\n        if (err) {\n          return callback(Errors.dbOpenFailedError(err));\n        }\n\n        callback();\n      });\n    }\n  }, {\n    key: \"put\",\n    value: function put(key\n    /* : Key */\n    , value\n    /* : Buffer */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.db.put(key.toString(), value, function (err) {\n        if (err) {\n          return callback(Errors.dbWriteFailedError(err));\n        }\n\n        callback();\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function get(key\n    /* : Key */\n    , callback\n    /* : Callback<Buffer> */\n    )\n    /* : void */\n    {\n      this.db.get(key.toString(), function (err, data) {\n        if (err) {\n          return callback(Errors.notFoundError(err));\n        }\n\n        callback(null, data);\n      });\n    }\n  }, {\n    key: \"has\",\n    value: function has(key\n    /* : Key */\n    , callback\n    /* : Callback<bool> */\n    )\n    /* : void */\n    {\n      this.db.get(key.toString(), function (err, res) {\n        if (err) {\n          if (err.notFound) {\n            callback(null, false);\n            return;\n          }\n\n          callback(err);\n          return;\n        }\n\n        callback(null, true);\n      });\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key\n    /* : Key */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.db.del(key.toString(), function (err) {\n        if (err) {\n          return callback(Errors.dbDeleteFailedError(err));\n        }\n\n        callback();\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.db.close(callback);\n    }\n  }, {\n    key: \"batch\",\n    value: function batch()\n    /* : Batch<Buffer> */\n    {\n      var _this = this;\n\n      var ops = [];\n      return {\n        put: function put(key\n        /* : Key */\n        , value\n        /* : Buffer */\n        )\n        /* : void */\n        {\n          ops.push({\n            type: 'put',\n            key: key.toString(),\n            value: value\n          });\n        },\n        delete: function _delete(key\n        /* : Key */\n        )\n        /* : void */\n        {\n          ops.push({\n            type: 'del',\n            key: key.toString()\n          });\n        },\n        commit: function commit(callback\n        /* : Callback<void> */\n        )\n        /* : void */\n        {\n          _this.db.batch(ops, callback);\n        }\n      };\n    }\n  }, {\n    key: \"query\",\n    value: function query(q\n    /* : Query<Buffer> */\n    )\n    /* : QueryResult<Buffer> */\n    {\n      var values = true;\n\n      if (q.keysOnly != null) {\n        values = !q.keysOnly;\n      }\n\n      var iter = this.db.db.iterator({\n        keys: true,\n        values: values,\n        keyAsBuffer: true\n      });\n\n      var rawStream = function rawStream(end, cb) {\n        if (end) {\n          return iter.end(function (err) {\n            cb(err || end);\n          });\n        }\n\n        iter.next(function (err, key, value) {\n          if (err) {\n            return cb(err);\n          }\n\n          if (err == null && key == null && value == null) {\n            return iter.end(function (err) {\n              cb(err || true);\n            });\n          }\n\n          var res\n          /* : QueryEntry<Buffer> */\n          = {\n            key: new Key(key, false)\n          };\n\n          if (values) {\n            res.value = Buffer.from(value);\n          }\n\n          cb(null, res);\n        });\n      };\n\n      var tasks = [rawStream];\n      var filters = [];\n\n      if (q.prefix != null) {\n        var prefix = q.prefix;\n        filters.push(function (e, cb) {\n          return cb(null, e.key.toString().startsWith(prefix));\n        });\n      }\n\n      if (q.filters != null) {\n        filters = filters.concat(q.filters);\n      }\n\n      tasks = tasks.concat(filters.map(function (f) {\n        return asyncFilter(f);\n      }));\n\n      if (q.orders != null) {\n        tasks = tasks.concat(q.orders.map(function (o) {\n          return asyncSort(o);\n        }));\n      }\n\n      if (q.offset != null) {\n        var i = 0;\n        tasks.push(pull.filter(function () {\n          return i++ >= q.offset;\n        }));\n      }\n\n      if (q.limit != null) {\n        tasks.push(pull.take(q.limit));\n      }\n\n      return pull.apply(null, tasks);\n    }\n  }]);\n\n  return LevelDatastore;\n}();\n\nmodule.exports = LevelDatastore;","map":null,"metadata":{},"sourceType":"script"}