{"ast":null,"code":"var _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar chainParams = require('./chains');\n\nvar hardforkChanges = require('./hardforks');\n/**\n * Common class to access chain and hardfork parameters\n */\n\n\nvar Common =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  /**\n   * @constructor\n   * @param {String|Number|Dictionary} chain String ('mainnet') or Number (1) chain\n   * @param {String} hardfork String identifier ('byzantium') for hardfork (optional)\n   * @param {Array} supportedHardforks Limit parameter returns to the given hardforks (optional)\n   */\n  function Common(chain, hardfork, supportedHardforks) {\n    _classCallCheck(this, Common);\n\n    this.setChain(chain);\n    this._hardfork = null;\n    this._supportedHardforks = supportedHardforks === undefined ? [] : supportedHardforks;\n\n    if (hardfork) {\n      this.setHardfork(hardfork);\n    }\n  }\n  /**\n   * Sets the chain\n   * @param {String|Number|Dictionary} chain String ('mainnet') or Number (1) chain\n   *     representation. Or, a Dictionary of chain parameters for a private network.\n   */\n\n\n  _createClass(Common, [{\n    key: \"setChain\",\n    value: function setChain(chain) {\n      if (typeof chain === 'number') {\n        if (chainParams['names'][chain]) {\n          this._chainParams = chainParams[chainParams['names'][chain]];\n        } else {\n          throw new Error(\"Chain with ID \".concat(chain, \" not supported\"));\n        }\n      } else if (typeof chain === 'string') {\n        if (chainParams[chain]) {\n          this._chainParams = chainParams[chain];\n        } else {\n          throw new Error(\"Chain with name \".concat(chain, \" not supported\"));\n        }\n      } else if (typeof chain === 'object') {\n        var required = ['networkId', 'genesis', 'hardforks', 'bootstrapNodes'];\n\n        for (var _i = 0; _i < required.length; _i++) {\n          var param = required[_i];\n\n          if (chain[param] === undefined) {\n            throw new Error(\"Missing required chain parameter: \".concat(param));\n          }\n        }\n\n        this._chainParams = chain;\n      } else {\n        throw new Error('Wrong input format');\n      }\n    }\n    /**\n     * Sets the hardfork to get params for\n     * @param {String} hardfork String identifier ('byzantium')\n     */\n\n  }, {\n    key: \"setHardfork\",\n    value: function setHardfork(hardfork) {\n      if (!this._isSupportedHardfork(hardfork)) {\n        throw new Error(\"Hardfork \".concat(hardfork, \" not set as supported in supportedHardforks\"));\n      }\n\n      var changed = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = hardforkChanges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var hfChanges = _step.value;\n\n          if (hfChanges[0] === hardfork) {\n            this._hardfork = hardfork;\n            changed = true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (!changed) {\n        throw new Error(\"Hardfork with name \".concat(hardfork, \" not supported\"));\n      }\n    }\n    /**\n     * Internal helper function to choose between hardfork set and hardfork provided as param\n     * @param {String} hardfork Hardfork given to function as a parameter\n     * @returns {String} Hardfork chosen to be used\n     */\n\n  }, {\n    key: \"_chooseHardfork\",\n    value: function _chooseHardfork(hardfork, onlySupported) {\n      onlySupported = onlySupported === undefined ? true : onlySupported;\n\n      if (!hardfork) {\n        if (!this._hardfork) {\n          throw new Error('Method called with neither a hardfork set nor provided by param');\n        } else {\n          hardfork = this._hardfork;\n        }\n      } else if (!this._isSupportedHardfork(hardfork)) {\n        throw new Error(\"Hardfork \".concat(hardfork, \" not set as supported in supportedHardforks\"));\n      }\n\n      return hardfork;\n    }\n    /**\n     * Internal helper function, returns the params for the given hardfork for the chain set\n     * @param {String} hardfork Hardfork name\n     * @returns {Dictionary}\n     */\n\n  }, {\n    key: \"_getHardfork\",\n    value: function _getHardfork(hardfork) {\n      var hfs = this.hardforks();\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = hfs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var hf = _step2.value;\n          if (hf['name'] === hardfork) return hf;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      throw new Error(\"Hardfork \".concat(hardfork, \" not defined for chain \").concat(this.chainName()));\n    }\n    /**\n     * Internal helper function to check if a hardfork is set to be supported by the library\n     * @param {String} hardfork Hardfork name\n     * @returns {Boolean} True if hardfork is supported\n     */\n\n  }, {\n    key: \"_isSupportedHardfork\",\n    value: function _isSupportedHardfork(hardfork) {\n      if (this._supportedHardforks.length > 0) {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = this._supportedHardforks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var supportedHf = _step3.value;\n            if (hardfork === supportedHf) return true;\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      } else {\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Returns the parameter corresponding to a hardfork\n     * @param {String} topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow', 'casper', 'sharding')\n     * @param {String} name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n     * @param {String} hardfork Hardfork name, optional if hardfork set\n     */\n\n  }, {\n    key: \"param\",\n    value: function param(topic, name, hardfork) {\n      hardfork = this._chooseHardfork(hardfork);\n      var value;\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = hardforkChanges[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var hfChanges = _step4.value;\n\n          if (!hfChanges[1][topic]) {\n            throw new Error(\"Topic \".concat(topic, \" not defined\"));\n          }\n\n          if (hfChanges[1][topic][name] !== undefined) {\n            value = hfChanges[1][topic][name].v;\n          }\n\n          if (hfChanges[0] === hardfork) break;\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      if (value === undefined) {\n        throw new Error(\"\".concat(topic, \" value for \").concat(name, \" not found\"));\n      }\n\n      return value;\n    }\n    /**\n     * Returns a parameter for the hardfork active on block number\n     * @param {String} topic Parameter topic\n     * @param {String} name Parameter name\n     * @param {Number} blockNumber Block number\n     */\n\n  }, {\n    key: \"paramByBlock\",\n    value: function paramByBlock(topic, name, blockNumber) {\n      var activeHfs = this.activeHardforks(blockNumber);\n      var hardfork = activeHfs[activeHfs.length - 1]['name'];\n      return this.param(topic, name, hardfork);\n    }\n    /**\n     * Checks if set or provided hardfork is active on block number\n     * @param {String} hardfork Hardfork name or null (for HF set)\n     * @param {Number} blockNumber\n     * @param {Array} opts\n     * @param {Array.Boolean} opts.onlySupported optional, only allow supported HFs (default: false)\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hardforkIsActiveOnBlock\",\n    value: function hardforkIsActiveOnBlock(hardfork, blockNumber, opts) {\n      opts = opts !== undefined ? opts : [];\n      var onlySupported = opts.onlySupported === undefined ? false : opts.onlySupported;\n      hardfork = this._chooseHardfork(hardfork, onlySupported);\n      var hfBlock = this.hardforkBlock(hardfork);\n      if (hfBlock !== null && blockNumber >= hfBlock) return true;\n      return false;\n    }\n    /**\n     * Alias to hardforkIsActiveOnBlock when hardfork is set\n     * @param {Number} blockNumber\n     * @param {Array} opts\n     * @param {Array.Boolean} opts.onlySupported optional, only allow supported HFs (default: false)\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"activeOnBlock\",\n    value: function activeOnBlock(blockNumber, opts) {\n      return this.hardforkIsActiveOnBlock(null, blockNumber, opts);\n    }\n    /**\n     * Sequence based check if given or set HF1 is greater than or equal HF2\n     * @param {String} hardfork1 Hardfork name or null (if set)\n     * @param {String} hardfork2 Hardfork name\n     * @param {Array} opts\n     * @param {Array.Boolean} opts.onlyActive optional, only active HFs (default: false)\n     * @param {Array.Boolean} opts.onlySupported optional, only allow supported HFs (default: false)\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hardforkGteHardfork\",\n    value: function hardforkGteHardfork(hardfork1, hardfork2, opts) {\n      opts = opts !== undefined ? opts : [];\n      var onlyActive = opts.onlyActive === undefined ? false : opts.onlyActive;\n      hardfork1 = this._chooseHardfork(hardfork1, opts.onlySupported);\n      var hardforks;\n\n      if (onlyActive) {\n        hardforks = this.activeHardforks(null, opts);\n      } else {\n        hardforks = this.hardforks();\n      }\n\n      var posHf1, posHf2;\n      var index = 0;\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = hardforks[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var hf = _step5.value;\n          if (hf['name'] === hardfork1) posHf1 = index;\n          if (hf['name'] === hardfork2) posHf2 = index;\n          index += 1;\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return posHf1 >= posHf2;\n    }\n    /**\n     * Alias to hardforkGteHardfork when hardfork is set\n     * @param {String} hardfork Hardfork name\n     * @param {Array} opts\n     * @param {Array.Boolean} opts.onlyActive optional, only active HFs (default: false)\n     * @param {Array.Boolean} opts.onlySupported optional, only allow supported HFs (default: false)\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"gteHardfork\",\n    value: function gteHardfork(hardfork, opts) {\n      return this.hardforkGteHardfork(null, hardfork, opts);\n    }\n    /**\n     * Checks if given or set hardfork is active on the chain\n     * @param {String} hardfork Hardfork name, optional if HF set\n     * @param {Array} opts\n     * @param {Array.Boolean} opts.onlySupported optional, only allow supported HFs (default: false)\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"hardforkIsActiveOnChain\",\n    value: function hardforkIsActiveOnChain(hardfork, opts) {\n      opts = opts !== undefined ? opts : [];\n      var onlySupported = opts.onlySupported === undefined ? false : opts.onlySupported;\n      hardfork = this._chooseHardfork(hardfork, onlySupported);\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this.hardforks()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var hf = _step6.value;\n          if (hf['name'] === hardfork && hf['block'] !== null) return true;\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Returns the active hardfork switches for the current chain\n     * @param {Number} blockNumber up to block if provided, otherwise for the whole chain\n     * @param {Array} opts\n     * @param {Array.Boolean} opts.onlySupported optional, limit results to supported HFs (default: false)\n     * @return {Array} Array with hardfork arrays\n     */\n\n  }, {\n    key: \"activeHardforks\",\n    value: function activeHardforks(blockNumber, opts) {\n      opts = opts !== undefined ? opts : [];\n      var activeHardforks = [];\n      var hfs = this.hardforks();\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = hfs[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var hf = _step7.value;\n          if (hf['block'] === null) continue;\n          if (blockNumber !== undefined && blockNumber !== null && blockNumber < hf['block']) break;\n          if (opts.onlySupported && !this._isSupportedHardfork(hf['name'])) continue;\n          activeHardforks.push(hf);\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      return activeHardforks;\n    }\n    /**\n     * Returns the latest active hardfork name for chain or block or throws if unavailable\n     * @param {Number} blockNumber up to block if provided, otherwise for the whole chain\n     * @param {Array} opts\n     * @param {Array.Boolean} opts.onlySupported optional, limit results to supported HFs (default: false)\n     * @return {String} Hardfork name\n     */\n\n  }, {\n    key: \"activeHardfork\",\n    value: function activeHardfork(blockNumber, opts) {\n      var activeHardforks = this.activeHardforks(blockNumber, opts);\n\n      if (activeHardforks.length > 0) {\n        return activeHardforks[activeHardforks.length - 1]['name'];\n      } else {\n        throw new Error(\"No (supported) active hardfork found\");\n      }\n    }\n    /**\n     * Returns the hardfork change block for hardfork provided or set\n     * @param {String} hardfork Hardfork name, optional if HF set\n     * @returns {Number} Block number\n     */\n\n  }, {\n    key: \"hardforkBlock\",\n    value: function hardforkBlock(hardfork) {\n      hardfork = this._chooseHardfork(hardfork, false);\n      return this._getHardfork(hardfork)['block'];\n    }\n    /**\n     * True if block number provided is the hardfork (given or set) change block of the current chain\n     * @param {Number} blockNumber Number of the block to check\n     * @param {String} hardfork Hardfork name, optional if HF set\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"isHardforkBlock\",\n    value: function isHardforkBlock(blockNumber, hardfork) {\n      hardfork = this._chooseHardfork(hardfork, false);\n\n      if (this.hardforkBlock(hardfork) === blockNumber) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    /**\n     * Provide the consensus type for the hardfork set or provided as param\n     * @param {String} hardfork Hardfork name, optional if hardfork set\n     * @returns {String} Consensus type (e.g. 'pow', 'poa')\n     */\n\n  }, {\n    key: \"consensus\",\n    value: function consensus(hardfork) {\n      hardfork = this._chooseHardfork(hardfork);\n      return this._getHardfork(hardfork)['consensus'];\n    }\n    /**\n     * Provide the finality type for the hardfork set or provided as param\n     * @param {String} hardfork Hardfork name, optional if hardfork set\n     * @returns {String} Finality type (e.g. 'pos', null of no finality)\n     */\n\n  }, {\n    key: \"finality\",\n    value: function finality(hardfork) {\n      hardfork = this._chooseHardfork(hardfork);\n      return this._getHardfork(hardfork)['finality'];\n    }\n    /**\n     * Returns the Genesis parameters of current chain\n     * @returns {Dictionary} Genesis dict\n    */\n\n  }, {\n    key: \"genesis\",\n    value: function genesis() {\n      return this._chainParams['genesis'];\n    }\n    /**\n     * Returns the hardforks for current chain\n     * @returns {Array} Array with arrays of hardforks\n     */\n\n  }, {\n    key: \"hardforks\",\n    value: function hardforks() {\n      return this._chainParams['hardforks'];\n    }\n    /**\n     * Returns bootstrap nodes for the current chain\n     * @returns {Dictionary} Dict with bootstrap nodes\n     */\n\n  }, {\n    key: \"bootstrapNodes\",\n    value: function bootstrapNodes() {\n      return this._chainParams['bootstrapNodes'];\n    }\n    /**\n     * Returns the hardfork set\n     * @returns {String} Hardfork name\n     */\n\n  }, {\n    key: \"hardfork\",\n    value: function hardfork() {\n      return this._hardfork;\n    }\n    /**\n     * Returns the Id of current chain\n     * @returns {Number} chain Id\n     */\n\n  }, {\n    key: \"chainId\",\n    value: function chainId() {\n      return this._chainParams['chainId'];\n    }\n    /**\n     * Returns the name of current chain\n     * @returns {String} chain name (lower case)\n     */\n\n  }, {\n    key: \"chainName\",\n    value: function chainName() {\n      return chainParams['names'][this.chainId()] || this._chainParams['name'];\n    }\n    /**\n     * Returns the Id of current network\n     * @returns {Number} network Id\n     */\n\n  }, {\n    key: \"networkId\",\n    value: function networkId() {\n      return this._chainParams['networkId'];\n    }\n  }]);\n\n  return Common;\n}();\n\nmodule.exports = Common;","map":null,"metadata":{},"sourceType":"script"}