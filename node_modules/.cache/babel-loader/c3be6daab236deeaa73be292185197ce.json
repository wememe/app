{"ast":null,"code":"'use strict'; // See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nvar utils = function () {\n  var AbiCoder = require('../utils/abi-coder');\n\n  var convert = require('../utils/convert');\n\n  var properties = require('../utils/properties');\n\n  var utf8 = require('../utils/utf8');\n\n  return {\n    defineFrozen: properties.defineFrozen,\n    defineProperty: properties.defineProperty,\n    coder: AbiCoder.defaultCoder,\n    parseSignature: AbiCoder.parseSignature,\n    arrayify: convert.arrayify,\n    concat: convert.concat,\n    isHexString: convert.isHexString,\n    toUtf8Bytes: utf8.toUtf8Bytes,\n    keccak256: require('../utils/keccak256')\n  };\n}();\n\nvar errors = require('../utils/errors');\n\nfunction parseParams(params) {\n  var names = [];\n  var types = [];\n  params.forEach(function (param) {\n    if (param.components != null) {\n      if (param.type.substring(0, 5) !== 'tuple') {\n        throw new Error('internal error; report on GitHub');\n      }\n\n      var suffix = '';\n      var arrayBracket = param.type.indexOf('[');\n\n      if (arrayBracket >= 0) {\n        suffix = param.type.substring(arrayBracket);\n      }\n\n      var result = parseParams(param.components);\n      names.push({\n        name: param.name || null,\n        names: result.names\n      });\n      types.push('tuple(' + result.types.join(',') + ')' + suffix);\n    } else {\n      names.push(param.name || null);\n      types.push(param.type);\n    }\n  });\n  return {\n    names: names,\n    types: types\n  };\n}\n\nfunction populateDescription(object, items) {\n  for (var key in items) {\n    utils.defineProperty(object, key, items[key]);\n  }\n\n  return object;\n}\n/**\n *  - bytecode (optional; only for deploy)\n *  - type (\"deploy\")\n */\n\n\nfunction DeployDescription() {}\n/**\n *  - name\n *  - signature\n *  - sighash\n *  - \n *  - \n *  - \n *  - \n *  - type: (\"call\" | \"transaction\")\n */\n\n\nfunction FunctionDescription() {}\n/**\n *  - anonymous\n *  - name\n *  - signature\n *  - parse\n *  - topics\n *  - inputs\n *  - type (\"event\")\n */\n\n\nfunction EventDescription() {}\n\nfunction Indexed(value) {\n  utils.defineProperty(this, 'indexed', true);\n  utils.defineProperty(this, 'hash', value);\n}\n\nfunction Result() {}\n\nfunction Interface(abi) {\n  if (!(this instanceof Interface)) {\n    throw new Error('missing new');\n  }\n\n  if (typeof abi === 'string') {\n    try {\n      abi = JSON.parse(abi);\n    } catch (error) {\n      errors.throwError('could not parse ABI JSON', errors.INVALID_ARGUMENT, {\n        arg: 'abi',\n        errorMessage: error.message,\n        value: abi\n      });\n    }\n  }\n\n  var _abi = [];\n  abi.forEach(function (fragment) {\n    if (typeof fragment === 'string') {\n      fragment = utils.parseSignature(fragment);\n    }\n\n    _abi.push(fragment);\n  });\n  utils.defineFrozen(this, 'abi', _abi);\n  var methods = {},\n      events = {},\n      deploy = null;\n  utils.defineProperty(this, 'functions', methods);\n  utils.defineProperty(this, 'events', events);\n\n  function addMethod(method) {\n    switch (method.type) {\n      case 'constructor':\n        var func = function () {\n          var inputParams = parseParams(method.inputs);\n\n          var func = function func(bytecode) {\n            if (!utils.isHexString(bytecode)) {\n              errors.throwError('invalid contract bytecode', errors.INVALID_ARGUMENT, {\n                arg: 'bytecode',\n                type: typeof bytecode,\n                value: bytecode\n              });\n            }\n\n            var params = Array.prototype.slice.call(arguments, 1);\n\n            if (params.length < inputParams.types.length) {\n              errors.throwError('missing constructor argument', errors.MISSING_ARGUMENT, {\n                arg: inputParams.names[params.length] || 'unknown',\n                count: params.length,\n                expectedCount: inputParams.types.length\n              });\n            } else if (params.length > inputParams.types.length) {\n              errors.throwError('too many constructor arguments', errors.UNEXPECTED_ARGUMENT, {\n                count: params.length,\n                expectedCount: inputParams.types.length\n              });\n            }\n\n            try {\n              var encodedParams = utils.coder.encode(method.inputs, params);\n            } catch (error) {\n              errors.throwError('invalid constructor argument', errors.INVALID_ARGUMENT, {\n                arg: error.arg,\n                reason: error.reason,\n                value: error.value\n              });\n            }\n\n            var result = {\n              bytecode: bytecode + encodedParams.substring(2),\n              type: 'deploy'\n            };\n            return populateDescription(new DeployDescription(), result);\n          };\n\n          utils.defineFrozen(func, 'inputs', inputParams);\n          utils.defineProperty(func, 'payable', method.payable == null || !!method.payable);\n          return func;\n        }();\n\n        if (!deploy) {\n          deploy = func;\n        }\n\n        break;\n\n      case 'function':\n        var func = function () {\n          var inputParams = parseParams(method.inputs);\n          var outputParams = parseParams(method.outputs);\n          var signature = '(' + inputParams.types.join(',') + ')';\n          signature = signature.replace(/tuple/g, '');\n          signature = method.name + signature;\n\n          var parse = function parse(data) {\n            try {\n              return utils.coder.decode(method.outputs, utils.arrayify(data));\n            } catch (error) {\n              errors.throwError('invalid data for function output', errors.INVALID_ARGUMENT, {\n                arg: 'data',\n                errorArg: error.arg,\n                errorValue: error.value,\n                value: data,\n                reason: error.reason\n              });\n            }\n          };\n\n          var sighash = utils.keccak256(utils.toUtf8Bytes(signature)).substring(0, 10);\n\n          var func = function func() {\n            var result = {\n              name: method.name,\n              signature: signature,\n              sighash: sighash,\n              type: method.constant ? 'call' : 'transaction'\n            };\n            var params = Array.prototype.slice.call(arguments, 0);\n\n            if (params.length < inputParams.types.length) {\n              errors.throwError('missing input argument', errors.MISSING_ARGUMENT, {\n                arg: inputParams.names[params.length] || 'unknown',\n                count: params.length,\n                expectedCount: inputParams.types.length,\n                name: method.name\n              });\n            } else if (params.length > inputParams.types.length) {\n              errors.throwError('too many input arguments', errors.UNEXPECTED_ARGUMENT, {\n                count: params.length,\n                expectedCount: inputParams.types.length\n              });\n            }\n\n            try {\n              var encodedParams = utils.coder.encode(method.inputs, params);\n            } catch (error) {\n              errors.throwError('invalid input argument', errors.INVALID_ARGUMENT, {\n                arg: error.arg,\n                reason: error.reason,\n                value: error.value\n              });\n            }\n\n            result.data = sighash + encodedParams.substring(2);\n            result.parse = parse;\n            return populateDescription(new FunctionDescription(), result);\n          };\n\n          utils.defineFrozen(func, 'inputs', inputParams);\n          utils.defineFrozen(func, 'outputs', outputParams);\n          utils.defineProperty(func, 'payable', method.payable == null || !!method.payable);\n          utils.defineProperty(func, 'parseResult', parse);\n          utils.defineProperty(func, 'signature', signature);\n          utils.defineProperty(func, 'sighash', sighash);\n          return func;\n        }(); // Expose the first (and hopefully unique named function\n\n\n        if (method.name && methods[method.name] == null) {\n          utils.defineProperty(methods, method.name, func);\n        } // Expose all methods by their signature, for overloaded functions\n\n\n        if (methods[func.signature] == null) {\n          utils.defineProperty(methods, func.signature, func);\n        }\n\n        break;\n\n      case 'event':\n        var func = function () {\n          var inputParams = parseParams(method.inputs);\n          var signature = '(' + inputParams.types.join(',') + ')';\n          signature = signature.replace(/tuple/g, '');\n          signature = method.name + signature;\n          var result = {\n            anonymous: !!method.anonymous,\n            name: method.name,\n            signature: signature,\n            type: 'event'\n          };\n\n          result.parse = function (topics, data) {\n            if (data == null) {\n              data = topics;\n              topics = null;\n            } // Strip the signature off of non-anonymous topics\n\n\n            if (topics != null && !method.anonymous) {\n              topics = topics.slice(1);\n            }\n\n            var inputIndexed = [],\n                inputNonIndexed = [];\n            var inputDynamic = [];\n            method.inputs.forEach(function (param, index) {\n              if (param.indexed) {\n                if (param.type === 'string' || param.type === 'bytes' || param.type.indexOf('[') >= 0 || param.type.substring(0, 5) === 'tuple') {\n                  inputIndexed.push({\n                    type: 'bytes32',\n                    name: param.name || ''\n                  });\n                  inputDynamic.push(true);\n                } else {\n                  inputIndexed.push(param);\n                  inputDynamic.push(false);\n                }\n              } else {\n                inputNonIndexed.push(param);\n                inputDynamic.push(false);\n              }\n            });\n\n            if (topics != null) {\n              var resultIndexed = utils.coder.decode(inputIndexed, utils.concat(topics));\n            }\n\n            var resultNonIndexed = utils.coder.decode(inputNonIndexed, utils.arrayify(data));\n            var result = new Result();\n            var nonIndexedIndex = 0,\n                indexedIndex = 0;\n            method.inputs.forEach(function (input, index) {\n              if (input.indexed) {\n                if (topics == null) {\n                  result[index] = new Indexed(null);\n                } else if (inputDynamic[index]) {\n                  result[index] = new Indexed(resultIndexed[indexedIndex++]);\n                } else {\n                  result[index] = resultIndexed[indexedIndex++];\n                }\n              } else {\n                result[index] = resultNonIndexed[nonIndexedIndex++];\n              }\n\n              if (input.name) {\n                result[input.name] = result[index];\n              }\n            });\n            result.length = method.inputs.length;\n            return result;\n          };\n\n          var func = populateDescription(new EventDescription(), result);\n          utils.defineFrozen(func, 'topics', [utils.keccak256(utils.toUtf8Bytes(signature))]);\n          utils.defineFrozen(func, 'inputs', inputParams);\n          return func;\n        }(); // Expose the first (and hopefully unique) event name\n\n\n        if (method.name && events[method.name] == null) {\n          utils.defineProperty(events, method.name, func);\n        } // Expose all events by their signature, for overloaded functions\n\n\n        if (methods[func.signature] == null) {\n          utils.defineProperty(methods, func.signature, func);\n        }\n\n        break;\n\n      case 'fallback':\n        // Nothing to do for fallback\n        break;\n\n      default:\n        console.log('WARNING: unsupported ABI type - ' + method.type);\n        break;\n    }\n  }\n\n  ;\n\n  _abi.forEach(addMethod, this); // If there wasn't a constructor, create the default constructor\n\n\n  if (!deploy) {\n    addMethod({\n      type: 'constructor',\n      inputs: []\n    });\n  }\n\n  utils.defineProperty(this, 'deployFunction', deploy);\n}\n\nutils.defineProperty(Interface.prototype, 'parseTransaction', function (tx) {\n  var sighash = tx.data.substring(0, 10).toLowerCase();\n\n  for (var name in this.functions) {\n    if (name.indexOf('(') === -1) {\n      continue;\n    }\n\n    var func = this.functions[name];\n\n    if (func.sighash === sighash) {\n      var result = utils.coder.decode(func.inputs.types, '0x' + tx.data.substring(10));\n      return {\n        args: result,\n        signature: func.signature,\n        sighash: func.sighash,\n        parse: func.parseResult,\n        value: tx.value\n      };\n    }\n  }\n\n  return null;\n});\nmodule.exports = Interface;","map":null,"metadata":{},"sourceType":"script"}