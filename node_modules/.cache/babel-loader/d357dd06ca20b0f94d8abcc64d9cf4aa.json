{"ast":null,"code":"'use strict';\n\nvar debug = require('debug');\n\nvar promisify = require('promisify-es6');\n\nvar waterfall = require('async/waterfall');\n\nvar parallel = require('async/parallel');\n\nvar human = require('human-to-milliseconds');\n\nvar crypto = require('libp2p-crypto');\n\nvar errcode = require('err-code');\n\nvar log = debug('jsipfs:name');\nlog.error = debug('jsipfs:name:error');\n\nvar utils = require('../utils');\n\nvar path = require('../ipns/path');\n\nvar keyLookup = function keyLookup(ipfsNode, kname, callback) {\n  if (kname === 'self') {\n    return callback(null, ipfsNode._peerInfo.id.privKey);\n  }\n\n  var pass = ipfsNode._options.pass;\n  waterfall([function (cb) {\n    return ipfsNode._keychain.exportKey(kname, pass, cb);\n  }, function (pem, cb) {\n    return crypto.keys.import(pem, pass, cb);\n  }], function (err, privateKey) {\n    if (err) {\n      log.error(err);\n      return callback(errcode(err, 'ERR_CANNOT_GET_KEY'));\n    }\n\n    return callback(null, privateKey);\n  });\n};\n\nmodule.exports = function name(self) {\n  return {\n    /**\n     * IPNS is a PKI namespace, where names are the hashes of public keys, and\n     * the private key enables publishing new (signed) values. In both publish\n     * and resolve, the default name used is the node's own PeerID,\n     * which is the hash of its public key.\n     *\n     * @param {String} value ipfs path of the object to be published.\n     * @param {Object} options ipfs publish options.\n     * @param {boolean} options.resolve resolve given path before publishing.\n     * @param {String} options.lifetime time duration that the record will be valid for.\n    This accepts durations such as \"300s\", \"1.5h\" or \"2h45m\". Valid time units are\n    \"ns\", \"ms\", \"s\", \"m\", \"h\". Default is 24h.\n     * @param {String} options.ttl time duration this record should be cached for (NOT IMPLEMENTED YET).\n     * This accepts durations such as \"300s\", \"1.5h\" or \"2h45m\". Valid time units are\n     \"ns\", \"ms\", \"s\", \"m\", \"h\" (caution: experimental).\n     * @param {String} options.key name of the key to be used or a valid PeerID, as listed by 'ipfs key list -l'.\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    publish: promisify(function (value, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      var resolve = !(options.resolve === false);\n      var lifetime = options.lifetime || '24h';\n      var key = options.key || 'self';\n\n      if (!self.isOnline()) {\n        var errMsg = utils.OFFLINE_ERROR;\n        log.error(errMsg);\n        return callback(errcode(errMsg, 'OFFLINE_ERROR'));\n      } // TODO: params related logic should be in the core implementation\n      // Normalize path value\n\n\n      try {\n        value = utils.normalizePath(value);\n      } catch (err) {\n        log.error(err);\n        return callback(err);\n      }\n\n      parallel([function (cb) {\n        return human(lifetime, cb);\n      }, // (cb) => ttl ? human(ttl, cb) : cb(),\n      function (cb) {\n        return keyLookup(self, key, cb);\n      }, // verify if the path exists, if not, an error will stop the execution\n      function (cb) {\n        return resolve.toString() === 'true' ? path.resolvePath(self, value, cb) : cb();\n      }], function (err, results) {\n        if (err) {\n          log.error(err);\n          return callback(err);\n        } // Calculate lifetime with nanoseconds precision\n\n\n        var pubLifetime = results[0].toFixed(6);\n        var privateKey = results[1]; // TODO IMPROVEMENT - Handle ttl for cache\n        // const ttl = results[1]\n        // const privateKey = results[2]\n        // Start publishing process\n\n        self._ipns.publish(privateKey, value, pubLifetime, callback);\n      });\n    }),\n\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {String} name ipns name to resolve. Defaults to your node's peerID.\n     * @param {Object} options ipfs resolve options.\n     * @param {boolean} options.nocache do not use cached entries.\n     * @param {boolean} options.recursive resolve until the result is not an IPNS name.\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    resolve: promisify(function (name, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      var nocache = options.nocache && options.nocache.toString() === 'true';\n      var recursive = options.recursive && options.recursive.toString() === 'true';\n      var local = true; // TODO ROUTING - use self._options.local\n\n      if (!self.isOnline() && !local) {\n        var errMsg = utils.OFFLINE_ERROR;\n        log.error(errMsg);\n        return callback(errcode(errMsg, 'OFFLINE_ERROR'));\n      } // TODO: params related logic should be in the core implementation\n\n\n      if (local && nocache) {\n        var error = 'cannot specify both local and nocache';\n        log.error(error);\n        return callback(errcode(new Error(error), 'ERR_NOCACHE_AND_LOCAL'));\n      } // Set node id as name for being resolved, if it is not received\n\n\n      if (!name) {\n        name = self._peerInfo.id.toB58String();\n      }\n\n      if (!name.startsWith('/ipns/')) {\n        name = \"/ipns/\".concat(name);\n      }\n\n      var resolveOptions = {\n        nocache: nocache,\n        recursive: recursive,\n        local: local\n      };\n\n      self._ipns.resolve(name, self._peerInfo.id, resolveOptions, callback);\n    })\n  };\n};","map":null,"metadata":{},"sourceType":"script"}