{"ast":null,"code":"'use strict';\n\nvar UnixFS = require('ipfs-unixfs');\n\nvar pull = require('pull-stream');\n\nvar paramap = require('pull-paramap');\n\nvar CID = require('cids');\n\nvar resolvers = {\n  directory: require('./dir-flat'),\n  'hamt-sharded-directory': require('./dir-hamt-sharded'),\n  file: require('./file'),\n  object: require('./object'),\n  raw: require('./raw')\n};\nmodule.exports = Object.assign({\n  createResolver: createResolver,\n  typeOf: typeOf\n}, resolvers);\n\nfunction createResolver(dag, options, depth, parent) {\n  if (!depth) {\n    depth = 0;\n  }\n\n  if (depth > options.maxDepth) {\n    return pull.map(identity);\n  }\n\n  return pull(paramap(function (item, cb) {\n    if (typeof item.depth !== 'number') {\n      return pull.error(new Error('no depth'));\n    }\n\n    if (item.object) {\n      return cb(null, resolveItem(null, item.object, item, options.offset, options.length));\n    }\n\n    var cid = new CID(item.multihash);\n    dag.get(cid, function (err, node) {\n      if (err) {\n        return cb(err);\n      } // const name = item.fromPathRest ? item.name : item.path\n\n\n      cb(null, resolveItem(cid, node.value, item, options.offset, options.length));\n    });\n  }), pull.flatten(), pull.filter(Boolean), pull.filter(function (node) {\n    return node.depth <= options.maxDepth;\n  }));\n\n  function resolveItem(cid, node, item, offset, length) {\n    return resolve(cid, node, item.name, item.path, item.pathRest, item.size, dag, item.parent || parent, item.depth, offset, length);\n  }\n\n  function resolve(cid, node, name, path, pathRest, size, dag, parentNode, depth, offset, length) {\n    var type;\n\n    try {\n      type = typeOf(node);\n    } catch (error) {\n      return pull.error(error);\n    }\n\n    var nodeResolver = resolvers[type];\n\n    if (!nodeResolver) {\n      return pull.error(new Error('Unkown node type ' + type));\n    }\n\n    var resolveDeep = createResolver(dag, options, depth, node);\n    return nodeResolver(cid, node, name, path, pathRest, resolveDeep, size, dag, parentNode, depth, offset, length);\n  }\n}\n\nfunction typeOf(node) {\n  if (Buffer.isBuffer(node)) {\n    return 'raw';\n  } else if (Buffer.isBuffer(node.data)) {\n    return UnixFS.unmarshal(node.data).type;\n  } else {\n    return 'object';\n  }\n}\n\nfunction identity(o) {\n  return o;\n}","map":null,"metadata":{},"sourceType":"script"}