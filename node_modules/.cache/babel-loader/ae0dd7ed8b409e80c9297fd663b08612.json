{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils_1 = require(\"./utils\"); // The default Buffer size if one is not provided.\n\n\nvar DEFAULT_SMARTBUFFER_SIZE = 4096; // The default string encoding to use for reading/writing strings.\n\nvar DEFAULT_SMARTBUFFER_ENCODING = 'utf8';\n\nvar SmartBuffer =\n/*#__PURE__*/\nfunction () {\n  /**\n     * Creates a new SmartBuffer instance.\n     *\n     * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.\n     */\n  function SmartBuffer(options) {\n    _classCallCheck(this, SmartBuffer);\n\n    this.length = 0;\n    this._encoding = DEFAULT_SMARTBUFFER_ENCODING;\n    this._writeOffset = 0;\n    this._readOffset = 0;\n\n    if (SmartBuffer.isSmartBufferOptions(options)) {\n      // Checks for encoding\n      if (options.encoding) {\n        utils_1.checkEncoding(options.encoding);\n        this._encoding = options.encoding;\n      } // Checks for initial size length\n\n\n      if (options.size) {\n        if (utils_1.isFiniteInteger(options.size) && options.size > 0) {\n          this._buff = Buffer.allocUnsafe(options.size);\n        } else {\n          throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);\n        } // Check for initial Buffer\n\n      } else if (options.buff) {\n        if (options.buff instanceof Buffer) {\n          this._buff = options.buff;\n          this.length = options.buff.length;\n        } else {\n          throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);\n        }\n      } else {\n        this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n      }\n    } else {\n      // If something was passed but it's not a SmartBufferOptions object\n      if (typeof options !== 'undefined') {\n        throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);\n      } // Otherwise default to sane options\n\n\n      this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n    }\n  }\n  /**\n     * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.\n     *\n     * @param size { Number } The size of the internal Buffer.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */\n\n\n  _createClass(SmartBuffer, [{\n    key: \"readInt8\",\n    // Signed integers\n\n    /**\n       * Reads an Int8 value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n    value: function readInt8(offset) {\n      return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);\n    }\n    /**\n       * Reads an Int16BE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n\n  }, {\n    key: \"readInt16BE\",\n    value: function readInt16BE(offset) {\n      return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);\n    }\n    /**\n       * Reads an Int16LE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n\n  }, {\n    key: \"readInt16LE\",\n    value: function readInt16LE(offset) {\n      return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);\n    }\n    /**\n       * Reads an Int32BE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n\n  }, {\n    key: \"readInt32BE\",\n    value: function readInt32BE(offset) {\n      return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);\n    }\n    /**\n       * Reads an Int32LE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n\n  }, {\n    key: \"readInt32LE\",\n    value: function readInt32LE(offset) {\n      return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);\n    }\n    /**\n       * Writes an Int8 value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"writeInt8\",\n    value: function writeInt8(value, offset) {\n      this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n\n      return this;\n    }\n    /**\n       * Inserts an Int8 value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"insertInt8\",\n    value: function insertInt8(value, offset) {\n      this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n\n      return this;\n    }\n    /**\n       * Writes an Int16BE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"writeInt16BE\",\n    value: function writeInt16BE(value, offset) {\n      this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n\n      return this;\n    }\n    /**\n       * Inserts an Int16BE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"insertInt16BE\",\n    value: function insertInt16BE(value, offset) {\n      this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n\n      return this;\n    }\n    /**\n       * Writes an Int16LE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"writeInt16LE\",\n    value: function writeInt16LE(value, offset) {\n      this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n\n      return this;\n    }\n    /**\n       * Inserts an Int16LE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"insertInt16LE\",\n    value: function insertInt16LE(value, offset) {\n      this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n\n      return this;\n    }\n    /**\n       * Writes an Int32BE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"writeInt32BE\",\n    value: function writeInt32BE(value, offset) {\n      this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n\n      return this;\n    }\n    /**\n       * Inserts an Int32BE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"insertInt32BE\",\n    value: function insertInt32BE(value, offset) {\n      this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n\n      return this;\n    }\n    /**\n       * Writes an Int32LE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"writeInt32LE\",\n    value: function writeInt32LE(value, offset) {\n      this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n\n      return this;\n    }\n    /**\n       * Inserts an Int32LE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"insertInt32LE\",\n    value: function insertInt32LE(value, offset) {\n      this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n\n      return this;\n    } // Unsigned Integers\n\n    /**\n       * Reads an UInt8 value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n\n  }, {\n    key: \"readUInt8\",\n    value: function readUInt8(offset) {\n      return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);\n    }\n    /**\n       * Reads an UInt16BE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n\n  }, {\n    key: \"readUInt16BE\",\n    value: function readUInt16BE(offset) {\n      return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);\n    }\n    /**\n       * Reads an UInt16LE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n\n  }, {\n    key: \"readUInt16LE\",\n    value: function readUInt16LE(offset) {\n      return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);\n    }\n    /**\n       * Reads an UInt32BE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n\n  }, {\n    key: \"readUInt32BE\",\n    value: function readUInt32BE(offset) {\n      return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);\n    }\n    /**\n       * Reads an UInt32LE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n\n  }, {\n    key: \"readUInt32LE\",\n    value: function readUInt32LE(offset) {\n      return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);\n    }\n    /**\n       * Writes an UInt8 value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"writeUInt8\",\n    value: function writeUInt8(value, offset) {\n      this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n\n      return this;\n    }\n    /**\n       * Inserts an UInt8 value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"insertUInt8\",\n    value: function insertUInt8(value, offset) {\n      this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n\n      return this;\n    }\n    /**\n       * Writes an UInt16BE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"writeUInt16BE\",\n    value: function writeUInt16BE(value, offset) {\n      this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n\n      return this;\n    }\n    /**\n       * Inserts an UInt16BE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"insertUInt16BE\",\n    value: function insertUInt16BE(value, offset) {\n      this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n\n      return this;\n    }\n    /**\n       * Writes an UInt16LE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"writeUInt16LE\",\n    value: function writeUInt16LE(value, offset) {\n      this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n\n      return this;\n    }\n    /**\n       * Inserts an UInt16LE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"insertUInt16LE\",\n    value: function insertUInt16LE(value, offset) {\n      this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n\n      return this;\n    }\n    /**\n       * Writes an UInt32BE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"writeUInt32BE\",\n    value: function writeUInt32BE(value, offset) {\n      this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n\n      return this;\n    }\n    /**\n       * Inserts an UInt32BE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"insertUInt32BE\",\n    value: function insertUInt32BE(value, offset) {\n      this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n\n      return this;\n    }\n    /**\n       * Writes an UInt32LE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"writeUInt32LE\",\n    value: function writeUInt32LE(value, offset) {\n      this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n\n      return this;\n    }\n    /**\n       * Inserts an UInt32LE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"insertUInt32LE\",\n    value: function insertUInt32LE(value, offset) {\n      this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n\n      return this;\n    } // Floating Point\n\n    /**\n       * Reads an FloatBE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n\n  }, {\n    key: \"readFloatBE\",\n    value: function readFloatBE(offset) {\n      return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);\n    }\n    /**\n       * Reads an FloatLE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n\n  }, {\n    key: \"readFloatLE\",\n    value: function readFloatLE(offset) {\n      return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);\n    }\n    /**\n       * Writes a FloatBE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"writeFloatBE\",\n    value: function writeFloatBE(value, offset) {\n      this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n\n      return this;\n    }\n    /**\n       * Inserts a FloatBE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"insertFloatBE\",\n    value: function insertFloatBE(value, offset) {\n      this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n\n      return this;\n    }\n    /**\n       * Writes a FloatLE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"writeFloatLE\",\n    value: function writeFloatLE(value, offset) {\n      this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n\n      return this;\n    }\n    /**\n       * Inserts a FloatLE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"insertFloatLE\",\n    value: function insertFloatLE(value, offset) {\n      this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n\n      return this;\n    } // Double Floating Point\n\n    /**\n       * Reads an DoublEBE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n\n  }, {\n    key: \"readDoubleBE\",\n    value: function readDoubleBE(offset) {\n      return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);\n    }\n    /**\n       * Reads an DoubleLE value from the current read position or an optionally provided offset.\n       *\n       * @param offset { Number } The offset to read data from (optional)\n       * @return { Number }\n       */\n\n  }, {\n    key: \"readDoubleLE\",\n    value: function readDoubleLE(offset) {\n      return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);\n    }\n    /**\n       * Writes a DoubleBE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"writeDoubleBE\",\n    value: function writeDoubleBE(value, offset) {\n      this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n\n      return this;\n    }\n    /**\n       * Inserts a DoubleBE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"insertDoubleBE\",\n    value: function insertDoubleBE(value, offset) {\n      this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n\n      return this;\n    }\n    /**\n       * Writes a DoubleLE value to the current write position (or at optional offset).\n       *\n       * @param value { Number } The value to write.\n       * @param offset { Number } The offset to write the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"writeDoubleLE\",\n    value: function writeDoubleLE(value, offset) {\n      this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n\n      return this;\n    }\n    /**\n       * Inserts a DoubleLE value at the given offset value.\n       *\n       * @param value { Number } The value to insert.\n       * @param offset { Number } The offset to insert the value at.\n       *\n       * @return this\n       */\n\n  }, {\n    key: \"insertDoubleLE\",\n    value: function insertDoubleLE(value, offset) {\n      this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n\n      return this;\n    } // Strings\n\n    /**\n       * Reads a String from the current read position.\n       *\n       * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for\n       *             the string (Defaults to instance level encoding).\n       * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n       *\n       * @return { String }\n       */\n\n  }, {\n    key: \"readString\",\n    value: function readString(arg1, encoding) {\n      var lengthVal; // Length provided\n\n      if (typeof arg1 === 'number') {\n        utils_1.checkLengthValue(arg1);\n        lengthVal = Math.min(arg1, this.length - this._readOffset);\n      } else {\n        encoding = arg1;\n        lengthVal = this.length - this._readOffset;\n      } // Check encoding\n\n\n      if (typeof encoding !== 'undefined') {\n        utils_1.checkEncoding(encoding);\n      }\n\n      var value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);\n\n      this._readOffset += lengthVal;\n      return value;\n    }\n    /**\n       * Inserts a String\n       *\n       * @param value { String } The String value to insert.\n       * @param offset { Number } The offset to insert the string at.\n       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n       */\n\n  }, {\n    key: \"insertString\",\n    value: function insertString(value, offset, encoding) {\n      utils_1.checkOffsetValue(offset);\n      return this._handleString(value, true, offset, encoding);\n    }\n    /**\n       * Writes a String\n       *\n       * @param value { String } The String value to write.\n       * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.\n       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n       */\n\n  }, {\n    key: \"writeString\",\n    value: function writeString(value, arg2, encoding) {\n      return this._handleString(value, false, arg2, encoding);\n    }\n    /**\n       * Reads a null-terminated String from the current read position.\n       *\n       * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n       *\n       * @return { String }\n       */\n\n  }, {\n    key: \"readStringNT\",\n    value: function readStringNT(encoding) {\n      if (typeof encoding !== 'undefined') {\n        utils_1.checkEncoding(encoding);\n      } // Set null character position to the end SmartBuffer instance.\n\n\n      var nullPos = this.length; // Find next null character (if one is not found, default from above is used)\n\n      for (var i = this._readOffset; i < this.length; i++) {\n        if (this._buff[i] === 0x00) {\n          nullPos = i;\n          break;\n        }\n      } // Read string value\n\n\n      var value = this._buff.slice(this._readOffset, nullPos); // Increment internal Buffer read offset\n\n\n      this._readOffset = nullPos + 1;\n      return value.toString(encoding || this._encoding);\n    }\n    /**\n       * Inserts a null-terminated String.\n       *\n       * @param value { String } The String value to write.\n       * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n       */\n\n  }, {\n    key: \"insertStringNT\",\n    value: function insertStringNT(value, offset, encoding) {\n      utils_1.checkOffsetValue(offset); // Write Values\n\n      this.insertString(value, offset, encoding);\n      this.insertUInt8(0x00, offset + value.length);\n    }\n    /**\n       * Writes a null-terminated String.\n       *\n       * @param value { String } The String value to write.\n       * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n       */\n\n  }, {\n    key: \"writeStringNT\",\n    value: function writeStringNT(value, arg2, encoding) {\n      // Write Values\n      this.writeString(value, arg2, encoding);\n      this.writeUInt8(0x00, typeof arg2 === 'number' ? arg2 + value.length : this.writeOffset);\n    } // Buffers\n\n    /**\n       * Reads a Buffer from the internal read position.\n       *\n       * @param length { Number } The length of data to read as a Buffer.\n       *\n       * @return { Buffer }\n       */\n\n  }, {\n    key: \"readBuffer\",\n    value: function readBuffer(length) {\n      if (typeof length !== 'undefined') {\n        utils_1.checkLengthValue(length);\n      }\n\n      var lengthVal = typeof length === 'number' ? length : this.length;\n      var endPoint = Math.min(this.length, this._readOffset + lengthVal); // Read buffer value\n\n      var value = this._buff.slice(this._readOffset, endPoint); // Increment internal Buffer read offset\n\n\n      this._readOffset = endPoint;\n      return value;\n    }\n    /**\n       * Writes a Buffer to the current write position.\n       *\n       * @param value { Buffer } The Buffer to write.\n       * @param offset { Number } The offset to write the Buffer to.\n       */\n\n  }, {\n    key: \"insertBuffer\",\n    value: function insertBuffer(value, offset) {\n      utils_1.checkOffsetValue(offset);\n      return this._handleBuffer(value, true, offset);\n    }\n    /**\n       * Writes a Buffer to the current write position.\n       *\n       * @param value { Buffer } The Buffer to write.\n       * @param offset { Number } The offset to write the Buffer to.\n       */\n\n  }, {\n    key: \"writeBuffer\",\n    value: function writeBuffer(value, offset) {\n      return this._handleBuffer(value, false, offset);\n    }\n    /**\n       * Reads a null-terminated Buffer from the current read poisiton.\n       *\n       * @return { Buffer }\n       */\n\n  }, {\n    key: \"readBufferNT\",\n    value: function readBufferNT() {\n      // Set null character position to the end SmartBuffer instance.\n      var nullPos = this.length; // Find next null character (if one is not found, default from above is used)\n\n      for (var i = this._readOffset; i < this.length; i++) {\n        if (this._buff[i] === 0x00) {\n          nullPos = i;\n          break;\n        }\n      } // Read value\n\n\n      var value = this._buff.slice(this._readOffset, nullPos); // Increment internal Buffer read offset\n\n\n      this._readOffset = nullPos + 1;\n      return value;\n    }\n    /**\n       * Inserts a null-terminated Buffer.\n       *\n       * @param value { Buffer } The Buffer to write.\n       * @param offset { Number } The offset to write the Buffer to.\n       */\n\n  }, {\n    key: \"insertBufferNT\",\n    value: function insertBufferNT(value, offset) {\n      utils_1.checkOffsetValue(offset); // Write Values\n\n      this.insertBuffer(value, offset);\n      this.insertUInt8(0x00, offset + value.length);\n      return this;\n    }\n    /**\n       * Writes a null-terminated Buffer.\n       *\n       * @param value { Buffer } The Buffer to write.\n       * @param offset { Number } The offset to write the Buffer to.\n       */\n\n  }, {\n    key: \"writeBufferNT\",\n    value: function writeBufferNT(value, offset) {\n      // Checks for valid numberic value;\n      if (typeof offset !== 'undefined') {\n        utils_1.checkOffsetValue(offset);\n      } // Write Values\n\n\n      this.writeBuffer(value, offset);\n      this.writeUInt8(0x00, typeof offset === 'number' ? offset + value.length : this._writeOffset);\n      return this;\n    }\n    /**\n       * Clears the SmartBuffer instance to its original empty state.\n       */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._writeOffset = 0;\n      this._readOffset = 0;\n      this.length = 0;\n      return this;\n    }\n    /**\n       * Gets the remaining data left to be read from the SmartBuffer instance.\n       *\n       * @return { Number }\n       */\n\n  }, {\n    key: \"remaining\",\n    value: function remaining() {\n      return this.length - this._readOffset;\n    }\n    /**\n       * Gets the current read offset value of the SmartBuffer instance.\n       *\n       * @return { Number }\n       */\n\n  }, {\n    key: \"toBuffer\",\n\n    /**\n       * Gets the value of the internal managed Buffer (Includes managed data only)\n       *\n       * @param { Buffer }\n       */\n    value: function toBuffer() {\n      return this._buff.slice(0, this.length);\n    }\n    /**\n       * Gets the String value of the internal managed Buffer\n       *\n       * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).\n       */\n\n  }, {\n    key: \"toString\",\n    value: function toString(encoding) {\n      var encodingVal = typeof encoding === 'string' ? encoding : this._encoding; // Check for invalid encoding.\n\n      utils_1.checkEncoding(encodingVal);\n      return this._buff.toString(encodingVal, 0, this.length);\n    }\n    /**\n       * Destroys the SmartBuffer instance.\n       */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.clear();\n      return this;\n    }\n    /**\n       * Handles inserting and writing strings.\n       *\n       * @param value { String } The String value to insert.\n       * @param isInsert { Boolean } True if inserting a string, false if writing.\n       * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.\n       * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n       */\n\n  }, {\n    key: \"_handleString\",\n    value: function _handleString(value, isInsert, arg3, encoding) {\n      var offsetVal = this._writeOffset;\n      var encodingVal = this._encoding; // Check for offset\n\n      if (typeof arg3 === 'number') {\n        offsetVal = arg3; // Check for encoding\n      } else if (typeof arg3 === 'string') {\n        utils_1.checkEncoding(arg3);\n        encodingVal = arg3;\n      } // Check for encoding (third param)\n\n\n      if (typeof encoding === 'string') {\n        utils_1.checkEncoding(encoding);\n        encodingVal = encoding;\n      } // Calculate bytelength of string.\n\n\n      var byteLength = Buffer.byteLength(value, encodingVal); // Ensure there is enough internal Buffer capacity.\n\n      if (isInsert) {\n        this.ensureInsertable(byteLength, offsetVal);\n      } else {\n        this._ensureWriteable(byteLength, offsetVal);\n      } // Write value\n\n\n      this._buff.write(value, offsetVal, byteLength, encodingVal); // Increment internal Buffer write offset;\n\n\n      if (isInsert) {\n        this._writeOffset += byteLength;\n      } else {\n        // If an offset was given, check to see if we wrote beyond the current writeOffset.\n        if (typeof arg3 === 'number') {\n          this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);\n        } else {\n          // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n          this._writeOffset += byteLength;\n        }\n      }\n\n      return this;\n    }\n    /**\n       * Handles writing or insert of a Buffer.\n       *\n       * @param value { Buffer } The Buffer to write.\n       * @param offset { Number } The offset to write the Buffer to.\n       */\n\n  }, {\n    key: \"_handleBuffer\",\n    value: function _handleBuffer(value, isInsert, offset) {\n      var offsetVal = typeof offset === 'number' ? offset : this._writeOffset; // Ensure there is enough internal Buffer capacity.\n\n      if (isInsert) {\n        this.ensureInsertable(value.length, offsetVal);\n      } else {\n        this._ensureWriteable(value.length, offsetVal);\n      } // Write buffer value\n\n\n      value.copy(this._buff, offsetVal); // Increment internal Buffer write offset;\n\n      if (isInsert) {\n        this._writeOffset += value.length;\n      } else {\n        // If an offset was given, check to see if we wrote beyond the current writeOffset.\n        if (typeof offset === 'number') {\n          this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);\n        } else {\n          // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n          this._writeOffset += value.length;\n        }\n      }\n\n      return this;\n    }\n    /**\n       * Ensures that the internal Buffer is large enough to read data.\n       *\n       * @param length { Number } The length of the data that needs to be read.\n       * @param offset { Number } The offset of the data that needs to be read.\n       */\n\n  }, {\n    key: \"ensureReadable\",\n    value: function ensureReadable(length, offset) {\n      // Offset value defaults to managed read offset.\n      var offsetVal = this._readOffset; // If an offset was provided, use it.\n\n      if (typeof offset !== 'undefined') {\n        // Checks for valid numberic value;\n        utils_1.checkOffsetValue(offset); // Overide with custom offset.\n\n        offsetVal = offset;\n      } // Checks if offset is below zero, or the offset+length offset is beyond the total length of the managed data.\n\n\n      if (offsetVal < 0 || offsetVal + length > this.length) {\n        throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);\n      }\n    }\n    /**\n       * Ensures that the internal Buffer is large enough to insert data.\n       *\n       * @param dataLength { Number } The length of the data that needs to be written.\n       * @param offset { Number } The offset of the data to be written.\n       */\n\n  }, {\n    key: \"ensureInsertable\",\n    value: function ensureInsertable(dataLength, offset) {\n      // Checks for valid numberic value;\n      utils_1.checkOffsetValue(offset); // Ensure there is enough internal Buffer capacity.\n\n      this._ensureCapacity(this.length + dataLength); // If an offset was provided and its not the very end of the buffer, copy data into appropriate location in regards to the offset.\n\n\n      if (offset < this.length) {\n        this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);\n      } // Adjust tracked smart buffer length\n\n\n      if (offset + dataLength > this.length) {\n        this.length = offset + dataLength;\n      } else {\n        this.length += dataLength;\n      }\n    }\n    /**\n       * Ensures that the internal Buffer is large enough to write data.\n       *\n       * @param dataLength { Number } The length of the data that needs to be written.\n       * @param offset { Number } The offset of the data to be written (defaults to writeOffset).\n       */\n\n  }, {\n    key: \"_ensureWriteable\",\n    value: function _ensureWriteable(dataLength, offset) {\n      var offsetVal = typeof offset === 'number' ? offset : this._writeOffset; // Ensure enough capacity to write data.\n\n      this._ensureCapacity(offsetVal + dataLength); // Adjust SmartBuffer length (if offset + length is larger than managed length, adjust length)\n\n\n      if (offsetVal + dataLength > this.length) {\n        this.length = offsetVal + dataLength;\n      }\n    }\n    /**\n       * Ensures that the internal Buffer is large enough to write at least the given amount of data.\n       *\n       * @param minLength { Number } The minimum length of the data needs to be written.\n       */\n\n  }, {\n    key: \"_ensureCapacity\",\n    value: function _ensureCapacity(minLength) {\n      var oldLength = this._buff.length;\n\n      if (minLength > oldLength) {\n        var data = this._buff;\n        var newLength = oldLength * 3 / 2 + 1;\n\n        if (newLength < minLength) {\n          newLength = minLength;\n        }\n\n        this._buff = Buffer.allocUnsafe(newLength);\n        data.copy(this._buff, 0, 0, oldLength);\n      }\n    }\n    /**\n       * Reads a numeric number value using the provided function.\n       *\n       * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.\n       * @param byteSize { Number } The number of bytes read.\n       * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.\n       *\n       * @param { Number }\n       */\n\n  }, {\n    key: \"_readNumberValue\",\n    value: function _readNumberValue(func, byteSize, offset) {\n      this.ensureReadable(byteSize, offset); // Call Buffer.readXXXX();\n\n      var value = func.call(this._buff, typeof offset === 'number' ? offset : this._readOffset); // Adjust internal read offset if an optional read offset was not provided.\n\n      if (typeof offset === 'undefined') {\n        this._readOffset += byteSize;\n      }\n\n      return value;\n    }\n    /**\n       * Inserts a numeric number value based on the given offset and value.\n       *\n       * @param func { Function(offset: number, offset?) => number} The function to write data on the internal Buffer with.\n       * @param byteSize { Number } The number of bytes written.\n       * @param value { Number } The number value to write.\n       * @param offset { Number } the offset to write the number at (REQUIRED).\n       *\n       */\n\n  }, {\n    key: \"_insertNumberValue\",\n    value: function _insertNumberValue(func, byteSize, value, offset) {\n      // Check for invalid offset values.\n      utils_1.checkOffsetValue(offset); // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n\n      this.ensureInsertable(byteSize, offset); // Call buffer.writeXXXX();\n\n      func.call(this._buff, value, offset); // Adjusts internally managed write offset.\n\n      this._writeOffset += byteSize;\n    }\n    /**\n       * Writes a numeric number value based on the given offset and value.\n       *\n       * @param func { Function(offset: number, offset?) => number} The function to write data on the internal Buffer with.\n       * @param byteSize { Number } The number of bytes written.\n       * @param value { Number } The number value to write.\n       * @param offset { Number } the offset to write the number at (REQUIRED).\n       *\n       */\n\n  }, {\n    key: \"_writeNumberValue\",\n    value: function _writeNumberValue(func, byteSize, value, offset) {\n      // If an offset was provided, validate it.\n      if (typeof offset === 'number') {\n        // Check if we're writing beyond the bounds of the managed data.\n        if (offset < 0) {\n          throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);\n        }\n\n        utils_1.checkOffsetValue(offset);\n      } // Default to writeOffset if no offset value was given.\n\n\n      var offsetVal = typeof offset === 'number' ? offset : this._writeOffset; // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n\n      this._ensureWriteable(byteSize, offsetVal);\n\n      func.call(this._buff, value, offsetVal); // If an offset was given, check to see if we wrote beyond the current writeOffset.\n\n      if (typeof offset === 'number') {\n        this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);\n      } else {\n        // If no numeric offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n        this._writeOffset += byteSize;\n      }\n    }\n  }, {\n    key: \"readOffset\",\n    get: function get() {\n      return this._readOffset;\n    }\n    /**\n       * Sets the read offset value of the SmartBuffer instance.\n       *\n       * @param offset { Number } - The offset value to set.\n       */\n    ,\n    set: function set(offset) {\n      utils_1.checkOffsetValue(offset); // Check for bounds.\n\n      utils_1.checkTargetOffset(offset, this);\n      this._readOffset = offset;\n    }\n    /**\n       * Gets the current write offset value of the SmartBuffer instance.\n       *\n       * @return { Number }\n       */\n\n  }, {\n    key: \"writeOffset\",\n    get: function get() {\n      return this._writeOffset;\n    }\n    /**\n       * Sets the write offset value of the SmartBuffer instance.\n       *\n       * @param offset { Number } - The offset value to set.\n       */\n    ,\n    set: function set(offset) {\n      utils_1.checkOffsetValue(offset); // Check for bounds.\n\n      utils_1.checkTargetOffset(offset, this);\n      this._writeOffset = offset;\n    }\n    /**\n       * Gets the currently set string encoding of the SmartBuffer instance.\n       *\n       * @return { BufferEncoding } The string Buffer encoding currently set.\n       */\n\n  }, {\n    key: \"encoding\",\n    get: function get() {\n      return this._encoding;\n    }\n    /**\n       * Sets the string encoding of the SmartBuffer instance.\n       *\n       * @param encoding { BufferEncoding } The string Buffer encoding to set.\n       */\n    ,\n    set: function set(encoding) {\n      utils_1.checkEncoding(encoding);\n      this._encoding = encoding;\n    }\n    /**\n       * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)\n       *\n       * @return { Buffer } The Buffer value.\n       */\n\n  }, {\n    key: \"internalBuffer\",\n    get: function get() {\n      return this._buff;\n    }\n  }], [{\n    key: \"fromSize\",\n    value: function fromSize(size, encoding) {\n      return new this({\n        size: size,\n        encoding: encoding\n      });\n    }\n    /**\n       * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.\n       *\n       * @param buffer { Buffer } The Buffer to use as the internal Buffer value.\n       * @param encoding { String } The BufferEncoding to use for strings.\n       *\n       * @return { SmartBuffer }\n       */\n\n  }, {\n    key: \"fromBuffer\",\n    value: function fromBuffer(buff, encoding) {\n      return new this({\n        buff: buff,\n        encoding: encoding\n      });\n    }\n    /**\n       * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.\n       *\n       * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.\n       */\n\n  }, {\n    key: \"fromOptions\",\n    value: function fromOptions(options) {\n      return new this(options);\n    }\n    /**\n       * Type checking function that determines if an object is a SmartBufferOptions object.\n       */\n\n  }, {\n    key: \"isSmartBufferOptions\",\n    value: function isSmartBufferOptions(options) {\n      var castOptions = options;\n      return castOptions && (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined);\n    }\n  }]);\n\n  return SmartBuffer;\n}();\n\nexports.SmartBuffer = SmartBuffer;","map":null,"metadata":{},"sourceType":"script"}