{"ast":null,"code":"'use strict'; // Port of lower_bound from http://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nfunction lowerBound(array, value, comp) {\n  var first = 0;\n  var count = array.length;\n\n  while (count > 0) {\n    var step = count / 2 | 0;\n    var it = first + step;\n\n    if (comp(array[it], value) <= 0) {\n      first = ++it;\n      count -= step + 1;\n    } else {\n      count = step;\n    }\n  }\n\n  return first;\n}\n\nvar PriorityQueue =\n/*#__PURE__*/\nfunction () {\n  function PriorityQueue() {\n    _classCallCheck(this, PriorityQueue);\n\n    this._queue = [];\n  }\n\n  _createClass(PriorityQueue, [{\n    key: \"enqueue\",\n    value: function enqueue(run, opts) {\n      opts = Object.assign({\n        priority: 0\n      }, opts);\n      var element = {\n        priority: opts.priority,\n        run: run\n      };\n\n      if (this.size && this._queue[this.size - 1].priority >= opts.priority) {\n        this._queue.push(element);\n\n        return;\n      }\n\n      var index = lowerBound(this._queue, element, function (a, b) {\n        return b.priority - a.priority;\n      });\n\n      this._queue.splice(index, 0, element);\n    }\n  }, {\n    key: \"dequeue\",\n    value: function dequeue() {\n      return this._queue.shift().run;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._queue.length;\n    }\n  }]);\n\n  return PriorityQueue;\n}();\n\nvar PQueue =\n/*#__PURE__*/\nfunction () {\n  function PQueue(opts) {\n    _classCallCheck(this, PQueue);\n\n    opts = Object.assign({\n      concurrency: Infinity,\n      autoStart: true,\n      queueClass: PriorityQueue\n    }, opts);\n\n    if (!(typeof opts.concurrency === 'number' && opts.concurrency >= 1)) {\n      throw new TypeError(\"Expected `concurrency` to be a number from 1 and up, got `\".concat(opts.concurrency, \"` (\").concat(typeof opts.concurrency, \")\"));\n    }\n\n    this.queue = new opts.queueClass(); // eslint-disable-line new-cap\n\n    this._queueClass = opts.queueClass;\n    this._pendingCount = 0;\n    this._concurrency = opts.concurrency;\n    this._isPaused = opts.autoStart === false;\n\n    this._resolveEmpty = function () {};\n\n    this._resolveIdle = function () {};\n  }\n\n  _createClass(PQueue, [{\n    key: \"_next\",\n    value: function _next() {\n      this._pendingCount--;\n\n      if (this.queue.size > 0) {\n        if (!this._isPaused) {\n          this.queue.dequeue()();\n        }\n      } else {\n        this._resolveEmpty();\n\n        this._resolveEmpty = function () {};\n\n        if (this._pendingCount === 0) {\n          this._resolveIdle();\n\n          this._resolveIdle = function () {};\n        }\n      }\n    }\n  }, {\n    key: \"add\",\n    value: function add(fn, opts) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        var run = function run() {\n          _this._pendingCount++;\n\n          try {\n            Promise.resolve(fn()).then(function (val) {\n              resolve(val);\n\n              _this._next();\n            }, function (err) {\n              reject(err);\n\n              _this._next();\n            });\n          } catch (err) {\n            reject(err);\n\n            _this._next();\n          }\n        };\n\n        if (!_this._isPaused && _this._pendingCount < _this._concurrency) {\n          run();\n        } else {\n          _this.queue.enqueue(run, opts);\n        }\n      });\n    }\n  }, {\n    key: \"addAll\",\n    value: function addAll(fns, opts) {\n      var _this2 = this;\n\n      return Promise.all(fns.map(function (fn) {\n        return _this2.add(fn, opts);\n      }));\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (!this._isPaused) {\n        return;\n      }\n\n      this._isPaused = false;\n\n      while (this.queue.size > 0 && this._pendingCount < this._concurrency) {\n        this.queue.dequeue()();\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this._isPaused = true;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.queue = new this._queueClass(); // eslint-disable-line new-cap\n    }\n  }, {\n    key: \"onEmpty\",\n    value: function onEmpty() {\n      var _this3 = this;\n\n      // Instantly resolve if the queue is empty\n      if (this.queue.size === 0) {\n        return Promise.resolve();\n      }\n\n      return new Promise(function (resolve) {\n        var existingResolve = _this3._resolveEmpty;\n\n        _this3._resolveEmpty = function () {\n          existingResolve();\n          resolve();\n        };\n      });\n    }\n  }, {\n    key: \"onIdle\",\n    value: function onIdle() {\n      var _this4 = this;\n\n      // Instantly resolve if none pending\n      if (this._pendingCount === 0) {\n        return Promise.resolve();\n      }\n\n      return new Promise(function (resolve) {\n        var existingResolve = _this4._resolveIdle;\n\n        _this4._resolveIdle = function () {\n          existingResolve();\n          resolve();\n        };\n      });\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.queue.size;\n    }\n  }, {\n    key: \"pending\",\n    get: function get() {\n      return this._pendingCount;\n    }\n  }, {\n    key: \"isPaused\",\n    get: function get() {\n      return this._isPaused;\n    }\n  }]);\n\n  return PQueue;\n}();\n\nmodule.exports = PQueue;","map":null,"metadata":{},"sourceType":"script"}