{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nvar _slicedToArray = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar promisify = require('promisify-es6');\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode,\n    DAGLink = _require.DAGLink;\n\nvar CID = require('cids');\n\nvar map = require('async/map');\n\nvar mapSeries = require('async/mapSeries');\n\nvar series = require('async/series');\n\nvar parallel = require('async/parallel');\n\nvar eachLimit = require('async/eachLimit');\n\nvar waterfall = require('async/waterfall');\n\nvar someLimit = require('async/someLimit');\n\nvar setImmediate = require('async/setImmediate');\n\nvar _require2 = require('interface-datastore'),\n    Key = _require2.Key;\n\nvar errCode = require('err-code');\n\nvar createPinSet = require('./pin-set');\n\nvar _require3 = require('../utils'),\n    resolvePath = _require3.resolvePath; // arbitrary limit to the number of concurrent dag operations\n\n\nvar concurrencyLimit = 300;\nvar pinDataStoreKey = new Key('/local/pins');\n\nfunction toB58String(hash) {\n  return new CID(hash).toBaseEncodedString();\n}\n\nfunction invalidPinTypeErr(type) {\n  var errMsg = \"Invalid type '\".concat(type, \"', must be one of {direct, indirect, recursive, all}\");\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE');\n}\n\nmodule.exports = function (self) {\n  var repo = self._repo;\n  var dag = self.dag;\n  var pinset = createPinSet(dag);\n  var types = {\n    direct: 'direct',\n    recursive: 'recursive',\n    indirect: 'indirect',\n    all: 'all'\n  };\n  var directPins = new Set();\n  var recursivePins = new Set();\n\n  var directKeys = function directKeys() {\n    return Array.from(directPins).map(function (key) {\n      return new CID(key).buffer;\n    });\n  };\n\n  var recursiveKeys = function recursiveKeys() {\n    return Array.from(recursivePins).map(function (key) {\n      return new CID(key).buffer;\n    });\n  };\n\n  function getIndirectKeys(callback) {\n    var indirectKeys = new Set();\n    eachLimit(recursiveKeys(), concurrencyLimit, function (multihash, cb) {\n      dag._getRecursive(multihash, function (err, nodes) {\n        if (err) {\n          return cb(err);\n        }\n\n        nodes.map(function (_ref) {\n          var multihash = _ref.multihash;\n          return toB58String(multihash);\n        }) // recursive pins pre-empt indirect pins\n        .filter(function (key) {\n          return !recursivePins.has(key);\n        }).forEach(function (key) {\n          return indirectKeys.add(key);\n        });\n        cb();\n      });\n    }, function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, Array.from(indirectKeys));\n    });\n  } // Encode and write pin key sets to the datastore:\n  // a DAGLink for each of the recursive and direct pinsets\n  // a DAGNode holding those as DAGLinks, a kind of root pin\n\n\n  function flushPins(callback) {\n    var dLink, rLink, root;\n    series([// create a DAGLink to the node with direct pins\n    function (cb) {\n      return waterfall([function (cb) {\n        return pinset.storeSet(directKeys(), cb);\n      }, function (node, cb) {\n        return DAGLink.create(types.direct, node.size, node.multihash, cb);\n      }, function (link, cb) {\n        dLink = link;\n        cb(null);\n      }], cb);\n    }, // create a DAGLink to the node with recursive pins\n    function (cb) {\n      return waterfall([function (cb) {\n        return pinset.storeSet(recursiveKeys(), cb);\n      }, function (node, cb) {\n        return DAGLink.create(types.recursive, node.size, node.multihash, cb);\n      }, function (link, cb) {\n        rLink = link;\n        cb(null);\n      }], cb);\n    }, // the pin-set nodes link to a special 'empty' node, so make sure it exists\n    function (cb) {\n      return DAGNode.create(Buffer.alloc(0), function (err, empty) {\n        if (err) {\n          return cb(err);\n        }\n\n        dag.put(empty, {\n          cid: new CID(empty.multihash),\n          preload: false\n        }, cb);\n      });\n    }, // create a root node with DAGLinks to the direct and recursive DAGs\n    function (cb) {\n      return DAGNode.create(Buffer.alloc(0), [dLink, rLink], function (err, node) {\n        if (err) {\n          return cb(err);\n        }\n\n        root = node;\n        dag.put(root, {\n          cid: new CID(root.multihash),\n          preload: false\n        }, cb);\n      });\n    }, // hack for CLI tests\n    function (cb) {\n      return repo.closed ? repo.open(cb) : cb(null, null);\n    }, // save root to datastore under a consistent key\n    function (cb) {\n      return repo.datastore.put(pinDataStoreKey, root.multihash, cb);\n    }], function (err, res) {\n      if (err) {\n        return callback(err);\n      }\n\n      self.log(\"Flushed pins with root: \".concat(root));\n      return callback(null, root);\n    });\n  }\n\n  var pin = {\n    add: promisify(function (paths, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      var recursive = options.recursive == null ? true : options.recursive;\n      resolvePath(self.object, paths, function (err, mhs) {\n        if (err) {\n          return callback(err);\n        } // verify that each hash can be pinned\n\n\n        map(mhs, function (multihash, cb) {\n          var key = toB58String(multihash);\n\n          if (recursive) {\n            if (recursivePins.has(key)) {\n              // it's already pinned recursively\n              return cb(null, key);\n            } // entire graph of nested links should be pinned,\n            // so make sure we have all the objects\n\n\n            dag._getRecursive(key, {\n              preload: options.preload\n            }, function (err) {\n              if (err) {\n                return cb(err);\n              } // found all objects, we can add the pin\n\n\n              return cb(null, key);\n            });\n          } else {\n            if (recursivePins.has(key)) {\n              // recursive supersedes direct, can't have both\n              return cb(new Error(\"\".concat(key, \" already pinned recursively\")));\n            }\n\n            if (directPins.has(key)) {\n              // already directly pinned\n              return cb(null, key);\n            } // make sure we have the object\n\n\n            dag.get(new CID(multihash), {\n              preload: options.preload\n            }, function (err) {\n              if (err) {\n                return cb(err);\n              } // found the object, we can add the pin\n\n\n              return cb(null, key);\n            });\n          }\n        }, function (err, results) {\n          if (err) {\n            return callback(err);\n          } // update the pin sets in memory\n\n\n          var pinset = recursive ? recursivePins : directPins;\n          results.forEach(function (key) {\n            return pinset.add(key);\n          }); // persist updated pin sets to datastore\n\n          flushPins(function (err, root) {\n            if (err) {\n              return callback(err);\n            }\n\n            return callback(null, results.map(function (hash) {\n              return {\n                hash: hash\n              };\n            }));\n          });\n        });\n      });\n    }),\n    rm: promisify(function (paths, options, callback) {\n      var recursive = true;\n\n      if (typeof options === 'function') {\n        callback = options;\n      } else if (options && options.recursive === false) {\n        recursive = false;\n      }\n\n      resolvePath(self.object, paths, function (err, mhs) {\n        if (err) {\n          return callback(err);\n        } // verify that each hash can be unpinned\n\n\n        map(mhs, function (multihash, cb) {\n          pin._isPinnedWithType(multihash, types.all, function (err, res) {\n            if (err) {\n              return cb(err);\n            }\n\n            var pinned = res.pinned,\n                reason = res.reason;\n            var key = toB58String(multihash);\n\n            if (!pinned) {\n              return cb(new Error(\"\".concat(key, \" is not pinned\")));\n            }\n\n            switch (reason) {\n              case types.recursive:\n                if (recursive) {\n                  return cb(null, key);\n                } else {\n                  return cb(new Error(\"\".concat(key, \" is pinned recursively\")));\n                }\n\n              case types.direct:\n                return cb(null, key);\n\n              default:\n                return cb(new Error(\"\".concat(key, \" is pinned indirectly under \").concat(reason)));\n            }\n          });\n        }, function (err, results) {\n          if (err) {\n            return callback(err);\n          } // update the pin sets in memory\n\n\n          results.forEach(function (key) {\n            if (recursive && recursivePins.has(key)) {\n              recursivePins.delete(key);\n            } else {\n              directPins.delete(key);\n            }\n          }); // persist updated pin sets to datastore\n\n          flushPins(function (err, root) {\n            if (err) {\n              return callback(err);\n            }\n\n            self.log(\"Removed pins: \".concat(results));\n            return callback(null, results.map(function (hash) {\n              return {\n                hash: hash\n              };\n            }));\n          });\n        });\n      });\n    }),\n    ls: promisify(function (paths, options, callback) {\n      var type = types.all;\n\n      if (typeof paths === 'function') {\n        callback = paths;\n        options = null;\n        paths = null;\n      }\n\n      if (typeof options === 'function') {\n        callback = options;\n      }\n\n      if (paths && paths.type) {\n        options = paths;\n        paths = null;\n      }\n\n      if (options && options.type) {\n        if (typeof options.type !== 'string') {\n          return setImmediate(function () {\n            return callback(invalidPinTypeErr(options.type));\n          });\n        }\n\n        type = options.type.toLowerCase();\n      }\n\n      if (!Object.keys(types).includes(type)) {\n        return setImmediate(function () {\n          return callback(invalidPinTypeErr(type));\n        });\n      }\n\n      if (paths) {\n        // check the pinned state of specific hashes\n        resolvePath(self.object, paths, function (err, mhs) {\n          if (err) {\n            return callback(err);\n          }\n\n          mapSeries(mhs, function (multihash, cb) {\n            pin._isPinnedWithType(multihash, types.all, function (err, res) {\n              if (err) {\n                return cb(err);\n              }\n\n              var pinned = res.pinned,\n                  reason = res.reason;\n              var key = toB58String(multihash);\n\n              if (!pinned) {\n                return cb(new Error(\"Path \".concat(key, \" is not pinned\")));\n              }\n\n              switch (reason) {\n                case types.direct:\n                case types.recursive:\n                  return cb(null, {\n                    hash: key,\n                    type: reason\n                  });\n\n                default:\n                  return cb(null, {\n                    hash: key,\n                    type: \"\".concat(types.indirect, \" through \").concat(reason)\n                  });\n              }\n            });\n          }, callback);\n        });\n      } else {\n        // show all pinned items of type\n        var pins = [];\n\n        if (type === types.direct || type === types.all) {\n          pins = pins.concat(Array.from(directPins).map(function (hash) {\n            return {\n              type: types.direct,\n              hash: hash\n            };\n          }));\n        }\n\n        if (type === types.recursive || type === types.all) {\n          pins = pins.concat(Array.from(recursivePins).map(function (hash) {\n            return {\n              type: types.recursive,\n              hash: hash\n            };\n          }));\n        }\n\n        if (type === types.indirect || type === types.all) {\n          getIndirectKeys(function (err, indirects) {\n            if (err) {\n              return callback(err);\n            }\n\n            pins = pins // if something is pinned both directly and indirectly,\n            // report the indirect entry\n            .filter(function (_ref2) {\n              var hash = _ref2.hash;\n              return !indirects.includes(hash) || indirects.includes(hash) && !directPins.has(hash);\n            }).concat(indirects.map(function (hash) {\n              return {\n                type: types.indirect,\n                hash: hash\n              };\n            }));\n            return callback(null, pins);\n          });\n        } else {\n          return callback(null, pins);\n        }\n      }\n    }),\n    _isPinnedWithType: promisify(function (multihash, type, callback) {\n      var key = toB58String(multihash);\n      var recursive = types.recursive,\n          direct = types.direct,\n          all = types.all; // recursive\n\n      if ((type === recursive || type === all) && recursivePins.has(key)) {\n        return callback(null, {\n          pinned: true,\n          reason: recursive\n        });\n      }\n\n      if (type === recursive) {\n        return callback(null, {\n          pinned: false\n        });\n      } // direct\n\n\n      if ((type === direct || type === all) && directPins.has(key)) {\n        return callback(null, {\n          pinned: true,\n          reason: direct\n        });\n      }\n\n      if (type === direct) {\n        return callback(null, {\n          pinned: false\n        });\n      } // indirect (default)\n      // check each recursive key to see if multihash is under it\n      // arbitrary limit, enables handling 1000s of pins.\n\n\n      var foundPin;\n      someLimit(recursiveKeys(), concurrencyLimit, function (key, cb) {\n        dag.get(new CID(key), function (err, res) {\n          if (err) {\n            return cb(err);\n          }\n\n          pinset.hasDescendant(res.value, multihash, function (err, has) {\n            if (has) {\n              foundPin = toB58String(res.value.multihash);\n            }\n\n            cb(err, has);\n          });\n        });\n      }, function (err, found) {\n        if (err) {\n          return callback(err);\n        }\n\n        return callback(null, {\n          pinned: found,\n          reason: foundPin\n        });\n      });\n    }),\n    _load: promisify(function (callback) {\n      waterfall([// hack for CLI tests\n      function (cb) {\n        return repo.closed ? repo.datastore.open(cb) : cb(null, null);\n      }, function (_, cb) {\n        return repo.datastore.has(pinDataStoreKey, cb);\n      }, function (has, cb) {\n        return has ? cb() : cb(new Error('No pins to load'));\n      }, function (cb) {\n        return repo.datastore.get(pinDataStoreKey, cb);\n      }, function (mh, cb) {\n        return dag.get(new CID(mh), '', {\n          preload: false\n        }, cb);\n      }], function (err, pinRoot) {\n        if (err) {\n          if (err.message === 'No pins to load') {\n            self.log('No pins to load');\n            return callback();\n          } else {\n            return callback(err);\n          }\n        }\n\n        parallel([function (cb) {\n          return pinset.loadSet(pinRoot.value, types.recursive, cb);\n        }, function (cb) {\n          return pinset.loadSet(pinRoot.value, types.direct, cb);\n        }], function (err, keys) {\n          if (err) {\n            return callback(err);\n          }\n\n          var _keys = _slicedToArray(keys, 2),\n              rKeys = _keys[0],\n              dKeys = _keys[1];\n\n          directPins = new Set(dKeys.map(toB58String));\n          recursivePins = new Set(rKeys.map(toB58String));\n          self.log('Loaded pins from the datastore');\n          return callback(null);\n        });\n      });\n    })\n  };\n  return pin;\n};","map":null,"metadata":{},"sourceType":"script"}