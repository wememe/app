{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar once = require('once');\n\nvar PeerId = require('peer-id');\n\nvar waterfall = require('async/waterfall');\n\nvar isFunction = require('lodash.isfunction');\n\nvar multiaddr = require('multiaddr');\n\nvar Connection = require('interface-connection').Connection;\n\nvar utilsFactory = require('./utils');\n\nvar StreamHandler = require('./stream-handler');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:circuit:dialer');\nlog.err = debug('libp2p:circuit:error:dialer');\n\nvar multicodec = require('../multicodec');\n\nvar proto = require('../protocol');\n\nvar Dialer =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Creates an instance of Dialer.\n   * @param {Swarm} swarm - the swarm\n   * @param {any} options - config options\n   *\n   * @memberOf Dialer\n   */\n  function Dialer(swarm, options) {\n    _classCallCheck(this, Dialer);\n\n    this.swarm = swarm;\n    this.relayPeers = new Map();\n    this.relayConns = new Map();\n    this.options = options;\n    this.utils = utilsFactory(swarm);\n  }\n  /**\n   * Helper that returns a relay connection\n   *\n   * @param {*} relay\n   * @param {*} callback\n   * @returns {Function} - callback\n   */\n\n\n  _createClass(Dialer, [{\n    key: \"_dialRelayHelper\",\n    value: function _dialRelayHelper(relay, callback) {\n      if (this.relayConns.has(relay.id.toB58String())) {\n        return callback(null, this.relayConns.get(relay.id.toB58String()));\n      }\n\n      return this._dialRelay(relay, callback);\n    }\n    /**\n     * Dial a peer over a relay\n     *\n     * @param {multiaddr} ma - the multiaddr of the peer to dial\n     * @param {Function} cb - a callback called once dialed\n     * @returns {Connection} - the connection\n     *\n     */\n\n  }, {\n    key: \"dial\",\n    value: function dial(ma, cb) {\n      cb = cb || function () {};\n\n      var strMa = ma.toString();\n\n      if (!strMa.includes('/p2p-circuit')) {\n        log.err('invalid circuit address');\n        return cb(new Error('invalid circuit address'));\n      }\n\n      var addr = strMa.split('p2p-circuit'); // extract relay address if any\n\n      var relay = addr[0] === '/' ? null : multiaddr(addr[0]);\n      var peer = multiaddr(addr[1] || addr[0]);\n      var dstConn = new Connection();\n      setImmediate(this._dialPeer.bind(this), peer, relay, function (err, conn) {\n        if (err) {\n          log.err(err);\n          return cb(err);\n        }\n\n        dstConn.setInnerConn(conn);\n        cb(null, dstConn);\n      });\n      return dstConn;\n    }\n    /**\n     * Does the peer support the HOP protocol\n     *\n     * @param {PeerInfo} peer\n     * @param {Function} callback\n     * @returns {*}\n     */\n\n  }, {\n    key: \"canHop\",\n    value: function canHop(peer, callback) {\n      var _this = this;\n\n      callback = once(callback || function () {});\n\n      this._dialRelayHelper(peer, function (err, conn) {\n        if (err) {\n          return callback(err);\n        }\n\n        var sh = new StreamHandler(conn);\n        waterfall([function (cb) {\n          return sh.write(proto.CircuitRelay.encode({\n            type: proto.CircuitRelay.Type.CAN_HOP\n          }), cb);\n        }, function (cb) {\n          return sh.read(cb);\n        }], function (err, msg) {\n          if (err) {\n            return callback(err);\n          }\n\n          var response = proto.CircuitRelay.decode(msg);\n\n          if (response.code !== proto.CircuitRelay.Status.SUCCESS) {\n            var _err = new Error(\"HOP not supported, skipping - \".concat(_this.utils.getB58String(peer)));\n\n            log(_err);\n            return callback(_err);\n          }\n\n          log(\"HOP supported adding as relay - \".concat(_this.utils.getB58String(peer)));\n\n          _this.relayPeers.set(_this.utils.getB58String(peer), peer);\n\n          sh.close();\n          callback();\n        });\n      });\n    }\n    /**\n     * Dial the destination peer over a relay\n     *\n     * @param {multiaddr} dstMa\n     * @param {Connection|PeerInfo} relay\n     * @param {Function} cb\n     * @return {Function|void}\n     * @private\n     */\n\n  }, {\n    key: \"_dialPeer\",\n    value: function _dialPeer(dstMa, relay, cb) {\n      var _this2 = this;\n\n      if (isFunction(relay)) {\n        cb = relay;\n        relay = null;\n      }\n\n      if (!cb) {\n        cb = function cb() {};\n      }\n\n      dstMa = multiaddr(dstMa); // if no relay provided, dial on all available relays until one succeeds\n\n      if (!relay) {\n        var relays = Array.from(this.relayPeers.values());\n\n        var next = function next(nextRelay) {\n          if (!nextRelay) {\n            var err = \"no relay peers were found or all relays failed to dial\";\n            log.err(err);\n            return cb(err);\n          }\n\n          return _this2._negotiateRelay(nextRelay, dstMa, function (err, conn) {\n            if (err) {\n              log.err(err);\n              return next(relays.shift());\n            }\n\n            cb(null, conn);\n          });\n        };\n\n        next(relays.shift());\n      } else {\n        return this._negotiateRelay(relay, dstMa, function (err, conn) {\n          if (err) {\n            log.err(\"An error has occurred negotiating the relay connection\", err);\n            return cb(err);\n          }\n\n          return cb(null, conn);\n        });\n      }\n    }\n    /**\n     * Negotiate the relay connection\n     *\n     * @param {Multiaddr|PeerInfo|Connection} relay - the Connection or PeerInfo of the relay\n     * @param {multiaddr} dstMa - the multiaddr of the peer to relay the connection for\n     * @param {Function} callback - a callback which gets the negotiated relay connection\n     * @returns {void}\n     * @private\n     *\n     * @memberOf Dialer\n     */\n\n  }, {\n    key: \"_negotiateRelay\",\n    value: function _negotiateRelay(relay, dstMa, callback) {\n      var _this3 = this;\n\n      dstMa = multiaddr(dstMa);\n      relay = this.utils.peerInfoFromMa(relay);\n\n      var srcMas = this.swarm._peerInfo.multiaddrs.toArray();\n\n      this._dialRelayHelper(relay, function (err, conn) {\n        if (err) {\n          log.err(err);\n          return callback(err);\n        }\n\n        var sh = new StreamHandler(conn);\n        waterfall([function (cb) {\n          log(\"negotiating relay for peer \".concat(dstMa.getPeerId()));\n          sh.write(proto.CircuitRelay.encode({\n            type: proto.CircuitRelay.Type.HOP,\n            srcPeer: {\n              id: _this3.swarm._peerInfo.id.id,\n              addrs: srcMas.map(function (addr) {\n                return addr.buffer;\n              })\n            },\n            dstPeer: {\n              id: PeerId.createFromB58String(dstMa.getPeerId()).id,\n              addrs: [dstMa.buffer]\n            }\n          }), cb);\n        }, function (cb) {\n          return sh.read(cb);\n        }], function (err, msg) {\n          if (err) {\n            return callback(err);\n          }\n\n          var message = proto.CircuitRelay.decode(msg);\n\n          if (message.type !== proto.CircuitRelay.Type.STATUS) {\n            return callback(new Error(\"Got invalid message type - \" + \"expected \".concat(proto.CircuitRelay.Type.STATUS, \" got \").concat(message.type)));\n          }\n\n          if (message.code !== proto.CircuitRelay.Status.SUCCESS) {\n            return callback(new Error(\"Got \".concat(message.code, \" error code trying to dial over relay\")));\n          }\n\n          callback(null, new Connection(sh.rest()));\n        });\n      });\n    }\n    /**\n     * Dial a relay peer by its PeerInfo\n     *\n     * @param {PeerInfo} peer - the PeerInfo of the relay peer\n     * @param {Function} cb - a callback with the connection to the relay peer\n     * @returns {Function|void}\n     * @private\n     */\n\n  }, {\n    key: \"_dialRelay\",\n    value: function _dialRelay(peer, cb) {\n      cb = once(cb || function () {});\n      this.swarm.dial(peer, multicodec.relay, once(function (err, conn) {\n        if (err) {\n          log.err(err);\n          return cb(err);\n        }\n\n        cb(null, conn);\n      }));\n    }\n  }]);\n\n  return Dialer;\n}();\n\nmodule.exports = Dialer;","map":null,"metadata":{},"sourceType":"script"}