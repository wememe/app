{"ast":null,"code":"var EventEmitter = require('events').EventEmitter;\n\nvar shortid = require('shortid');\n\nvar _require = require('./constants'),\n    WORKER_REQUEST_READ_LOCK = _require.WORKER_REQUEST_READ_LOCK,\n    WORKER_RELEASE_READ_LOCK = _require.WORKER_RELEASE_READ_LOCK,\n    MASTER_GRANT_READ_LOCK = _require.MASTER_GRANT_READ_LOCK,\n    WORKER_REQUEST_WRITE_LOCK = _require.WORKER_REQUEST_WRITE_LOCK,\n    WORKER_RELEASE_WRITE_LOCK = _require.WORKER_RELEASE_WRITE_LOCK,\n    MASTER_GRANT_WRITE_LOCK = _require.MASTER_GRANT_WRITE_LOCK;\n\nvar cluster;\n\nvar handleWorkerLockRequest = function handleWorkerLockRequest(emitter, masterEvent, requestType, releaseType, grantType) {\n  return function (worker, requestEvent) {\n    if (requestEvent && requestEvent.type === requestType) {\n      emitter.emit(masterEvent, requestEvent.name, function () {\n        // grant lock to worker\n        worker.send({\n          type: grantType,\n          name: requestEvent.name,\n          identifier: requestEvent.identifier\n        }); // wait for worker to finish\n\n        return new Promise(function (resolve) {\n          var releaseEventListener = function releaseEventListener(releaseEvent) {\n            if (releaseEvent && releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n              worker.removeListener('message', releaseEventListener);\n              resolve();\n            }\n          };\n\n          worker.on('message', releaseEventListener);\n        });\n      });\n    }\n  };\n};\n\nvar makeWorkerLockRequest = function makeWorkerLockRequest(name, requestType, grantType, releaseType) {\n  return function (fn) {\n    var id = shortid.generate();\n    process.send({\n      type: requestType,\n      identifier: id,\n      name: name\n    });\n    return new Promise(function (resolve, reject) {\n      var listener = function listener(event) {\n        if (event && event.type === grantType && event.identifier === id) {\n          process.removeListener('message', listener);\n          var error = null;\n          fn().catch(function (err) {\n            error = err;\n          }).then(function (result) {\n            process.send({\n              type: releaseType,\n              identifier: id,\n              name: name\n            });\n\n            if (error) {\n              return reject(error);\n            }\n\n            resolve(result);\n          });\n        }\n      };\n\n      process.on('message', listener);\n    });\n  };\n};\n\nmodule.exports = function (options) {\n  try {\n    cluster = require('cluster');\n\n    if (!Object.keys(cluster).length) {\n      return;\n    }\n  } catch (_) {\n    return;\n  }\n\n  if (cluster.isMaster || options.singleProcess) {\n    var emitter = new EventEmitter();\n    cluster.on('message', handleWorkerLockRequest(emitter, 'requestReadLock', WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));\n    cluster.on('message', handleWorkerLockRequest(emitter, 'requestWriteLock', WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));\n    return emitter;\n  }\n\n  return {\n    isWorker: true,\n    readLock: function readLock(name, options) {\n      return makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK);\n    },\n    writeLock: function writeLock(name, options) {\n      return makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK);\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}