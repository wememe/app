{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar identify = require('libp2p-identify');\n\nvar multistream = require('multistream-select');\n\nvar waterfall = require('async/waterfall');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:switch:connection');\n\nvar once = require('once');\n\nvar setImmediate = require('async/setImmediate');\n\nvar Circuit = require('libp2p-circuit');\n\nvar plaintext = require('./plaintext');\n/**\n * Contains methods for binding handlers to the Switch\n * in order to better manage its connections.\n */\n\n\nvar ConnectionManager =\n/*#__PURE__*/\nfunction () {\n  function ConnectionManager(_switch) {\n    _classCallCheck(this, ConnectionManager);\n\n    this.switch = _switch;\n  }\n  /**\n   * Adds a listener for the given `muxer` and creates a handler for it\n   * leveraging the Switch.protocolMuxer handler factory\n   *\n   * @param {Muxer} muxer\n   * @returns {void}\n   */\n\n\n  _createClass(ConnectionManager, [{\n    key: \"addStreamMuxer\",\n    value: function addStreamMuxer(muxer) {\n      var _this = this;\n\n      // for dialing\n      this.switch.muxers[muxer.multicodec] = muxer; // for listening\n\n      this.switch.handle(muxer.multicodec, function (protocol, conn) {\n        var muxedConn = muxer.listener(conn);\n        muxedConn.on('stream', _this.switch.protocolMuxer(null)); // If identify is enabled\n        //   1. overload getPeerInfo\n        //   2. call getPeerInfo\n        //   3. add this conn to the pool\n\n        if (_this.switch.identify) {\n          // Get the peer info from the crypto exchange\n          conn.getPeerInfo(function (err, cryptoPI) {\n            if (err || !cryptoPI) {\n              log('crypto peerInfo wasnt found');\n            } // overload peerInfo to use Identify instead\n\n\n            conn.getPeerInfo = function (callback) {\n              var conn = muxedConn.newStream();\n              var ms = new multistream.Dialer();\n              callback = once(callback);\n              waterfall([function (cb) {\n                return ms.handle(conn, cb);\n              }, function (cb) {\n                return ms.select(identify.multicodec, cb);\n              }, // run identify and verify the peer has the same info from crypto\n              function (conn, cb) {\n                return identify.dialer(conn, cryptoPI, cb);\n              }, function (peerInfo, observedAddrs, cb) {\n                observedAddrs.forEach(function (oa) {\n                  _this.switch._peerInfo.multiaddrs.addSafe(oa);\n                });\n                cb(null, peerInfo);\n              }], function (err, peerInfo) {\n                if (err) {\n                  return muxedConn.end(function () {\n                    if (peerInfo) {\n                      setImmediate(function () {\n                        return _this.switch.emit('peer-mux-closed', peerInfo);\n                      });\n                    }\n\n                    callback(err, null);\n                  });\n                }\n\n                if (peerInfo) {\n                  conn.setPeerInfo(peerInfo);\n                }\n\n                callback(err, peerInfo);\n              });\n            };\n\n            conn.getPeerInfo(function (err, peerInfo) {\n              if (err) {\n                return log('identify not successful');\n              }\n\n              var b58Str = peerInfo.id.toB58String();\n              _this.switch.muxedConns[b58Str] = {\n                muxer: muxedConn\n              };\n\n              if (peerInfo.multiaddrs.size > 0) {\n                // with incomming conn and through identify, going to pick one\n                // of the available multiaddrs from the other peer as the one\n                // I'm connected to as we really can't be sure at the moment\n                // TODO add this consideration to the connection abstraction!\n                peerInfo.connect(peerInfo.multiaddrs.toArray()[0]);\n              } else {\n                // for the case of websockets in the browser, where peers have\n                // no addr, use just their IPFS id\n                peerInfo.connect(\"/ipfs/\".concat(b58Str));\n              }\n\n              peerInfo = _this.switch._peerBook.put(peerInfo);\n              muxedConn.on('close', function () {\n                delete _this.switch.muxedConns[b58Str];\n                peerInfo.disconnect();\n                peerInfo = _this.switch._peerBook.put(peerInfo);\n                log(\"closed connection to \".concat(b58Str));\n                setImmediate(function () {\n                  return _this.switch.emit('peer-mux-closed', peerInfo);\n                });\n              });\n              setImmediate(function () {\n                return _this.switch.emit('peer-mux-established', peerInfo);\n              });\n            });\n          });\n        }\n\n        return conn;\n      });\n    }\n    /**\n     * Adds the `encrypt` handler for the given `tag` and also sets the\n     * Switch's crypto to past `encrypt` function\n     *\n     * @param {String} tag\n     * @param {function(PeerID, Connection, PeerId, Callback)} encrypt\n     * @returns {void}\n     */\n\n  }, {\n    key: \"crypto\",\n    value: function crypto(tag, encrypt) {\n      var _this2 = this;\n\n      if (!tag && !encrypt) {\n        tag = plaintext.tag;\n        encrypt = plaintext.encrypt;\n      }\n\n      this.switch.unhandle(this.switch.crypto.tag);\n      this.switch.handle(tag, function (protocol, conn) {\n        var myId = _this2.switch._peerInfo.id;\n        var secure = encrypt(myId, conn, undefined, function () {\n          _this2.switch.protocolMuxer(null)(secure);\n        });\n      });\n      this.switch.crypto = {\n        tag: tag,\n        encrypt: encrypt\n      };\n    }\n    /**\n     * If config.enabled is true, a Circuit relay will be added to the\n     * available Switch transports.\n     *\n     * @param {any} config\n     * @returns {void}\n     */\n\n  }, {\n    key: \"enableCircuitRelay\",\n    value: function enableCircuitRelay(config) {\n      config = config || {};\n\n      if (config.enabled) {\n        if (!config.hop) {\n          Object.assign(config, {\n            hop: {\n              enabled: false,\n              active: false\n            }\n          });\n        }\n\n        this.switch.transport.add(Circuit.tag, new Circuit(this.switch, config));\n      }\n    }\n    /**\n     * Sets identify to true on the Switch and performs handshakes\n     * for libp2p-identify leveraging the Switch's muxer.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"reuse\",\n    value: function reuse() {\n      var _this3 = this;\n\n      this.switch.identify = true;\n      this.switch.handle(identify.multicodec, function (protocol, conn) {\n        identify.listener(conn, _this3.switch._peerInfo);\n      });\n    }\n  }]);\n\n  return ConnectionManager;\n}();\n\nmodule.exports = ConnectionManager;","map":null,"metadata":{},"sourceType":"script"}