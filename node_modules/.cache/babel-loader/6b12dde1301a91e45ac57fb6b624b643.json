{"ast":null,"code":"// secrets.js - by Alexander Stetsyuk - released under MIT License\n(function (exports, global) {\n  var defaults = {\n    bits: 8,\n    // default number of bits\n    radix: 16,\n    // work with HEX by default\n    minBits: 3,\n    maxBits: 20,\n    // this permits 1,048,575 shares, though going this high is NOT recommended in JS!\n    bytesPerChar: 2,\n    maxBytesPerChar: 6,\n    // Math.pow(256,7) > Math.pow(2,53)\n    // Primitive polynomials (in decimal form) for Galois Fields GF(2^n), for 2 <= n <= 30\n    // The index of each term in the array corresponds to the n for that polynomial\n    // i.e. to get the polynomial for n=16, use primitivePolynomials[16]\n    primitivePolynomials: [null, null, 1, 3, 3, 5, 3, 3, 29, 17, 9, 5, 83, 27, 43, 3, 45, 9, 39, 39, 9, 5, 3, 33, 27, 9, 71, 39, 9, 5, 83],\n    // warning for insecure PRNG\n    warning: 'WARNING:\\nA secure random number generator was not found.\\nUsing Math.random(), which is NOT cryptographically strong!'\n  }; // Protected settings object\n\n  var config = {};\n  /** @expose **/\n\n  exports.getConfig = function () {\n    return {\n      'bits': config.bits,\n      'unsafePRNG': config.unsafePRNG\n    };\n  };\n\n  function init(bits) {\n    if (bits && (typeof bits !== 'number' || bits % 1 !== 0 || bits < defaults.minBits || bits > defaults.maxBits)) {\n      throw new Error('Number of bits must be an integer between ' + defaults.minBits + ' and ' + defaults.maxBits + ', inclusive.');\n    }\n\n    config.radix = defaults.radix;\n    config.bits = bits || defaults.bits;\n    config.size = Math.pow(2, config.bits);\n    config.max = config.size - 1; // Construct the exp and log tables for multiplication.\t\n\n    var logs = [],\n        exps = [],\n        x = 1,\n        primitive = defaults.primitivePolynomials[config.bits];\n\n    for (var i = 0; i < config.size; i++) {\n      exps[i] = x;\n      logs[x] = i;\n      x <<= 1;\n\n      if (x >= config.size) {\n        x ^= primitive;\n        x &= config.max;\n      }\n    }\n\n    config.logs = logs;\n    config.exps = exps;\n  }\n\n  ;\n  /** @expose **/\n\n  exports.init = init;\n\n  function isInited() {\n    if (!config.bits || !config.size || !config.max || !config.logs || !config.exps || config.logs.length !== config.size || config.exps.length !== config.size) {\n      return false;\n    }\n\n    return true;\n  }\n\n  ; // Returns a pseudo-random number generator of the form function(bits){}\n  // which should output a random string of 1's and 0's of length `bits`\n\n  function getRNG() {\n    var randomBits, crypto;\n\n    function construct(bits, arr, radix, size) {\n      var str = '',\n          i = 0,\n          len = arr.length - 1;\n\n      while (i < len || str.length < bits) {\n        str += padLeft(parseInt(arr[i], radix).toString(2), size);\n        i++;\n      }\n\n      str = str.substr(-bits);\n\n      if ((str.match(/0/g) || []).length === str.length) {\n        // all zeros?\n        return null;\n      } else {\n        return str;\n      }\n    } // node.js crypto.randomBytes()\n\n\n    if (typeof require === 'function' && (crypto = require('crypto')) && (randomBits = crypto['randomBytes'])) {\n      return function (bits) {\n        var bytes = Math.ceil(bits / 8),\n            str = null;\n\n        while (str === null) {\n          str = construct(bits, randomBits(bytes).toString('hex'), 16, 4);\n        }\n\n        return str;\n      };\n    } // browsers with window.crypto.getRandomValues()\n\n\n    if (global['crypto'] && typeof global['crypto']['getRandomValues'] === 'function' && typeof global['Uint32Array'] === 'function') {\n      crypto = global['crypto'];\n      return function (bits) {\n        var elems = Math.ceil(bits / 32),\n            str = null,\n            arr = new global['Uint32Array'](elems);\n\n        while (str === null) {\n          crypto['getRandomValues'](arr);\n          str = construct(bits, arr, 10, 32);\n        }\n\n        return str;\n      };\n    } // A totally insecure RNG!!! (except in Safari)\n    // Will produce a warning every time it is called.\n\n\n    config.unsafePRNG = true;\n    warn();\n    var bitsPerNum = 32;\n    var max = Math.pow(2, bitsPerNum) - 1;\n    return function (bits) {\n      var elems = Math.ceil(bits / bitsPerNum);\n      var arr = [],\n          str = null;\n\n      while (str === null) {\n        for (var i = 0; i < elems; i++) {\n          arr[i] = Math.floor(Math.random() * max + 1);\n        }\n\n        str = construct(bits, arr, 10, bitsPerNum);\n      }\n\n      return str;\n    };\n  }\n\n  ; // Warn about using insecure rng.\n  // Called when Math.random() is being used.\n\n  function warn() {\n    global['console']['warn'](defaults.warning);\n\n    if (typeof global['alert'] === 'function' && config.alert) {\n      global['alert'](defaults.warning);\n    }\n  } // Set the PRNG to use. If no RNG function is supplied, pick a default using getRNG()\n\n  /** @expose **/\n\n\n  exports.setRNG = function (rng, alert) {\n    if (!isInited()) {\n      this.init();\n    }\n\n    config.unsafePRNG = false;\n    rng = rng || getRNG(); // test the RNG (5 times)\n\n    if (typeof rng !== 'function' || typeof rng(config.bits) !== 'string' || !parseInt(rng(config.bits), 2) || rng(config.bits).length > config.bits || rng(config.bits).length < config.bits) {\n      throw new Error(\"Random number generator is invalid. Supply an RNG of the form function(bits){} that returns a string containing 'bits' number of random 1's and 0's.\");\n    } else {\n      config.rng = rng;\n    }\n\n    config.alert = !!alert;\n    return !!config.unsafePRNG;\n  };\n\n  function isSetRNG() {\n    return typeof config.rng === 'function';\n  }\n\n  ; // Generates a random bits-length number string using the PRNG\n\n  /** @expose **/\n\n  exports.random = function (bits) {\n    if (!isSetRNG()) {\n      this.setRNG();\n    }\n\n    if (typeof bits !== 'number' || bits % 1 !== 0 || bits < 2) {\n      throw new Error('Number of bits must be an integer greater than 1.');\n    }\n\n    if (config.unsafePRNG) {\n      warn();\n    }\n\n    return bin2hex(config.rng(bits));\n  }; // Divides a `secret` number String str expressed in radix `inputRadix` (optional, default 16) \n  // into `numShares` shares, each expressed in radix `outputRadix` (optional, default to `inputRadix`), \n  // requiring `threshold` number of shares to reconstruct the secret. \n  // Optionally, zero-pads the secret to a length that is a multiple of padLength before sharing.\n\n  /** @expose **/\n\n\n  exports.share = function (secret, numShares, threshold, padLength, withoutPrefix) {\n    if (!isInited()) {\n      this.init();\n    }\n\n    if (!isSetRNG()) {\n      this.setRNG();\n    }\n\n    padLength = padLength || 0;\n\n    if (typeof secret !== 'string') {\n      throw new Error('Secret must be a string.');\n    }\n\n    if (typeof numShares !== 'number' || numShares % 1 !== 0 || numShares < 2) {\n      throw new Error('Number of shares must be an integer between 2 and 2^bits-1 (' + config.max + '), inclusive.');\n    }\n\n    if (numShares > config.max) {\n      var neededBits = Math.ceil(Math.log(numShares + 1) / Math.LN2);\n      throw new Error('Number of shares must be an integer between 2 and 2^bits-1 (' + config.max + '), inclusive. To create ' + numShares + ' shares, use at least ' + neededBits + ' bits.');\n    }\n\n    if (typeof threshold !== 'number' || threshold % 1 !== 0 || threshold < 2) {\n      throw new Error('Threshold number of shares must be an integer between 2 and 2^bits-1 (' + config.max + '), inclusive.');\n    }\n\n    if (threshold > config.max) {\n      var neededBits = Math.ceil(Math.log(threshold + 1) / Math.LN2);\n      throw new Error('Threshold number of shares must be an integer between 2 and 2^bits-1 (' + config.max + '), inclusive.  To use a threshold of ' + threshold + ', use at least ' + neededBits + ' bits.');\n    }\n\n    if (typeof padLength !== 'number' || padLength % 1 !== 0) {\n      throw new Error('Zero-pad length must be an integer greater than 1.');\n    }\n\n    if (config.unsafePRNG) {\n      warn();\n    }\n\n    secret = '1' + hex2bin(secret); // append a 1 so that we can preserve the correct number of leading zeros in our secret\n\n    secret = split(secret, padLength);\n    var x = new Array(numShares),\n        y = new Array(numShares);\n\n    for (var i = 0, len = secret.length; i < len; i++) {\n      var subShares = this._getShares(secret[i], numShares, threshold);\n\n      for (var j = 0; j < numShares; j++) {\n        x[j] = x[j] || subShares[j].x.toString(config.radix);\n        y[j] = padLeft(subShares[j].y.toString(2)) + (y[j] ? y[j] : '');\n      }\n    }\n\n    var padding = config.max.toString(config.radix).length;\n\n    if (withoutPrefix) {\n      for (var i = 0; i < numShares; i++) {\n        x[i] = bin2hex(y[i]);\n      }\n    } else {\n      for (var i = 0; i < numShares; i++) {\n        x[i] = config.bits.toString(36).toUpperCase() + padLeft(x[i], padding) + bin2hex(y[i]);\n      }\n    }\n\n    return x;\n  }; // This is the basic polynomial generation and evaluation function \n  // for a `config.bits`-length secret (NOT an arbitrary length)\n  // Note: no error-checking at this stage! If `secrets` is NOT \n  // a NUMBER less than 2^bits-1, the output will be incorrect!\n\n  /** @expose **/\n\n\n  exports._getShares = function (secret, numShares, threshold) {\n    var shares = [];\n    var coeffs = [secret];\n\n    for (var i = 1; i < threshold; i++) {\n      coeffs[i] = parseInt(config.rng(config.bits), 2);\n    }\n\n    for (var i = 1, len = numShares + 1; i < len; i++) {\n      shares[i - 1] = {\n        x: i,\n        y: horner(i, coeffs)\n      };\n    }\n\n    return shares;\n  }; // Polynomial evaluation at `x` using Horner's Method\n  // TODO: this can possibly be sped up using other methods\n  // NOTE: fx=fx * x + coeff[i] ->  exp(log(fx) + log(x)) + coeff[i], \n  //       so if fx===0, just set fx to coeff[i] because\n  //       using the exp/log form will result in incorrect value\n\n\n  function horner(x, coeffs) {\n    var logx = config.logs[x];\n    var fx = 0;\n\n    for (var i = coeffs.length - 1; i >= 0; i--) {\n      if (fx === 0) {\n        fx = coeffs[i];\n        continue;\n      }\n\n      fx = config.exps[(logx + config.logs[fx]) % config.max] ^ coeffs[i];\n    }\n\n    return fx;\n  }\n\n  ;\n\n  function inArray(arr, val) {\n    for (var i = 0, len = arr.length; i < len; i++) {\n      if (arr[i] === val) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  ;\n\n  function processShare(share) {\n    var bits = parseInt(share[0], 36);\n\n    if (bits && (typeof bits !== 'number' || bits % 1 !== 0 || bits < defaults.minBits || bits > defaults.maxBits)) {\n      throw new Error('Number of bits must be an integer between ' + defaults.minBits + ' and ' + defaults.maxBits + ', inclusive.');\n    }\n\n    var max = Math.pow(2, bits) - 1;\n    var idLength = max.toString(config.radix).length;\n    var id = parseInt(share.substr(1, idLength), config.radix);\n\n    if (typeof id !== 'number' || id % 1 !== 0 || id < 1 || id > max) {\n      throw new Error('Share id must be an integer between 1 and ' + config.max + ', inclusive.');\n    }\n\n    share = share.substr(idLength + 1);\n\n    if (!share.length) {\n      throw new Error('Invalid share: zero-length share.');\n    }\n\n    return {\n      'bits': bits,\n      'id': id,\n      'value': share\n    };\n  }\n\n  ;\n  /** @expose **/\n\n  exports._processShare = processShare; // Protected method that evaluates the Lagrange interpolation\n  // polynomial at x=`at` for individual config.bits-length\n  // segments of each share in the `shares` Array.\n  // Each share is expressed in base `inputRadix`. The output \n  // is expressed in base `outputRadix'\n\n  function combine(at, shares) {\n    var setBits,\n        share,\n        x = [],\n        y = [],\n        result = '',\n        idx;\n\n    for (var i = 0, len = shares.length; i < len; i++) {\n      share = processShare(shares[i]);\n\n      if (typeof setBits === 'undefined') {\n        setBits = share['bits'];\n      } else if (share['bits'] !== setBits) {\n        throw new Error('Mismatched shares: Different bit settings.');\n      }\n\n      if (config.bits !== setBits) {\n        init(setBits);\n      }\n\n      if (inArray(x, share['id'])) {\n        // repeated x value?\n        continue;\n      }\n\n      idx = x.push(share['id']) - 1;\n      share = split(hex2bin(share['value']));\n\n      for (var j = 0, len2 = share.length; j < len2; j++) {\n        y[j] = y[j] || [];\n        y[j][idx] = share[j];\n      }\n    }\n\n    for (var i = 0, len = y.length; i < len; i++) {\n      result = padLeft(lagrange(at, x, y[i]).toString(2)) + result;\n    }\n\n    if (at === 0) {\n      // reconstructing the secret\n      var idx = result.indexOf('1'); //find the first 1\n\n      return bin2hex(result.slice(idx + 1));\n    } else {\n      // generating a new share\n      return bin2hex(result);\n    }\n  }\n\n  ; // Combine `shares` Array into the original secret\n\n  /** @expose **/\n\n  exports.combine = function (shares) {\n    return combine(0, shares);\n  }; // Generate a new share with id `id` (a number between 1 and 2^bits-1)\n  // `id` can be a Number or a String in the default radix (16)\n\n  /** @expose **/\n\n\n  exports.newShare = function (id, shares) {\n    if (typeof id === 'string') {\n      id = parseInt(id, config.radix);\n    }\n\n    var share = processShare(shares[0]);\n    var max = Math.pow(2, share['bits']) - 1;\n\n    if (typeof id !== 'number' || id % 1 !== 0 || id < 1 || id > max) {\n      throw new Error('Share id must be an integer between 1 and ' + config.max + ', inclusive.');\n    }\n\n    var padding = max.toString(config.radix).length;\n    return config.bits.toString(36).toUpperCase() + padLeft(id.toString(config.radix), padding) + combine(id, shares);\n  }; // Evaluate the Lagrange interpolation polynomial at x = `at`\n  // using x and y Arrays that are of the same length, with\n  // corresponding elements constituting points on the polynomial.\n\n\n  function lagrange(at, x, y) {\n    var sum = 0,\n        product,\n        i,\n        j;\n\n    for (var i = 0, len = x.length; i < len; i++) {\n      if (!y[i]) {\n        continue;\n      }\n\n      product = config.logs[y[i]];\n\n      for (var j = 0; j < len; j++) {\n        if (i === j) {\n          continue;\n        }\n\n        if (at === x[j]) {\n          // happens when computing a share that is in the list of shares used to compute it\n          product = -1; // fix for a zero product term, after which the sum should be sum^0 = sum, not sum^1\n\n          break;\n        }\n\n        product = (product + config.logs[at ^ x[j]] - config.logs[x[i] ^ x[j]] + config.max\n        /* to make sure it's not negative */\n        ) % config.max;\n      }\n\n      sum = product === -1 ? sum : sum ^ config.exps[product]; // though exps[-1]= undefined and undefined ^ anything = anything in chrome, this behavior may not hold everywhere, so do the check\n    }\n\n    return sum;\n  }\n\n  ;\n  /** @expose **/\n\n  exports._lagrange = lagrange; // Splits a number string `bits`-length segments, after first \n  // optionally zero-padding it to a length that is a multiple of `padLength.\n  // Returns array of integers (each less than 2^bits-1), with each element\n  // representing a `bits`-length segment of the input string from right to left, \n  // i.e. parts[0] represents the right-most `bits`-length segment of the input string.\n\n  function split(str, padLength) {\n    if (padLength) {\n      str = padLeft(str, padLength);\n    }\n\n    var parts = [];\n\n    for (var i = str.length; i > config.bits; i -= config.bits) {\n      parts.push(parseInt(str.slice(i - config.bits, i), 2));\n    }\n\n    parts.push(parseInt(str.slice(0, i), 2));\n    return parts;\n  }\n\n  ; // Pads a string `str` with zeros on the left so that its length is a multiple of `bits`\n\n  function padLeft(str, bits) {\n    bits = bits || config.bits;\n    var missing = str.length % bits;\n    return (missing ? new Array(bits - missing + 1).join('0') : '') + str;\n  }\n\n  ;\n\n  function hex2bin(str) {\n    var bin = '',\n        num;\n\n    for (var i = str.length - 1; i >= 0; i--) {\n      num = parseInt(str[i], 16);\n\n      if (isNaN(num)) {\n        throw new Error('Invalid hex character.');\n      }\n\n      bin = padLeft(num.toString(2), 4) + bin;\n    }\n\n    return bin;\n  }\n\n  function bin2hex(str) {\n    var hex = '',\n        num;\n    str = padLeft(str, 4);\n\n    for (var i = str.length; i >= 4; i -= 4) {\n      num = parseInt(str.slice(i - 4, i), 2);\n\n      if (isNaN(num)) {\n        throw new Error('Invalid binary character.');\n      }\n\n      hex = num.toString(16) + hex;\n    }\n\n    return hex;\n  } // Converts a given UTF16 character string to the HEX representation. \n  // Each character of the input string is represented by \n  // `bytesPerChar` bytes in the output string.\n\n  /** @expose **/\n\n\n  exports.str2hex = function (str, bytesPerChar) {\n    if (typeof str !== 'string') {\n      throw new Error('Input must be a character string.');\n    }\n\n    bytesPerChar = bytesPerChar || defaults.bytesPerChar;\n\n    if (typeof bytesPerChar !== 'number' || bytesPerChar % 1 !== 0 || bytesPerChar < 1 || bytesPerChar > defaults.maxBytesPerChar) {\n      throw new Error('Bytes per character must be an integer between 1 and ' + defaults.maxBytesPerChar + ', inclusive.');\n    }\n\n    var hexChars = 2 * bytesPerChar;\n    var max = Math.pow(16, hexChars) - 1;\n    var out = '',\n        num;\n\n    for (var i = 0, len = str.length; i < len; i++) {\n      num = str[i].charCodeAt();\n\n      if (isNaN(num)) {\n        throw new Error('Invalid character: ' + str[i]);\n      } else if (num > max) {\n        var neededBytes = Math.ceil(Math.log(num + 1) / Math.log(256));\n        throw new Error('Invalid character code (' + num + '). Maximum allowable is 256^bytes-1 (' + max + '). To convert this character, use at least ' + neededBytes + ' bytes.');\n      } else {\n        out = padLeft(num.toString(16), hexChars) + out;\n      }\n    }\n\n    return out;\n  }; // Converts a given HEX number string to a UTF16 character string. \n\n  /** @expose **/\n\n\n  exports.hex2str = function (str, bytesPerChar) {\n    if (typeof str !== 'string') {\n      throw new Error('Input must be a hexadecimal string.');\n    }\n\n    bytesPerChar = bytesPerChar || defaults.bytesPerChar;\n\n    if (typeof bytesPerChar !== 'number' || bytesPerChar % 1 !== 0 || bytesPerChar < 1 || bytesPerChar > defaults.maxBytesPerChar) {\n      throw new Error('Bytes per character must be an integer between 1 and ' + defaults.maxBytesPerChar + ', inclusive.');\n    }\n\n    var hexChars = 2 * bytesPerChar;\n    var out = '';\n    str = padLeft(str, hexChars);\n\n    for (var i = 0, len = str.length; i < len; i += hexChars) {\n      out = String.fromCharCode(parseInt(str.slice(i, i + hexChars), 16)) + out;\n    }\n\n    return out;\n  }; // by default, initialize without an RNG\n\n\n  exports.init();\n})(typeof module !== 'undefined' && module['exports'] ? module['exports'] : window['secrets'] = {}, typeof GLOBAL !== 'undefined' ? GLOBAL : window);","map":null,"metadata":{},"sourceType":"script"}