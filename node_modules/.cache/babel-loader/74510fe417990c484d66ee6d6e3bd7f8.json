{"ast":null,"code":"var node = require('./node');\n\nvar browser = require('./browser');\n\nvar Queue = require('p-queue');\n\nvar _require = require('promise-timeout'),\n    timeout = _require.timeout;\n\nvar observe = require('observable-webworkers');\n\nvar mutexes = {};\nvar implementation;\n\nvar createMutex = function createMutex(name, options) {\n  if (implementation.isWorker) {\n    return {\n      readLock: implementation.readLock(name, options),\n      writeLock: implementation.writeLock(name, options)\n    };\n  }\n\n  var masterQueue = new Queue({\n    concurrency: 1\n  });\n  var readQueue = null;\n  return {\n    readLock: function readLock(fn) {\n      if (!readQueue) {\n        readQueue = new Queue({\n          concurrency: options.concurrency,\n          autoStart: false\n        });\n        var localReadQueue = readQueue;\n        masterQueue.add(function () {\n          localReadQueue.start();\n          return localReadQueue.onIdle().then(function () {\n            if (readQueue === localReadQueue) {\n              readQueue = null;\n            }\n          });\n        });\n      }\n\n      return readQueue.add(function () {\n        return timeout(fn(), options.timeout);\n      });\n    },\n    writeLock: function writeLock(fn) {\n      readQueue = null;\n      return masterQueue.add(function () {\n        return timeout(fn(), options.timeout);\n      });\n    }\n  };\n};\n\nvar defaultOptions = {\n  concurrency: Infinity,\n  timeout: 84600000,\n  global: global,\n  singleProcess: false\n};\n\nmodule.exports = function (name, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof name === 'object') {\n    options = name;\n    name = 'lock';\n  }\n\n  if (!name) {\n    name = 'lock';\n  }\n\n  options = Object.assign({}, defaultOptions, options);\n\n  if (!implementation) {\n    implementation = node(options) || browser(options);\n\n    if (!implementation.isWorker) {\n      // we are master, set up worker requests\n      implementation.on('requestReadLock', function (name, fn) {\n        mutexes[name] && mutexes[name].readLock(fn);\n      });\n      implementation.on('requestWriteLock', function (name, fn) {\n        mutexes[name] && mutexes[name].writeLock(fn);\n      });\n    }\n  }\n\n  if (!mutexes[name]) {\n    mutexes[name] = createMutex(name, options);\n  }\n\n  return mutexes[name];\n};\n\nmodule.exports.Worker = function (script, Impl) {\n  Impl = Impl || global.Worker;\n  var worker;\n\n  try {\n    worker = new Impl(script);\n  } catch (error) {\n    if (error.message.includes('not a constructor')) {\n      worker = Impl(script);\n    }\n  }\n\n  if (!worker) {\n    throw new Error('Could not create Worker from', Impl);\n  }\n\n  observe(worker);\n  return worker;\n};","map":null,"metadata":{},"sourceType":"script"}