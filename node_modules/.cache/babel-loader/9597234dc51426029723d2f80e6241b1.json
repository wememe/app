{"ast":null,"code":"'use strict';\n\nvar promisify = require('promisify-es6');\n\nvar every = require('async/every');\n\nvar PeerId = require('peer-id');\n\nvar CID = require('cids');\n\nvar each = require('async/each');\n\nvar setImmediate = require('async/setImmediate'); // const bsplit = require('buffer-split')\n\n\nvar errCode = require('err-code');\n\nmodule.exports = function (self) {\n  return {\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {Buffer} key\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    get: promisify(function (key, options, callback) {\n      if (!Buffer.isBuffer(key)) {\n        return callback(new Error('Not valid key'));\n      }\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n\n      self._libp2pNode.dht.get(key, options.timeout, callback);\n    }),\n\n    /**\n     * Write a key/value pair to the DHT.\n     *\n     * Given a key of the form /foo/bar and a value of any\n     * form, this will write that value to the DHT with\n     * that key.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    put: promisify(function (key, value, callback) {\n      if (!Buffer.isBuffer(key)) {\n        return callback(new Error('Not valid key'));\n      }\n\n      self._libp2pNode.dht.put(key, value, callback);\n    }),\n\n    /**\n     * Find peers in the DHT that can provide a specific value, given a key.\n     *\n     * @param {CID} key - They key to find providers for.\n     * @param {function(Error, Array<PeerInfo>)} [callback]\n     * @returns {Promise<PeerInfo>|void}\n     */\n    findprovs: promisify(function (key, opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n\n      opts = opts || {};\n\n      if (typeof key === 'string') {\n        try {\n          key = new CID(key);\n        } catch (err) {\n          return setImmediate(function () {\n            return callback(errCode(err, 'ERR_INVALID_CID'));\n          });\n        }\n      }\n\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n\n      opts = opts || {};\n\n      self._libp2pNode.contentRouting.findProviders(key, opts.timeout || null, callback);\n    }),\n\n    /**\n     * Query the DHT for all multiaddresses associated with a `PeerId`.\n     *\n     * @param {PeerId} peer - The id of the peer to search for.\n     * @param {function(Error, Array<Multiaddr>)} [callback]\n     * @returns {Promise<Array<Multiaddr>>|void}\n     */\n    findpeer: promisify(function (peer, callback) {\n      if (typeof peer === 'string') {\n        peer = PeerId.createFromB58String(peer);\n      }\n\n      self._libp2pNode.peerRouting.findPeer(peer, function (err, info) {\n        if (err) {\n          return callback(err);\n        } // convert to go-ipfs return value, we need to revisit\n        // this. For now will just conform.\n\n\n        var goResult = [{\n          Responses: [{\n            ID: info.id.toB58String(),\n            Addresses: info.multiaddrs.toArray().map(function (a) {\n              return a.toString();\n            })\n          }]\n        }];\n        callback(null, goResult);\n      });\n    }),\n\n    /**\n     * Announce to the network that we are providing given values.\n     *\n     * @param {CID|Array<CID>} keys - The keys that should be announced.\n     * @param {Object} [options={}]\n     * @param {bool} [options.recursive=false] - Provide not only the given object but also all objects linked from it.\n     * @param {function(Error)} [callback]\n     * @returns {Promise|void}\n     */\n    provide: promisify(function (keys, options, callback) {\n      if (!Array.isArray(keys)) {\n        keys = [keys];\n      }\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {}; // ensure blocks are actually local\n\n      every(keys, function (key, cb) {\n        self._repo.blocks.has(key, cb);\n      }, function (err, has) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!has) {\n          return callback(new Error('block(s) not found locally, cannot provide'));\n        }\n\n        if (options.recursive) {// TODO: Implement recursive providing\n        } else {\n          each(keys, function (cid, cb) {\n            self._libp2pNode.contentRouting.provide(cid, cb);\n          }, callback);\n        }\n      });\n    }),\n\n    /**\n     * Find the closest peers to a given `PeerId`, by querying the DHT.\n     *\n     * @param {PeerId} peer - The `PeerId` to run the query agains.\n     * @param {function(Error, Array<PeerId>)} [callback]\n     * @returns {Promise<Array<PeerId>>|void}\n     */\n    query: promisify(function (peerId, callback) {\n      if (typeof peerId === 'string') {\n        peerId = PeerId.createFromB58String(peerId);\n      } // TODO expose this method in peerRouting\n\n\n      self._libp2pNode._dht.getClosestPeers(peerId.toBytes(), function (err, peerIds) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, peerIds.map(function (id) {\n          return {\n            ID: id.toB58String()\n          };\n        }));\n      });\n    })\n  };\n};","map":null,"metadata":{},"sourceType":"script"}