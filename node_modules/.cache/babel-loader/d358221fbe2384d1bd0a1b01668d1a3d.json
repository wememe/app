{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:websocket-star:listener');\n\nvar multiaddr = require('multiaddr');\n\nvar io = require('socket.io-client');\n\nvar sp = require('socket.io-pull-stream');\n\nvar uuid = require('uuid');\n\nvar series = require('async/series');\n\nvar EE = require('events').EventEmitter;\n\nvar Connection = require('interface-connection').Connection;\n\nvar once = require('once');\n\nvar setImmediate = require('async/setImmediate');\n\nvar utils = require('./utils');\n\nvar cleanUrlSIO = utils.cleanUrlSIO;\n\nvar crypto = require('libp2p-crypto');\n\nvar pull = require('pull-stream');\n\nvar ERRORS = require('./errors');\n\nvar noop = once(function () {});\nvar sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true\n  /**\n    * Listener for signalling server\n    * @class\n    * @param {Object} options - Options for the listener\n    * @param {PeerId} options.id - Id for the crypto challenge\n    * @param {function} options.handler - Incomming connection handler\n    */\n\n};\n\nvar Listener =\n/*#__PURE__*/\nfunction (_EE) {\n  _inherits(Listener, _EE);\n\n  function Listener(options) {\n    var _this;\n\n    _classCallCheck(this, Listener);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Listener).call(this));\n    _this.id = options.id;\n    _this.log = log.bind(log, 'listener#offline');\n    _this.canCrypto = Boolean(options.id);\n    _this._handler = options.handler || noop;\n    _this.listeners_list = options.listeners || {};\n    _this.flag = options.flag;\n    _this.conns = [];\n    _this.connected = false;\n    return _this;\n  } // \"private\" functions\n\n  /**\n    * Connects to the signalling server\n    * @param {function} cb - callback\n    * @returns {undefined}\n    * @private\n    */\n\n\n  _createClass(Listener, [{\n    key: \"_up\",\n    value: function _up(cb) {\n      var _this2 = this;\n\n      cb = cb ? once(cb) : noop;\n\n      if (this.io) {\n        return cb();\n      }\n\n      this.log = log.bind(log, 'listener#' + this.server);\n      this.log('dialing to signalling server');\n\n      var _io = this.io = io.connect(this.server, sioOptions);\n\n      sp(_io, {\n        codec: 'buffer'\n      });\n\n      _io.once('error', cb);\n\n      _io.once('connect_error', cb);\n\n      _io.once('connect', cb);\n\n      var proto = new utils.Protocol(this.log);\n      proto.addRequest('ws-peer', ['multiaddr'], function (socket, peer) {\n        return _this2.emit('peer', peer);\n      });\n      proto.addRequest('ss-incomming', ['string', 'multiaddr', 'function'], this._incommingDial.bind(this));\n      proto.handleSocket(_io);\n    }\n    /**\n      * Disconnects from signalling server\n      * @returns {undefined}\n      * @private\n      */\n\n  }, {\n    key: \"_down\",\n    value: function _down() {\n      if (!this.io) {\n        return;\n      }\n\n      this.io.disconnect();\n      this.emit('close');\n      delete this.io;\n    }\n    /**\n      * Performs a cryptoChallenge\n      * @param {function} callback - callback\n      * @returns {undefined}\n      * @private\n      */\n\n  }, {\n    key: \"_cryptoChallenge\",\n    value: function _cryptoChallenge(callback) {\n      var _this3 = this;\n\n      if (!this.io) {\n        return callback(new Error('Not connected'));\n      }\n\n      var pubKeyStr = this.canCrypto ? crypto.keys.marshalPublicKey(this.id.pubKey).toString('hex') : '';\n      var maStr = this.ma.toString();\n      this.io.emit('ss-join', maStr, pubKeyStr, function (err, sig) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (sig) {\n          if (!_this3.canCrypto) {\n            _this3._down();\n\n            return callback(new Error(\"Can't sign cryptoChallenge: No id provided\"));\n          }\n\n          _this3.log('performing cryptoChallenge');\n\n          _this3.id.privKey.sign(Buffer.from(sig), function (err, signature) {\n            if (err) {\n              return callback(err);\n            }\n\n            _this3.signature = signature.toString('hex');\n\n            _this3._join(callback);\n          });\n        } else {\n          if (!_this3.flag) {\n            _this3._down();\n\n            return callback(new Error('Tried to listen on a server with crypto challenge disabled!\\n    This is prohibited by default and can lead to security issues!\\n    Please set \"allowJoinWithDisabledChallenge\" to true in the constructor options (but only if you know what you are doing)!'));\n          }\n\n          _this3.signature = '_';\n          callback();\n        }\n      });\n    }\n    /**\n      * Performs a cryptoChallenge when no signature is found\n      * @param {function} cb - callback\n      * @returns {undefined}\n      * @private\n      */\n\n  }, {\n    key: \"_crypto\",\n    value: function _crypto(cb) {\n      var _this4 = this;\n\n      cb = cb ? once(cb) : noop;\n      this.log('joining');\n\n      if (!this.io) {\n        return cb(new Error('Not connected'));\n      }\n\n      if (this.signature) {\n        this._join(function (err, needNewChallenge) {\n          if (needNewChallenge) {\n            return _this4.cryptoChallenge(cb);\n          }\n\n          cb(err);\n        });\n      } else {\n        this._cryptoChallenge(cb);\n      }\n    }\n    /**\n      * Emits ss-join with the multiaddr and signature\n      *\n      * @param {function} cb - callback\n      * @returns {undefined}\n      * @private\n      */\n\n  }, {\n    key: \"_join\",\n    value: function _join(cb) {\n      this.io.emit('ss-join', this.ma.toString(), this.signature, cb);\n    }\n    /**\n      * Handles incomming dials\n      * @listens ss-incomming\n      * @param {socket.io_client} socket\n      * @param {string} dialId - Unique id for this dial\n      * @param {string} dialFrom - Multiaddr as string\n      * @param {function} cb - callback\n      * @returns {undefined}\n      * @private\n      */\n\n  }, {\n    key: \"_incommingDial\",\n    value: function _incommingDial(socket, dialId, dialFrom, cb) {\n      this.log('dial#' + dialId + ' incomming from', dialFrom);\n      var ma = multiaddr(dialFrom);\n      var source = this.io.createSource(dialId + '.dialer');\n      var sink = this.io.createSink(dialId + '.listener');\n      cb();\n      var conn = new Connection({\n        sink: sink,\n        source: source\n      }, {\n        getObservedAddrs: function getObservedAddrs(cb) {\n          return cb(null, [ma]);\n        }\n      });\n      this.emit('connection', conn);\n\n      this._handler(conn);\n    } // public functions\n\n    /**\n      * Listens on a multiaddr\n      * @param {Multiaddr} ma\n      * @param {function} callback\n      * @returns {undefined}\n      */\n\n  }, {\n    key: \"listen\",\n    value: function listen(ma, callback) {\n      var _this5 = this;\n\n      this.ma = ma;\n      this.server = cleanUrlSIO(ma);\n      this.listeners_list[this.server] = this;\n      callback = callback ? once(callback) : noop;\n\n      if (this.connected) {\n        // listener was .close()'d yet not all conns disconnected. we're still connected, so don't do anything\n        this.closing = false;\n        return setImmediate(function () {\n          return callback();\n        });\n      }\n\n      series([function (cb) {\n        return _this5._up(cb);\n      }, function (cb) {\n        return _this5._crypto(cb);\n      }], function (err) {\n        if (err) {\n          // Error connecting to WebSocket\n          if (err.description && err.description.code === 'ENOTFOUND') {\n            var hostname = err.description.hostname;\n            err = Object.assign(new Error(\"WebSocket connection failed on \".concat(hostname)), {\n              code: ERRORS.ERR_WS_STAR_WEBSOCKET_CONNECTION\n            });\n          }\n\n          _this5.log('error', err);\n\n          if (!(err instanceof Error)) err = new Error(err);\n\n          _this5._down();\n\n          _this5.emit('error', err);\n\n          _this5.emit('close');\n\n          return callback(err);\n        }\n\n        _this5.log('success');\n\n        _this5.connected = true;\n\n        _this5.io.on('reconnect', function () {\n          // force to get a new signature\n          _this5.signature = null;\n\n          _this5._crypto(function (err) {\n            if (err) {\n              _this5.log('reconnect error', err);\n\n              _this5.emit('error', err);\n            } else _this5.log('reconnected');\n          });\n        });\n\n        _this5.emit('listening');\n\n        callback();\n      });\n    }\n    /**\n      * Gets the addresses the listener listens on\n      * @param {function} callback\n      * @returns {undefined}\n      */\n\n  }, {\n    key: \"getAddrs\",\n    value: function getAddrs(callback) {\n      var _this6 = this;\n\n      setImmediate(function () {\n        return callback(null, _this6.ma ? [_this6.ma] : []);\n      });\n    }\n  }, {\n    key: \"maybeClose\",\n    value: function maybeClose() {\n      if (!this.activeConnections && this.closing) {\n        this.connected = false;\n        this.closing = false;\n        this.log('no more connections and listener is offline - closing');\n\n        this._down();\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close(callback) {\n      callback = callback ? once(callback) : noop;\n      this.closing = true; // will close once the last connection quits\n\n      this.maybeClose();\n      callback();\n    }\n  }, {\n    key: \"stateWatch\",\n    value: function stateWatch(sink, source) {\n      var _this7 = this;\n\n      var cstate = {\n        sink: true,\n        source: true\n      };\n\n      var watch = function watch(name) {\n        return pull.through(function (v) {\n          return v;\n        }, function (e) {\n          cstate[name] = false;\n\n          if (!cstate.sink && !cstate.source) {\n            _this7.maybeClose();\n          }\n        });\n      };\n\n      this.conns.push(cstate);\n      return {\n        sink: pull(watch('sink'), sink),\n        source: pull(source, watch('source'))\n      };\n    } // called from transport\n\n    /**\n      * Dials a peer\n      * @param {Multiaddr} ma - Multiaddr to dial to\n      * @param {Object} options\n      * @param {function} callback\n      * @returns {undefined}\n      */\n\n  }, {\n    key: \"dial\",\n    value: function dial(ma, options, callback) {\n      var _this8 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      var _ma = multiaddr(ma);\n\n      var conn = new Connection(null);\n      var dialId = uuid();\n      var dlog = this.log.bind(log, 'dial#' + dialId);\n      callback = callback ? once(callback) : noop;\n      var io = this.io;\n\n      if (!io) {\n        return callback(new Error('Not listening'));\n      }\n\n      var sink = io.createSink(dialId + '.dialer');\n      dlog('dialing', ma.toString()); // \"multiaddr\", \"multiaddr\", \"string\", \"function\" - dialFrom, dialTo, dialId, cb\n\n      io.emit('ss-dial', this.ma.toString(), ma.toString(), dialId, function (err) {\n        if (err) return callback(err instanceof Error ? err : new Error(err));\n        dlog(err ? 'error: ' + err.toString() : 'success');\n        var source = io.createSource(dialId + '.listener');\n        conn.setInnerConn(_this8.stateWatch(sink, source), {\n          getObservedAddrs: function getObservedAddrs(cb) {\n            return cb(null, [_ma]);\n          }\n        });\n        callback(null, conn);\n      });\n      return conn;\n    }\n  }, {\n    key: \"activeConnections\",\n    get: function get() {\n      this.conns = this.conns.filter(function (c) {\n        return c.sink || c.source;\n      });\n      return Boolean(this.conns.length);\n    }\n  }]);\n\n  return Listener;\n}(EE);\n\nmodule.exports = Listener;","map":null,"metadata":{},"sourceType":"script"}