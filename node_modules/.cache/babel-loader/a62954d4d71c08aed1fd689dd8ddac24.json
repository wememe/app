{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bytes_1 = require(\"./utils/bytes\");\n\nvar hash_1 = require(\"./utils/hash\");\n\nvar hdnode_1 = require(\"./utils/hdnode\");\n\nvar json_wallet_1 = require(\"./utils/json-wallet\");\n\nvar keccak256_1 = require(\"./utils/keccak256\");\n\nvar properties_1 = require(\"./utils/properties\");\n\nvar random_bytes_1 = require(\"./utils/random-bytes\");\n\nvar secretStorage = __importStar(require(\"./utils/secret-storage\"));\n\nvar signing_key_1 = require(\"./utils/signing-key\");\n\nvar transaction_1 = require(\"./utils/transaction\"); // Imported Abstracts\n\n\nvar abstract_signer_1 = require(\"./abstract-signer\");\n\nvar abstract_provider_1 = require(\"./providers/abstract-provider\");\n\nvar errors = __importStar(require(\"./errors\"));\n\nvar Wallet =\n/** @class */\nfunction (_super) {\n  __extends(Wallet, _super);\n\n  function Wallet(privateKey, provider) {\n    var _this = _super.call(this) || this;\n\n    errors.checkNew(_this, Wallet); // Make sure we have a valid signing key\n\n    if (signing_key_1.SigningKey.isSigningKey(privateKey)) {\n      properties_1.defineReadOnly(_this, 'signingKey', privateKey);\n    } else {\n      properties_1.defineReadOnly(_this, 'signingKey', new signing_key_1.SigningKey(privateKey));\n    }\n\n    properties_1.defineReadOnly(_this, 'provider', provider);\n    return _this;\n  }\n\n  Object.defineProperty(Wallet.prototype, \"address\", {\n    get: function get() {\n      return this.signingKey.address;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Wallet.prototype, \"mnemonic\", {\n    get: function get() {\n      return this.signingKey.mnemonic;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Wallet.prototype, \"path\", {\n    get: function get() {\n      return this.signingKey.path;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Wallet.prototype, \"privateKey\", {\n    get: function get() {\n      return this.signingKey.privateKey;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   *  Create a new instance of this Wallet connected to provider.\n   */\n\n  Wallet.prototype.connect = function (provider) {\n    if (!abstract_provider_1.Provider.isProvider(provider)) {\n      errors.throwError('invalid provider', errors.INVALID_ARGUMENT, {\n        argument: 'provider',\n        value: provider\n      });\n    }\n\n    return new Wallet(this.signingKey, provider);\n  };\n\n  Wallet.prototype.getAddress = function () {\n    return Promise.resolve(this.address);\n  };\n\n  Wallet.prototype.sign = function (transaction) {\n    var _this = this;\n\n    return properties_1.resolveProperties(transaction).then(function (tx) {\n      var rawTx = transaction_1.serialize(tx);\n\n      var signature = _this.signingKey.signDigest(keccak256_1.keccak256(rawTx));\n\n      return transaction_1.serialize(tx, signature);\n    });\n  };\n\n  Wallet.prototype.signMessage = function (message) {\n    return Promise.resolve(bytes_1.joinSignature(this.signingKey.signDigest(hash_1.hashMessage(message))));\n  };\n\n  Wallet.prototype.getBalance = function (blockTag) {\n    if (!this.provider) {\n      throw new Error('missing provider');\n    }\n\n    return this.provider.getBalance(this.address, blockTag);\n  };\n\n  Wallet.prototype.getTransactionCount = function (blockTag) {\n    if (!this.provider) {\n      throw new Error('missing provider');\n    }\n\n    return this.provider.getTransactionCount(this.address, blockTag);\n  };\n\n  Wallet.prototype.sendTransaction = function (transaction) {\n    var _this = this;\n\n    if (!this.provider) {\n      throw new Error('missing provider');\n    }\n\n    if (transaction.nonce == null) {\n      transaction = properties_1.shallowCopy(transaction);\n      transaction.nonce = this.getTransactionCount(\"pending\");\n    }\n\n    return transaction_1.populateTransaction(transaction, this.provider, this.address).then(function (tx) {\n      return _this.sign(tx).then(function (signedTransaction) {\n        return _this.provider.sendTransaction(signedTransaction);\n      });\n    });\n  };\n\n  Wallet.prototype.encrypt = function (password, options, progressCallback) {\n    if (typeof options === 'function' && !progressCallback) {\n      progressCallback = options;\n      options = {};\n    }\n\n    if (progressCallback && typeof progressCallback !== 'function') {\n      throw new Error('invalid callback');\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    if (this.mnemonic) {\n      // Make sure we don't accidentally bubble the mnemonic up the call-stack\n      options = properties_1.shallowCopy(options); // Set the mnemonic and path\n\n      options.mnemonic = this.mnemonic;\n      options.path = this.path;\n    }\n\n    return secretStorage.encrypt(this.privateKey, password, options, progressCallback);\n  };\n  /**\n   *  Static methods to create Wallet instances.\n   */\n\n\n  Wallet.createRandom = function (options) {\n    var entropy = random_bytes_1.randomBytes(16);\n\n    if (!options) {\n      options = {};\n    }\n\n    if (options.extraEntropy) {\n      entropy = bytes_1.arrayify(keccak256_1.keccak256(bytes_1.concat([entropy, options.extraEntropy])).substring(0, 34));\n    }\n\n    var mnemonic = hdnode_1.entropyToMnemonic(entropy, options.locale);\n    return Wallet.fromMnemonic(mnemonic, options.path, options.locale);\n  };\n\n  Wallet.fromEncryptedJson = function (json, password, progressCallback) {\n    if (json_wallet_1.isCrowdsaleWallet(json)) {\n      try {\n        if (progressCallback) {\n          progressCallback(0);\n        }\n\n        var privateKey = secretStorage.decryptCrowdsale(json, password);\n\n        if (progressCallback) {\n          progressCallback(1);\n        }\n\n        return Promise.resolve(new Wallet(privateKey));\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    } else if (json_wallet_1.isSecretStorageWallet(json)) {\n      return secretStorage.decrypt(json, password, progressCallback).then(function (signingKey) {\n        return new Wallet(signingKey);\n      });\n    }\n\n    return Promise.reject('invalid wallet JSON');\n  };\n\n  Wallet.fromMnemonic = function (mnemonic, path, wordlist) {\n    if (!path) {\n      path = hdnode_1.defaultPath;\n    }\n\n    return new Wallet(hdnode_1.fromMnemonic(mnemonic, wordlist).derivePath(path));\n  };\n\n  return Wallet;\n}(abstract_signer_1.Signer);\n\nexports.Wallet = Wallet;","map":null,"metadata":{},"sourceType":"script"}