{"ast":null,"code":"'use strict';\n\nvar BitcoinjsBlock = require('bitcoinjs-lib').Block;\n\nvar CID = require('cids');\n\nvar multihashes = require('multihashes');\n\nvar multihashing = require('multihashing-async');\n\nvar waterfall = require('async/waterfall');\n\nvar BITCOIN_BLOCK_HEADER_SIZE = 80;\n/**\n * @callback SerializeCallback\n * @param {?Error} error - Error if serialization failed\n * @param {?Buffer} binaryBlob - Binary Bitcoin block if serialization was\n *   successful\n */\n\n/**\n * Serialize internal representation into a binary Bitcoin block.\n *\n * @param {BitcoinBlock} dagNode - Internal representation of a Bitcoin block\n * @param {SerializeCallback} callback - Callback that handles the\n *   return value\n * @returns {void}\n */\n\nvar serialize = function serialize(dagNode, callback) {\n  var err = null;\n  var binaryBlob;\n\n  try {\n    binaryBlob = dagNode.toBuffer(true);\n  } catch (serializeError) {\n    err = serializeError;\n  } finally {\n    callback(err, binaryBlob);\n  }\n};\n/**\n * @callback DeserializeCallback\n * @param {?Error} error - Error if deserialization failed\n * @param {?BitcoinBlock} dagNode - Internal representation of a Bitcoin block\n *   if deserialization was successful\n */\n\n/**\n * Deserialize Bitcoin block into the internal representation,\n *\n * @param {Buffer} binaryBlob - Binary representation of a Bitcoin block\n * @param {DeserializeCallback} callback - Callback that handles the\n *   return value\n * @returns {void}\n */\n\n\nvar deserialize = function deserialize(binaryBlob, callback) {\n  if (binaryBlob.length !== BITCOIN_BLOCK_HEADER_SIZE) {\n    var err = new Error(\"Bitcoin block header needs to be \".concat(BITCOIN_BLOCK_HEADER_SIZE, \" bytes\"));\n    return callback(err);\n  }\n\n  var dagNode = BitcoinjsBlock.fromBuffer(binaryBlob);\n  callback(null, dagNode);\n};\n/**\n * @callback CidCallback\n * @param {?Error} error - Error if getting the CID failed\n * @param {?CID} cid - CID if call was successful\n */\n\n/**\n * Get the CID of the DAG-Node.\n *\n * @param {BitcoinBlock} dagNode - Internal representation of a Bitcoin block\n * @param {Object} [options] - Options to create the CID\n * @param {number} [options.version=1] - CID version number\n * @param {string} [options.hashAlg='dbl-sha2-256'] - Hashing algorithm\n * @param {CidCallback} callback - Callback that handles the return value\n * @returns {void}\n */\n\n\nvar cid = function cid(dagNode, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {}; // avoid deadly embrace between resolver and util\n\n  var hashAlg = options.hashAlg || require('./resolver').defaultHashAlg;\n\n  var version = typeof options.version === 'undefined' ? 1 : options.version;\n  waterfall([function (cb) {\n    try {\n      multihashing(dagNode.toBuffer(true), hashAlg, cb);\n    } catch (err) {\n      cb(err);\n    }\n  }, function (mh, cb) {\n    return cb(null, new CID(version, 'bitcoin-block', mh));\n  }], callback);\n}; // Convert a Bitcoin hash (as Buffer) to a CID\n\n\nvar hashToCid = function hashToCid(hash) {\n  // avoid deadly embrace between resolver and util\n  var defaultHashAlg = require('./resolver').defaultHashAlg;\n\n  var multihash = multihashes.encode(hash, defaultHashAlg);\n  var cidVersion = 1;\n  var cid = new CID(cidVersion, 'bitcoin-block', multihash);\n  return cid;\n};\n\nmodule.exports = {\n  hashToCid: hashToCid,\n  BITCOIN_BLOCK_HEADER_SIZE: BITCOIN_BLOCK_HEADER_SIZE,\n  // Public API\n  cid: cid,\n  deserialize: deserialize,\n  serialize: serialize\n};","map":null,"metadata":{},"sourceType":"script"}