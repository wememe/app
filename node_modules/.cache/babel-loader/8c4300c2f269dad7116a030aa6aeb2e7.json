{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar unixfsEngine = require('ipfs-unixfs-engine');\n\nvar importer = unixfsEngine.importer;\nvar exporter = unixfsEngine.exporter;\n\nvar promisify = require('promisify-es6');\n\nvar pull = require('pull-stream');\n\nvar sort = require('pull-sort');\n\nvar pushable = require('pull-pushable');\n\nvar toStream = require('pull-stream-to-stream');\n\nvar toPull = require('stream-to-pull-stream');\n\nvar deferred = require('pull-defer');\n\nvar waterfall = require('async/waterfall');\n\nvar isStream = require('is-stream');\n\nvar isSource = require('is-pull-stream').isSource;\n\nvar Duplex = require('readable-stream').Duplex;\n\nvar OtherBuffer = require('buffer').Buffer;\n\nvar CID = require('cids');\n\nvar toB58String = require('multihashes').toB58String;\n\nvar errCode = require('err-code');\n\nvar parseChunkerString = require('../utils').parseChunkerString;\n\nvar WRAPPER = 'wrapper/';\n\nfunction noop() {}\n\nfunction prepareFile(self, opts, file, callback) {\n  opts = opts || {};\n  var cid = new CID(file.multihash);\n\n  if (opts.cidVersion === 1) {\n    cid = cid.toV1();\n  }\n\n  waterfall([function (cb) {\n    return opts.onlyHash ? cb(null, file) : self.object.get(file.multihash, Object.assign({}, opts, {\n      preload: false\n    }), cb);\n  }, function (node, cb) {\n    var b58Hash = cid.toBaseEncodedString();\n    var size = node.size;\n\n    if (Buffer.isBuffer(node)) {\n      size = node.length;\n    }\n\n    cb(null, {\n      path: opts.wrapWithDirectory ? file.path.substring(WRAPPER.length) : file.path || b58Hash,\n      hash: b58Hash,\n      size: size\n    });\n  }], callback);\n}\n\nfunction normalizeContent(opts, content) {\n  if (!Array.isArray(content)) {\n    content = [content];\n  }\n\n  return content.map(function (data) {\n    // Buffer input\n    if (Buffer.isBuffer(data)) {\n      data = {\n        path: '',\n        content: pull.values([data])\n      };\n    } // Readable stream input\n\n\n    if (isStream.readable(data)) {\n      data = {\n        path: '',\n        content: toPull.source(data)\n      };\n    }\n\n    if (isSource(data)) {\n      data = {\n        path: '',\n        content: data\n      };\n    }\n\n    if (data && data.content && typeof data.content !== 'function') {\n      if (Buffer.isBuffer(data.content)) {\n        data.content = pull.values([data.content]);\n      }\n\n      if (isStream.readable(data.content)) {\n        data.content = toPull.source(data.content);\n      }\n    }\n\n    if (opts.wrapWithDirectory && !data.path) {\n      throw new Error('Must provide a path when wrapping with a directory');\n    }\n\n    if (opts.wrapWithDirectory) {\n      data.path = WRAPPER + data.path;\n    }\n\n    return data;\n  });\n}\n\nfunction preloadFile(self, opts, file) {\n  var isRootFile = opts.wrapWithDirectory ? file.path === '' : !file.path.includes('/');\n  var shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false;\n\n  if (shouldPreload) {\n    self._preload(file.hash);\n  }\n\n  return file;\n}\n\nfunction pinFile(self, opts, file, cb) {\n  // Pin a file if it is the root dir of a recursive add or the single file\n  // of a direct add.\n  var pin = 'pin' in opts ? opts.pin : true;\n  var isRootDir = !file.path.includes('/');\n  var shouldPin = pin && isRootDir && !opts.onlyHash && !opts.hashAlg;\n\n  if (shouldPin) {\n    return self.pin.add(file.hash, {\n      preload: false\n    }, function (err) {\n      return cb(err, file);\n    });\n  } else {\n    cb(null, file);\n  }\n}\n\nvar AddHelper =\n/*#__PURE__*/\nfunction (_Duplex) {\n  _inherits(AddHelper, _Duplex);\n\n  function AddHelper(pullStream, push, options) {\n    var _this;\n\n    _classCallCheck(this, AddHelper);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AddHelper).call(this, Object.assign({\n      objectMode: true\n    }, options)));\n    _this._pullStream = pullStream;\n    _this._pushable = push;\n    _this._waitingPullFlush = [];\n    return _this;\n  }\n\n  _createClass(AddHelper, [{\n    key: \"_read\",\n    value: function _read() {\n      var _this2 = this;\n\n      this._pullStream(null, function (end, data) {\n        while (_this2._waitingPullFlush.length) {\n          var cb = _this2._waitingPullFlush.shift();\n\n          cb();\n        }\n\n        if (end) {\n          if (end instanceof Error) {\n            _this2.emit('error', end);\n          }\n        } else {\n          _this2.push(data);\n        }\n      });\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, encoding, callback) {\n      this._waitingPullFlush.push(callback);\n\n      this._pushable.push(chunk);\n    }\n  }]);\n\n  return AddHelper;\n}(Duplex);\n\nmodule.exports = function files(self) {\n  function _addPullStream() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var chunkerOptions;\n\n    try {\n      chunkerOptions = parseChunkerString(options.chunker);\n    } catch (err) {\n      return pull.map(function () {\n        throw err;\n      });\n    }\n\n    var opts = Object.assign({}, {\n      shardSplitThreshold: self._options.EXPERIMENTAL.sharding ? 1000 : Infinity\n    }, options, chunkerOptions);\n\n    if (opts.hashAlg && opts.cidVersion !== 1) {\n      opts.cidVersion = 1;\n    }\n\n    var total = 0;\n    var prog = opts.progress || noop;\n\n    var progress = function progress(bytes) {\n      total += bytes;\n      prog(total);\n    };\n\n    opts.progress = progress;\n    return pull(pull.map(normalizeContent.bind(null, opts)), pull.flatten(), importer(self._ipld, opts), pull.asyncMap(prepareFile.bind(null, self, opts)), pull.map(preloadFile.bind(null, self, opts)), pull.asyncMap(pinFile.bind(null, self, opts)));\n  }\n\n  function _catPullStream(ipfsPath, options) {\n    if (typeof ipfsPath === 'function') {\n      throw new Error('You must supply an ipfsPath');\n    }\n\n    options = options || {};\n    ipfsPath = normalizePath(ipfsPath);\n    var pathComponents = ipfsPath.split('/');\n    var restPath = normalizePath(pathComponents.slice(1).join('/'));\n\n    var filterFile = function filterFile(file) {\n      return restPath && file.path === restPath || file.path === ipfsPath;\n    };\n\n    if (options.preload !== false) {\n      self._preload(pathComponents[0]);\n    }\n\n    var d = deferred.source();\n    pull(exporter(ipfsPath, self._ipld, options), pull.collect(function (err, files) {\n      if (err) {\n        return d.abort(err);\n      }\n\n      if (files && files.length > 1) {\n        files = files.filter(filterFile);\n      }\n\n      if (!files || !files.length) {\n        return d.abort(new Error('No such file'));\n      }\n\n      var file = files[0];\n      var content = file.content;\n\n      if (!content && file.type === 'dir') {\n        return d.abort(new Error('this dag node is a directory'));\n      }\n\n      d.resolve(content);\n    }));\n    return d;\n  }\n\n  function _lsPullStreamImmutable(ipfsPath, options) {\n    options = options || {};\n    var path = normalizePath(ipfsPath);\n    var recursive = options.recursive;\n    var pathComponents = path.split('/');\n    var pathDepth = pathComponents.length;\n    var maxDepth = recursive ? global.Infinity : pathDepth;\n    options.maxDepth = options.maxDepth || maxDepth;\n\n    if (options.preload !== false) {\n      self._preload(pathComponents[0]);\n    }\n\n    return pull(exporter(ipfsPath, self._ipld, options), pull.filter(function (node) {\n      return recursive ? node.depth >= pathDepth : node.depth === pathDepth;\n    }), pull.map(function (node) {\n      var cid = new CID(node.hash);\n      node = Object.assign({}, node, {\n        hash: cid.toBaseEncodedString()\n      });\n      delete node.content;\n      return node;\n    }));\n  }\n\n  return {\n    add: function () {\n      var add = promisify(function (data, options, callback) {\n        if (typeof options === 'function') {\n          callback = options;\n          options = {};\n        }\n\n        options = options || {};\n        var ok = Buffer.isBuffer(data) || isStream.readable(data) || Array.isArray(data) || OtherBuffer.isBuffer(data) || typeof data === 'object' || isSource(data);\n\n        if (!ok) {\n          return callback(new Error('first arg must be a buffer, readable stream, pull stream, an object or array of objects'));\n        } // CID v0 is for multihashes encoded with sha2-256\n\n\n        if (options.hashAlg && options.cidVersion !== 1) {\n          options.cidVersion = 1;\n        }\n\n        pull(pull.values([data]), _addPullStream(options), sort(function (a, b) {\n          if (a.path < b.path) return 1;\n          if (a.path > b.path) return -1;\n          return 0;\n        }), pull.collect(callback));\n      });\n      return function () {\n        var args = Array.from(arguments); // If we files.add(<pull stream>), then promisify thinks the pull stream\n        // is a callback! Add an empty options object in this case so that a\n        // promise is returned.\n\n        if (args.length === 1 && isSource(args[0])) {\n          args.push({});\n        }\n\n        return add.apply(null, args);\n      };\n    }(),\n    addReadableStream: function addReadableStream(options) {\n      options = options || {};\n      var p = pushable();\n      var s = pull(p, _addPullStream(options));\n      var retStream = new AddHelper(s, p);\n      retStream.once('finish', function () {\n        return p.end();\n      });\n      return retStream;\n    },\n    addPullStream: _addPullStream,\n    cat: promisify(function (ipfsPath, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      if (typeof callback !== 'function') {\n        throw new Error('Please supply a callback to ipfs.files.cat');\n      }\n\n      pull(_catPullStream(ipfsPath, options), pull.collect(function (err, buffers) {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, Buffer.concat(buffers));\n      }));\n    }),\n    catReadableStream: function catReadableStream(ipfsPath, options) {\n      return toStream.source(_catPullStream(ipfsPath, options));\n    },\n    catPullStream: function catPullStream(ipfsPath, options) {\n      return _catPullStream(ipfsPath, options);\n    },\n    get: promisify(function (ipfsPath, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n\n      if (options.preload !== false) {\n        var pathComponents;\n\n        try {\n          pathComponents = normalizePath(ipfsPath).split('/');\n        } catch (err) {\n          return setImmediate(function () {\n            return callback(errCode(err, 'ERR_INVALID_PATH'));\n          });\n        }\n\n        self._preload(pathComponents[0]);\n      }\n\n      pull(exporter(ipfsPath, self._ipld, options), pull.asyncMap(function (file, cb) {\n        if (file.content) {\n          pull(file.content, pull.collect(function (err, buffers) {\n            if (err) {\n              return cb(err);\n            }\n\n            file.content = Buffer.concat(buffers);\n            cb(null, file);\n          }));\n        } else {\n          cb(null, file);\n        }\n      }), pull.collect(callback));\n    }),\n    getReadableStream: function getReadableStream(ipfsPath, options) {\n      options = options || {};\n\n      if (options.preload !== false) {\n        var pathComponents;\n\n        try {\n          pathComponents = normalizePath(ipfsPath).split('/');\n        } catch (err) {\n          return toStream.source(pull.error(errCode(err, 'ERR_INVALID_PATH')));\n        }\n\n        self._preload(pathComponents[0]);\n      }\n\n      return toStream.source(pull(exporter(ipfsPath, self._ipld, options), pull.map(function (file) {\n        if (file.content) {\n          file.content = toStream.source(file.content);\n          file.content.pause();\n        }\n\n        return file;\n      })));\n    },\n    getPullStream: function getPullStream(ipfsPath, options) {\n      options = options || {};\n\n      if (options.preload !== false) {\n        var pathComponents;\n\n        try {\n          pathComponents = normalizePath(ipfsPath).split('/');\n        } catch (err) {\n          return pull.error(errCode(err, 'ERR_INVALID_PATH'));\n        }\n\n        self._preload(pathComponents[0]);\n      }\n\n      return exporter(ipfsPath, self._ipld, options);\n    },\n    lsImmutable: promisify(function (ipfsPath, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      pull(_lsPullStreamImmutable(ipfsPath, options), pull.collect(function (err, values) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        callback(null, values);\n      }));\n    }),\n    lsReadableStreamImmutable: function lsReadableStreamImmutable(ipfsPath, options) {\n      return toStream.source(_lsPullStreamImmutable(ipfsPath, options));\n    },\n    lsPullStreamImmutable: _lsPullStreamImmutable\n  };\n};\n\nfunction normalizePath(path) {\n  if (Buffer.isBuffer(path)) {\n    path = toB58String(path);\n  }\n\n  if (CID.isCID(path)) {\n    path = path.toBaseEncodedString();\n  }\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length);\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  return path;\n}","map":null,"metadata":{},"sourceType":"script"}