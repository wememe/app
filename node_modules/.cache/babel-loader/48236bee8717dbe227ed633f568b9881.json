{"ast":null,"code":"'use strict';\n\nvar _toArray = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toArray\");\n\nvar promisify = require('promisify-es6');\n\nvar map = require('async/map');\n\nvar isIpfs = require('is-ipfs');\n\nvar CID = require('cids');\n\nvar ERR_BAD_PATH = 'ERR_BAD_PATH';\nexports.OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.';\n/**\n * Break an ipfs-path down into it's hash and an array of links.\n *\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} ipfsPath An ipfs-path\n * @return {Object}            { hash: base58 string, links: [string], ?err: Error }\n * @throws on an invalid @param ipfsPath\n */\n\nfunction parseIpfsPath(ipfsPath) {\n  var invalidPathErr = new Error('invalid ipfs ref path');\n  ipfsPath = ipfsPath.replace(/^\\/ipfs\\//, '');\n  var matched = ipfsPath.match(/([^/]+(?:\\/[^/]+)*)\\/?$/);\n\n  if (!matched) {\n    throw invalidPathErr;\n  }\n\n  var _matched$1$split = matched[1].split('/'),\n      _matched$1$split2 = _toArray(_matched$1$split),\n      hash = _matched$1$split2[0],\n      links = _matched$1$split2.slice(1); // check that a CID can be constructed with the hash\n\n\n  if (isIpfs.cid(hash)) {\n    return {\n      hash: hash,\n      links: links\n    };\n  } else {\n    throw invalidPathErr;\n  }\n}\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n * If the received string is not a valid ipfs path, an error will be returned\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} pathStr An ipfs-path, or ipns-path or a cid\n * @return {String} ipfs-path or ipns-path\n * @throws on an invalid @param ipfsPath\n */\n\n\nvar normalizePath = function normalizePath(pathStr) {\n  if (isIpfs.cid(pathStr)) {\n    return \"/ipfs/\".concat(pathStr);\n  } else if (isIpfs.path(pathStr)) {\n    return pathStr;\n  } else {\n    throw Object.assign(new Error(\"invalid \".concat(pathStr, \" path\")), {\n      code: ERR_BAD_PATH\n    });\n  }\n};\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path.\n *\n * Accepts formats:\n *  - <base58 string>\n *  - <base58 string>/link/to/venus\n *  - /ipfs/<base58 string>/link/to/pluto\n *  - multihash Buffer\n *  - Arrays of the above\n *\n * @param  {IPFS}               objectAPI The IPFS object api\n * @param  {Described above}    ipfsPaths A single or collection of ipfs-paths\n * @param  {Function<err, res>} callback res is Array<Buffer(hash)>\n *                              if no callback is passed, returns a Promise\n * @return {Promise|void}\n */\n\n\nvar resolvePath = promisify(function (objectAPI, ipfsPaths, callback) {\n  if (!Array.isArray(ipfsPaths)) {\n    ipfsPaths = [ipfsPaths];\n  }\n\n  map(ipfsPaths, function (path, cb) {\n    if (typeof path !== 'string') {\n      var cid;\n\n      try {\n        cid = new CID(path);\n      } catch (err) {\n        return cb(err);\n      }\n\n      return cb(null, cid.buffer);\n    }\n\n    var parsedPath;\n\n    try {\n      parsedPath = exports.parseIpfsPath(path);\n    } catch (err) {\n      return cb(err);\n    }\n\n    var rootHash = new CID(parsedPath.hash);\n    var rootLinks = parsedPath.links;\n\n    if (!rootLinks.length) {\n      return cb(null, rootHash.buffer);\n    }\n\n    objectAPI.get(rootHash.multihash, follow.bind(null, rootLinks)); // recursively follow named links to the target node\n\n    function follow(links, err, obj) {\n      if (err) {\n        return cb(err);\n      }\n\n      if (!links.length) {\n        // done tracing, obj is the target node\n        return cb(null, obj.multihash);\n      }\n\n      var linkName = links[0];\n      var nextObj = obj.links.find(function (link) {\n        return link.name === linkName;\n      });\n\n      if (!nextObj) {\n        return cb(new Error(\"no link named \\\"\".concat(linkName, \"\\\" under \").concat(obj.toJSON().multihash)));\n      }\n\n      objectAPI.get(nextObj.multihash, follow.bind(null, links.slice(1)));\n    }\n  }, callback);\n});\n/**\n * Parses chunker string into options used by DAGBuilder in ipfs-unixfs-engine\n *\n *\n * @param  {String}   chunker Chunker algorithm supported formats:\n *                    \"size-{size}\"\n *                    \"rabin\"\n *                    \"rabin-{avg}\"\n *                    \"rabin-{min}-{avg}-{max}\"\n *\n * @return {Object}   Chunker options for DAGBuilder\n */\n\nfunction parseChunkerString(chunker) {\n  if (!chunker) {\n    return {\n      chunker: 'fixed'\n    };\n  } else if (chunker.startsWith('size-')) {\n    var sizeStr = chunker.split('-')[1];\n    var size = parseInt(sizeStr);\n\n    if (isNaN(size)) {\n      throw new Error('Chunker parameter size must be an integer');\n    }\n\n    return {\n      chunker: 'fixed',\n      chunkerOptions: {\n        maxChunkSize: size\n      }\n    };\n  } else if (chunker.startsWith('rabin')) {\n    return {\n      chunker: 'rabin',\n      chunkerOptions: parseRabinString(chunker)\n    };\n  } else {\n    throw new Error(\"Unrecognized chunker option: \".concat(chunker));\n  }\n}\n/**\n * Parses rabin chunker string\n *\n * @param  {String}   chunker Chunker algorithm supported formats:\n *                            \"rabin\"\n *                            \"rabin-{avg}\"\n *                            \"rabin-{min}-{avg}-{max}\"\n *\n * @return {Object}   rabin chunker options\n */\n\n\nfunction parseRabinString(chunker) {\n  var options = {};\n  var parts = chunker.split('-');\n\n  switch (parts.length) {\n    case 1:\n      options.avgChunkSize = 262144;\n      break;\n\n    case 2:\n      options.avgChunkSize = parseChunkSize(parts[1], 'avg');\n      break;\n\n    case 4:\n      options.minChunkSize = parseChunkSize(parts[1], 'min');\n      options.avgChunkSize = parseChunkSize(parts[2], 'avg');\n      options.maxChunkSize = parseChunkSize(parts[3], 'max');\n      break;\n\n    default:\n      throw new Error('Incorrect chunker format (expected \"rabin\" \"rabin-[avg]\" or \"rabin-[min]-[avg]-[max]\"');\n  }\n\n  return options;\n}\n\nfunction parseChunkSize(str, name) {\n  var size = parseInt(str);\n\n  if (isNaN(size)) {\n    throw new Error(\"Chunker parameter \".concat(name, \" must be an integer\"));\n  }\n\n  return size;\n}\n\nexports.normalizePath = normalizePath;\nexports.parseIpfsPath = parseIpfsPath;\nexports.resolvePath = resolvePath;\nexports.parseChunkerString = parseChunkerString;","map":null,"metadata":{},"sourceType":"script"}