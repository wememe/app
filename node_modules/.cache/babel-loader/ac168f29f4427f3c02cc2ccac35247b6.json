{"ast":null,"code":"'use strict';\n\nvar through = require('pull-through');\n\nfunction lazyConcat(buffers) {\n  if (buffers.length === 1) return buffers[0];\n  return Buffer.concat(buffers);\n}\n\nfunction lazySlice(buf, begin, end) {\n  if (begin === 0 && end === buf.length) return buf;\n  return buf.slice(begin, end);\n}\n\nmodule.exports = function block(size, opts) {\n  if (!opts) opts = {};\n\n  if (typeof size === 'object') {\n    opts = size;\n    size = opts.size;\n  }\n\n  size = size || 512;\n  var zeroPadding;\n\n  if (opts.nopad) {\n    zeroPadding = false;\n  } else {\n    zeroPadding = typeof opts.zeroPadding !== 'undefined' ? opts.zeroPadding : true;\n  }\n\n  var buffered = [];\n  var bufferedBytes = 0;\n  var bufferSkip = 0;\n  var emittedChunk = false;\n  return through(function transform(data) {\n    if (typeof data === 'number') {\n      data = Buffer.from([data]);\n    }\n\n    bufferedBytes += data.length;\n    buffered.push(data);\n\n    while (bufferedBytes >= size) {\n      var targetLength = 0;\n      var target = [];\n      var index = 0;\n      var b, end, out;\n\n      while (targetLength < size) {\n        b = buffered[index]; // Slice as much as we can from the next buffer.\n\n        end = Math.min(bufferSkip + size - targetLength, b.length);\n        out = lazySlice(b, bufferSkip, end);\n        targetLength += out.length;\n        target.push(out);\n\n        if (end === b.length) {\n          // If that consumes the buffer, move on to the next.\n          index++;\n          bufferSkip = 0;\n        } else {\n          // Otherwise keep track of how much we used.\n          bufferSkip += out.length;\n        }\n      } // Remove all consumed buffers and output the selection.\n\n\n      buffered = buffered.slice(index);\n      bufferedBytes -= targetLength;\n      this.queue(lazyConcat(target));\n      emittedChunk = true;\n    }\n  }, function flush(end) {\n    if (opts.emitEmpty && !emittedChunk || bufferedBytes) {\n      if (zeroPadding) {\n        var zeroes = Buffer.alloc(size - bufferedBytes);\n        zeroes.fill(0);\n        buffered.push(zeroes);\n      }\n\n      if (buffered) {\n        if (buffered.length > 0) {\n          // Don't copy the bufferSkip bytes through concat.\n          buffered[0] = buffered[0].slice(bufferSkip);\n        }\n\n        this.queue(lazyConcat(buffered));\n        buffered = null;\n      }\n    }\n\n    this.queue(null);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}