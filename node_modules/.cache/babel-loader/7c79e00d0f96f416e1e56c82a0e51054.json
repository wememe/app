{"ast":null,"code":"/* @flow */\n'use strict';\n/* :: import type {Batch, Query, QueryResult, Callback} from './' */\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar pull = require('pull-stream');\n\nvar setImmediate = require('async/setImmediate');\n\nvar asyncFilter = require('./utils').asyncFilter;\n\nvar asyncSort = require('./utils').asyncSort;\n\nvar Key = require('./key'); // Errors\n\n\nvar Errors = require('./errors');\n\nvar MemoryDatastore =\n/*#__PURE__*/\nfunction () {\n  /* :: data: {[key: string]: Buffer} */\n  function MemoryDatastore() {\n    _classCallCheck(this, MemoryDatastore);\n\n    this.data = {};\n  }\n\n  _createClass(MemoryDatastore, [{\n    key: \"open\",\n    value: function open(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      setImmediate(callback);\n    }\n  }, {\n    key: \"put\",\n    value: function put(key\n    /* : Key */\n    , val\n    /* : Buffer */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      this.data[key.toString()] = val;\n      setImmediate(callback);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key\n    /* : Key */\n    , callback\n    /* : Callback<Buffer> */\n    )\n    /* : void */\n    {\n      var _this = this;\n\n      this.has(key, function (err, exists) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!exists) {\n          return callback(Errors.notFoundError());\n        }\n\n        callback(null, _this.data[key.toString()]);\n      });\n    }\n  }, {\n    key: \"has\",\n    value: function has(key\n    /* : Key */\n    , callback\n    /* : Callback<bool> */\n    )\n    /* : void */\n    {\n      var _this2 = this;\n\n      setImmediate(function () {\n        callback(null, _this2.data[key.toString()] !== undefined);\n      });\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key\n    /* : Key */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      delete this.data[key.toString()];\n      setImmediate(function () {\n        callback();\n      });\n    }\n  }, {\n    key: \"batch\",\n    value: function batch()\n    /* : Batch<Buffer> */\n    {\n      var _this3 = this;\n\n      var puts = [];\n      var dels = [];\n      return {\n        put: function put(key\n        /* : Key */\n        , value\n        /* : Buffer */\n        )\n        /* : void */\n        {\n          puts.push([key, value]);\n        },\n        delete: function _delete(key\n        /* : Key */\n        )\n        /* : void */\n        {\n          dels.push(key);\n        },\n        commit: function commit(callback\n        /* : Callback<void> */\n        )\n        /* : void */\n        {\n          puts.forEach(function (v) {\n            _this3.data[v[0].toString()] = v[1];\n          });\n          puts = [];\n          dels.forEach(function (key) {\n            delete _this3.data[key.toString()];\n          });\n          dels = [];\n          setImmediate(callback);\n        }\n      };\n    }\n  }, {\n    key: \"query\",\n    value: function query(q\n    /* : Query<Buffer> */\n    )\n    /* : QueryResult<Buffer> */\n    {\n      var _this4 = this;\n\n      var tasks = [pull.keys(this.data), pull.map(function (k) {\n        return {\n          key: new Key(k),\n          value: _this4.data[k]\n        };\n      })];\n      var filters = [];\n\n      if (q.prefix != null) {\n        var prefix = q.prefix;\n        filters.push(function (e, cb) {\n          return cb(null, e.key.toString().startsWith(prefix));\n        });\n      }\n\n      if (q.filters != null) {\n        filters = filters.concat(q.filters);\n      }\n\n      tasks = tasks.concat(filters.map(function (f) {\n        return asyncFilter(f);\n      }));\n\n      if (q.orders != null) {\n        tasks = tasks.concat(q.orders.map(function (o) {\n          return asyncSort(o);\n        }));\n      }\n\n      if (q.offset != null) {\n        var i = 0; // $FlowFixMe\n\n        tasks.push(pull.filter(function () {\n          return i++ >= q.offset;\n        }));\n      }\n\n      if (q.limit != null) {\n        tasks.push(pull.take(q.limit));\n      }\n\n      if (q.keysOnly === true) {\n        tasks.push(pull.map(function (e) {\n          return {\n            key: e.key\n          };\n        }));\n      }\n\n      return pull.apply(null, tasks);\n    }\n  }, {\n    key: \"close\",\n    value: function close(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      setImmediate(callback);\n    }\n  }]);\n\n  return MemoryDatastore;\n}();\n\nmodule.exports = MemoryDatastore;","map":null,"metadata":{},"sourceType":"script"}