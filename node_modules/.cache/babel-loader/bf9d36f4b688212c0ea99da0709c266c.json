{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar SparseArray = require('sparse-array');\n\nvar map = require('async/map');\n\nvar eachSeries = require('async/eachSeries');\n\nvar wrapHash = require('./consumable-hash');\n\nvar defaultOptions = {\n  bits: 8 // TODO: make HAMT a generic NPM package\n\n};\n\nvar Bucket =\n/*#__PURE__*/\nfunction () {\n  function Bucket(options, parent, posAtParent) {\n    _classCallCheck(this, Bucket);\n\n    this._options = Object.assign({}, defaultOptions, options);\n    this._popCount = 0;\n    this._parent = parent;\n    this._posAtParent = posAtParent;\n\n    if (!this._options.hashFn) {\n      throw new Error('please define an options.hashFn');\n    } // make sure we only wrap options.hashFn once in the whole tree\n\n\n    if (!this._options.hash) {\n      this._options.hash = wrapHash(this._options.hashFn);\n    }\n\n    this._children = new SparseArray();\n  }\n\n  _createClass(Bucket, [{\n    key: \"put\",\n    value: function put(key, value, callback) {\n      this._findNewBucketAndPos(key, function (err, place) {\n        if (err) {\n          callback(err);\n          return; // early\n        }\n\n        place.bucket._putAt(place, key, value);\n\n        callback();\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, callback) {\n      this._findChild(key, function (err, child) {\n        if (err) {\n          callback(err);\n        } else {\n          callback(null, child && child.value);\n        }\n      });\n    }\n  }, {\n    key: \"del\",\n    value: function del(key, callback) {\n      this._findPlace(key, function (err, place) {\n        if (err) {\n          callback(err);\n          return; // early\n        }\n\n        var child = place.bucket._at(place.pos);\n\n        if (child && child.key === key) {\n          place.bucket._delAt(place.pos);\n        }\n\n        callback(null);\n      });\n    }\n  }, {\n    key: \"leafCount\",\n    value: function leafCount() {\n      this._children.reduce(function (acc, child) {\n        if (child instanceof Bucket) {\n          return acc + child.leafCount();\n        }\n\n        return acc + 1;\n      }, 0);\n    }\n  }, {\n    key: \"childrenCount\",\n    value: function childrenCount() {\n      return this._children.length;\n    }\n  }, {\n    key: \"onlyChild\",\n    value: function onlyChild(callback) {\n      var _this = this;\n\n      process.nextTick(function () {\n        return callback(null, _this._children.get(0));\n      });\n    }\n  }, {\n    key: \"eachLeafSeries\",\n    value: function eachLeafSeries(iterator, callback) {\n      eachSeries(this._children.compactArray(), function (child, cb) {\n        if (child instanceof Bucket) {\n          child.eachLeafSeries(iterator, cb);\n        } else {\n          iterator(child.key, child.value, cb);\n        }\n      }, callback);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(map, reduce) {\n      // serialize to a custom non-sparse representation\n      return reduce(this._children.reduce(function (acc, child, index) {\n        if (child) {\n          if (child instanceof Bucket) {\n            acc.push(child.serialize(map, reduce));\n          } else {\n            acc.push(map(child, index));\n          }\n        }\n\n        return acc;\n      }, []));\n    }\n  }, {\n    key: \"asyncTransform\",\n    value: function asyncTransform(asyncMap, asyncReduce, callback) {\n      asyncTransformBucket(this, asyncMap, asyncReduce, callback);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.serialize(mapNode, reduceNodes);\n    }\n  }, {\n    key: \"prettyPrint\",\n    value: function prettyPrint() {\n      return JSON.stringify(this.toJSON(), null, '  ');\n    }\n  }, {\n    key: \"tableSize\",\n    value: function tableSize() {\n      return Math.pow(2, this._options.bits);\n    }\n  }, {\n    key: \"_findChild\",\n    value: function _findChild(key, callback) {\n      this._findPlace(key, function (err, result) {\n        if (err) {\n          callback(err);\n          return; // early\n        }\n\n        var child = result.bucket._at(result.pos);\n\n        if (child && child.key === key) {\n          callback(null, child);\n        } else {\n          callback(null, undefined);\n        }\n      });\n    }\n  }, {\n    key: \"_findPlace\",\n    value: function _findPlace(key, callback) {\n      var _this2 = this;\n\n      var hashValue = this._options.hash(key);\n\n      hashValue.take(this._options.bits, function (err, index) {\n        if (err) {\n          callback(err);\n          return; // early\n        }\n\n        var child = _this2._children.get(index);\n\n        if (child instanceof Bucket) {\n          child._findPlace(hashValue, callback);\n        } else {\n          var place = {\n            bucket: _this2,\n            pos: index,\n            hash: hashValue\n          };\n          callback(null, place);\n        }\n      });\n    }\n  }, {\n    key: \"_findNewBucketAndPos\",\n    value: function _findNewBucketAndPos(key, callback) {\n      var _this3 = this;\n\n      this._findPlace(key, function (err, place) {\n        if (err) {\n          callback(err);\n          return; // early\n        }\n\n        var child = place.bucket._at(place.pos);\n\n        if (child && child.key !== key) {\n          // conflict\n          var bucket = new Bucket(_this3._options, place.bucket, place.pos);\n\n          place.bucket._putObjectAt(place.pos, bucket); // put the previous value\n\n\n          bucket._findPlace(child.hash, function (err, newPlace) {\n            if (err) {\n              callback(err);\n              return; // early\n            }\n\n            newPlace.bucket._putAt(newPlace, child.key, child.value);\n\n            bucket._findNewBucketAndPos(place.hash, callback);\n          });\n        } else {\n          // no conflict, we found the place\n          callback(null, place);\n        }\n      });\n    }\n  }, {\n    key: \"_putAt\",\n    value: function _putAt(place, key, value) {\n      this._putObjectAt(place.pos, {\n        key: key,\n        value: value,\n        hash: place.hash\n      });\n    }\n  }, {\n    key: \"_putObjectAt\",\n    value: function _putObjectAt(pos, object) {\n      if (!this._children.get(pos)) {\n        this._popCount++;\n      }\n\n      this._children.set(pos, object);\n    }\n  }, {\n    key: \"_delAt\",\n    value: function _delAt(pos) {\n      if (this._children.get(pos)) {\n        this._popCount--;\n      }\n\n      this._children.unset(pos);\n\n      this._level();\n    }\n  }, {\n    key: \"_level\",\n    value: function _level() {\n      if (this._parent && this._popCount <= 1) {\n        if (this._popCount === 1) {\n          // remove myself from parent, replacing me with my only child\n          var onlyChild = this._children.find(exists);\n\n          if (!(onlyChild instanceof Bucket)) {\n            var hash = onlyChild.hash;\n            hash.untake(this._options.bits);\n            var place = {\n              pos: this._posAtParent,\n              hash: hash\n            };\n\n            this._parent._putAt(place, onlyChild.key, onlyChild.value);\n          }\n        } else {\n          this._parent._delAt(this._posAtParent);\n        }\n      }\n    }\n  }, {\n    key: \"_at\",\n    value: function _at(index) {\n      return this._children.get(index);\n    }\n  }], [{\n    key: \"isBucket\",\n    value: function isBucket(o) {\n      return o instanceof Bucket;\n    }\n  }]);\n\n  return Bucket;\n}();\n\nfunction exists(o) {\n  return Boolean(o);\n}\n\nfunction mapNode(node, index) {\n  return node.key;\n}\n\nfunction reduceNodes(nodes) {\n  return nodes;\n}\n\nfunction asyncTransformBucket(bucket, asyncMap, asyncReduce, callback) {\n  map(bucket._children.compactArray(), function (child, callback) {\n    if (child instanceof Bucket) {\n      asyncTransformBucket(child, asyncMap, asyncReduce, callback);\n    } else {\n      asyncMap(child, function (err, mappedChildren) {\n        if (err) {\n          callback(err);\n        } else {\n          callback(null, {\n            bitField: bucket._children.bitField(),\n            children: mappedChildren\n          });\n        }\n      });\n    }\n  }, function (err, mappedChildren) {\n    if (err) {\n      callback(err);\n    } else {\n      asyncReduce(mappedChildren, callback);\n    }\n  });\n}\n\nmodule.exports = Bucket;","map":null,"metadata":{},"sourceType":"script"}