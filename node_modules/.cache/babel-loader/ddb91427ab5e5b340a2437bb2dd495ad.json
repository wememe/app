{"ast":null,"code":"'use strict';\n\nvar _multiaddr = require('multiaddr');\n\nvar Id = require('peer-id');\n\nvar crypto = require('libp2p-crypto');\n\nvar mafmt = require('mafmt');\n\nfunction cleanUrlSIO(ma) {\n  var protos = ma.protos();\n  var ipProto = protos[0].name;\n  var tcpProto = protos[1].name;\n  var wsProto = protos[2].name;\n  var stringTuples = ma.stringTuples();\n  var tcpPort = stringTuples[1][1];\n\n  if (tcpProto !== 'tcp' || wsProto !== 'ws' && wsProto !== 'wss') {\n    throw new Error('invalid multiaddr: ' + ma.toString());\n  }\n\n  var host = stringTuples[0][1];\n\n  if (ipProto === 'ip6') {\n    host = '[' + host + ']';\n  }\n\n  var proto = wsProto === 'wss' ? 'https' : 'http';\n  var port = wsProto === 'ws' && tcpPort === 80 || wsProto === 'wss' && tcpPort === 443 ? '' : tcpPort;\n  return proto + '://' + host + (port ? ':' + port : '');\n}\n\nvar types = {\n  string: function string(v) {\n    return typeof v === 'string';\n  },\n  object: function object(v) {\n    return typeof v === 'object';\n  },\n  multiaddr: function multiaddr(v) {\n    if (!types.string(v)) return;\n\n    try {\n      _multiaddr(v);\n\n      return true;\n    } catch (e) {\n      return false;\n    }\n  },\n  function: function _function(v) {\n    return typeof v === 'function';\n  }\n};\n\nfunction validate(def, data) {\n  if (!Array.isArray(data)) throw new Error('Data is not an array');\n  def.forEach(function (type, index) {\n    if (!types[type]) {\n      console.error('Type %s does not exist', type); // eslint-disable-line no-console\n\n      throw new Error('Type ' + type + ' does not exist');\n    }\n\n    if (!types[type](data[index])) throw new Error('Data at index ' + index + ' is invalid for type ' + type);\n  });\n}\n\nfunction Protocol(log) {\n  if (!log) log = function log() {};\n  var self = this;\n  self.requests = {};\n\n  self.addRequest = function (name, def, handle) {\n    self.requests[name] = {\n      def: def,\n      handle: handle\n    };\n  };\n\n  self.handleSocket = function (socket) {\n    socket.r = {};\n    Object.keys(self.requests).forEach(function (request) {\n      var r = self.requests[request];\n      socket.on(request, function () {\n        var data = Array.prototype.slice.call(arguments);\n\n        try {\n          validate(r.def, data);\n          data.unshift(socket);\n          r.handle.apply(null, data);\n        } catch (e) {\n          log(e);\n          log('peer %s has sent invalid data for request %s', socket.id || '<server>', request, data);\n        }\n      });\n    });\n  };\n}\n\nfunction getIdAndValidate(pub, id, cb) {\n  Id.createFromPubKey(Buffer.from(pub, 'hex'), function (err, _id) {\n    if (err) {\n      return cb(new Error('Crypto error'));\n    }\n\n    if (_id.toB58String() !== id) {\n      return cb(new Error('Id is not matching'));\n    }\n\n    return cb(null, crypto.keys.unmarshalPublicKey(Buffer.from(pub, 'hex')));\n  });\n}\n\nexports = module.exports;\nexports.cleanUrlSIO = cleanUrlSIO;\nexports.validate = validate;\nexports.Protocol = Protocol;\nexports.getIdAndValidate = getIdAndValidate;\n\nexports.validateMa = function (ma) {\n  return mafmt.WebSocketStar.matches(_multiaddr(ma));\n};","map":null,"metadata":{},"sourceType":"script"}