{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar lp = require('pull-length-prefixed');\n\nvar pull = require('pull-stream');\n\nvar waterfall = require('async/waterfall');\n\nvar each = require('async/each');\n\nvar nextTick = require('async/nextTick');\n\nvar Message = require('./types/message');\n\nvar CONSTANTS = require('./constants');\n\nvar logger = require('./utils').logger;\n\nvar BITSWAP100 = '/ipfs/bitswap/1.0.0';\nvar BITSWAP110 = '/ipfs/bitswap/1.1.0';\n\nvar Network =\n/*#__PURE__*/\nfunction () {\n  function Network(libp2p, bitswap, options, stats) {\n    _classCallCheck(this, Network);\n\n    this._log = logger(libp2p.peerInfo.id, 'network');\n    options = options || {};\n    this.libp2p = libp2p;\n    this.bitswap = bitswap;\n    this.b100Only = options.b100Only || false;\n    this._stats = stats;\n    this._running = false;\n  }\n\n  _createClass(Network, [{\n    key: \"start\",\n    value: function start(callback) {\n      var _this = this;\n\n      this._running = true; // bind event listeners\n\n      this._onPeerConnect = this._onPeerConnect.bind(this);\n      this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n      this._onConnection = this._onConnection.bind(this);\n      this.libp2p.handle(BITSWAP100, this._onConnection);\n\n      if (!this.b100Only) {\n        this.libp2p.handle(BITSWAP110, this._onConnection);\n      }\n\n      this.libp2p.on('peer:connect', this._onPeerConnect);\n      this.libp2p.on('peer:disconnect', this._onPeerDisconnect); // All existing connections are like new ones for us\n\n      this.libp2p.peerBook.getAllArray().filter(function (peer) {\n        return peer.isConnected();\n      }).forEach(function (peer) {\n        return _this._onPeerConnect(peer);\n      });\n      nextTick(function () {\n        return callback();\n      });\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      this._running = false;\n      this.libp2p.unhandle(BITSWAP100);\n\n      if (!this.b100Only) {\n        this.libp2p.unhandle(BITSWAP110);\n      }\n\n      this.libp2p.removeListener('peer:connect', this._onPeerConnect);\n      this.libp2p.removeListener('peer:disconnect', this._onPeerDisconnect);\n      nextTick(function () {\n        return callback();\n      });\n    } // Handles both types of bitswap messgages\n\n  }, {\n    key: \"_onConnection\",\n    value: function _onConnection(protocol, conn) {\n      var _this2 = this;\n\n      if (!this._running) {\n        return;\n      }\n\n      this._log('incomming new bitswap connection: %s', protocol);\n\n      pull(conn, lp.decode(), pull.asyncMap(function (data, cb) {\n        return Message.deserialize(data, cb);\n      }), pull.asyncMap(function (msg, cb) {\n        conn.getPeerInfo(function (err, peerInfo) {\n          if (err) {\n            return cb(err);\n          } // this._log('data from', peerInfo.id.toB58String())\n\n\n          _this2.bitswap._receiveMessage(peerInfo.id, msg, cb);\n        });\n      }), pull.onEnd(function (err) {\n        _this2._log('ending connection');\n\n        if (err) {\n          _this2.bitswap._receiveError(err);\n        }\n      }));\n    }\n  }, {\n    key: \"_onPeerConnect\",\n    value: function _onPeerConnect(peerInfo) {\n      if (!this._running) {\n        return;\n      }\n\n      this.bitswap._onPeerConnected(peerInfo.id);\n    }\n  }, {\n    key: \"_onPeerDisconnect\",\n    value: function _onPeerDisconnect(peerInfo) {\n      if (!this._running) {\n        return;\n      }\n\n      this.bitswap._onPeerDisconnected(peerInfo.id);\n    }\n  }, {\n    key: \"findProviders\",\n    value: function findProviders(cid, maxProviders, callback) {\n      this.libp2p.contentRouting.findProviders(cid, {\n        maxTimeout: CONSTANTS.providerRequestTimeout,\n        maxNumProviders: maxProviders\n      }, callback);\n    }\n  }, {\n    key: \"findAndConnect\",\n    value: function findAndConnect(cid, callback) {\n      var _this3 = this;\n\n      waterfall([function (cb) {\n        return _this3.findProviders(cid, CONSTANTS.maxProvidersPerRequest, cb);\n      }, function (provs, cb) {\n        _this3._log('connecting to providers', provs.map(function (p) {\n          return p.id.toB58String();\n        }));\n\n        each(provs, function (p, cb) {\n          return _this3.connectTo(p, cb);\n        });\n      }], callback);\n    }\n  }, {\n    key: \"provide\",\n    value: function provide(cid, callback) {\n      this.libp2p.contentRouting.provide(cid, callback);\n    } // Connect to the given peer\n    // Send the given msg (instance of Message) to the given peer\n\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(peer, msg, callback) {\n      var _this4 = this;\n\n      if (!this._running) {\n        return callback(new Error(\"network isn't running\"));\n      }\n\n      var stringId = peer.toB58String() ? peer.toB58String() : peer.id.toB58String();\n\n      this._log('sendMessage to %s', stringId, msg);\n\n      this._dialPeer(peer, function (err, conn, protocol) {\n        if (err) {\n          return callback(err);\n        }\n\n        var serialized;\n\n        switch (protocol) {\n          case BITSWAP100:\n            serialized = msg.serializeToBitswap100();\n            break;\n\n          case BITSWAP110:\n            serialized = msg.serializeToBitswap110();\n            break;\n\n          default:\n            return callback(new Error('Unkown protocol: ' + protocol));\n        } // TODO: why doesn't the error get propageted back??\n\n\n        writeMessage(conn, serialized, function (err) {\n          if (err) {\n            _this4._log.error(err);\n          }\n        });\n        callback();\n\n        _this4._updateSentStats(peer, msg.blocks);\n      });\n    }\n  }, {\n    key: \"connectTo\",\n    value: function connectTo(peer, callback) {\n      if (!this._running) {\n        return callback(new Error(\"network isn't running\"));\n      }\n\n      this.libp2p.dial(peer, callback);\n    } // Dial to the peer and try to use the most recent Bitswap\n\n  }, {\n    key: \"_dialPeer\",\n    value: function _dialPeer(peer, callback) {\n      var _this5 = this;\n\n      // Attempt Bitswap 1.1.0\n      this.libp2p.dialProtocol(peer, BITSWAP110, function (err, conn) {\n        if (err) {\n          // Attempt Bitswap 1.0.0\n          _this5.libp2p.dialProtocol(peer, BITSWAP100, function (err, conn) {\n            if (err) {\n              return callback(err);\n            }\n\n            callback(null, conn, BITSWAP100);\n          });\n\n          return;\n        }\n\n        callback(null, conn, BITSWAP110);\n      });\n    }\n  }, {\n    key: \"_updateSentStats\",\n    value: function _updateSentStats(peer, blocks) {\n      var _this6 = this;\n\n      var peerId = peer.toB58String();\n\n      if (this._stats) {\n        blocks.forEach(function (block) {\n          return _this6._stats.push(peerId, 'dataSent', block.data.length);\n        });\n\n        this._stats.push(peerId, 'blocksSent', blocks.size);\n      }\n    }\n  }]);\n\n  return Network;\n}();\n\nfunction writeMessage(conn, msg, callback) {\n  pull(pull.values([msg]), lp.encode(), conn, pull.onEnd(callback));\n}\n\nmodule.exports = Network;","map":null,"metadata":{},"sourceType":"script"}