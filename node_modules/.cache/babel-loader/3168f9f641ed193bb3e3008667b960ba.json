{"ast":null,"code":"'use strict';\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar IPFS = require('ipfs-mini');\n\nvar promisifyAll = require('bluebird').promisifyAll;\n\nvar resolve = require('did-resolver');\n\nvar registerMuportResolver = require('muport-did-resolver');\n\nvar didJWT = require('did-jwt');\n\nvar bs58 = require('bs58');\n\nvar Keyring = require('./keyring');\n\nvar EthereumUtils = require('./ethereum-utils');\n\nvar IPFS_CONF = {\n  host: 'ipfs.infura.io',\n  port: 5001,\n  protocol: 'https'\n};\nvar ipfs = void 0;\n/**\n * Primary object for interacting with a µPort identity. MuPort enables creation and\n * updating of µPort identities. It also provides functionality to sign claims and\n * help other identities recover.\n */\n\nvar MuPort = function () {\n  /**\n   * Instantiates a µPort identity from its serialized state.\n   *\n   * @param     {String}    serializeState          the serialized state of a µPort identity\n   * @param     {Object}    [opts]                  optional parameters\n   * @param     {Object}    opts.ipfsConf           configuration options for ipfs-mini\n   * @param     {String}    opts.rpcProviderUrl     rpc url to a custom ethereum node\n   * @return    {MuPort}                            self\n   */\n  function MuPort(serializeState) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck3.default)(this, MuPort);\n    initIpfs(opts.ipfsConf);\n\n    this._initIdentity(serializeState);\n\n    this.ethUtils = new EthereumUtils(opts.rpcProviderUrl);\n    registerMuportResolver({\n      ipfsConf: opts.ipfsConf,\n      rpcProviderUrl: opts.rpcProviderUrl\n    });\n  }\n\n  (0, _createClass3.default)(MuPort, [{\n    key: '_initIdentity',\n    value: function _initIdentity(serializeState) {\n      var state = JSON.parse(serializeState);\n\n      if (!state.did || !state.document || !state.keyring) {\n        throw new Error('Data missing for restoring identity');\n      }\n\n      this.did = state.did;\n      this.document = state.document;\n      this.documentHash = state.documentHash || this.did.split(':')[2];\n      this.keyring = new Keyring(state.keyring); // TODO - verify integrity of identity (resolving ID should result in the same did document, etc)\n    }\n    /**\n     * Help another identity recover. Returns a decrypted share if the current identity is a delegate\n     * returns undefined otherwise\n     *\n     * @param     {String}    did             the did of the identity that should be recovered\n     * @return    {Promise<String, Error>}    a share that the recovering identity can use\n     */\n\n  }, {\n    key: 'helpRecover',\n    value: function () {\n      var _ref = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee(did) {\n        var muportDoc;\n        return _regenerator2.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return MuPort.resolveIdentityDocument(did);\n\n              case 2:\n                muportDoc = _context.sent;\n                return _context.abrupt('return', this.keyring.decryptOneShare(muportDoc.recoveryNetwork, muportDoc.asymEncryptionKey, this.did));\n\n              case 4:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function helpRecover(_x2) {\n        return _ref.apply(this, arguments);\n      }\n\n      return helpRecover;\n    }()\n    /**\n     * The DID is the identifier of the identity. This is a unique string that can be used to\n     * look up information about the identity.\n     *\n     * @return    {String}        the DID\n     */\n\n  }, {\n    key: 'getDid',\n    value: function getDid() {\n      return this.did;\n    }\n    /**\n     * The DID Document is a json object that contains information such as public keys\n     *\n     * @return    {Object}        the DID Document\n     */\n\n  }, {\n    key: 'getDidDocument',\n    value: function getDidDocument() {\n      return this.document;\n    }\n    /**\n     * The recovery delegates that can help this identity recover\n     *\n     * @return    {Array<String>}        an array containing the DIDs of the delegates\n     */\n\n  }, {\n    key: 'getRecoveryDelegateDids',\n    value: function getRecoveryDelegateDids() {\n      var _this = this;\n\n      var toBuffer = true;\n      var dids = [];\n\n      if (this.document.symEncryptedData && this.document.symEncryptedData.symEncDids) {\n        dids = this.document.symEncryptedData.symEncDids.map(function (encDid) {\n          return bufferToDid(_this.keyring.symDecrypt(encDid.ciphertext, encDid.nonce, toBuffer));\n        });\n      }\n\n      return dids;\n    }\n    /**\n     * This function is used to update the publicProfile and/or the recoveryNetwork of the identity.\n     * The returned object has three properties; `address` an ethereum address, `costInEther` a number,\n     * and `finishUpdate` a function.\n     * In order to complete the update of the delegates you have to\n     * send `costInEther` ether to the `address` on mainnet (or other network if you are using\n     * a custom config). Once that is done the `finishUpdate` function can be called. This\n     * function sends a transaction to the network that updates the identity. The function\n     * will throw an error if there is to little ether in the `address`.\n     * Both publicProfile and delegateDids are optional and you may pass null if you don't wish to\n     * update one of them.\n     *\n     * @param     {Object}            publicProfile       a new public profile for the identity\n     * @param     {Array<String>}     delegateDids        an array containing the 3 DIDs of the new delegates\n     * @return    {Promise<Object, Error>}                an object with the data needed to finalize the update\n     */\n\n  }, {\n    key: 'updateIdentity',\n    value: function () {\n      var _ref2 = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee4(publicProfile, delegateDids) {\n        var _this2 = this;\n\n        var newDocument, didsPublicKeys, newDocumentHash, address, txParams, costInEther, signedTx;\n        return _regenerator2.default.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(!publicProfile && !delegateDids)) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error('publicProfile or delegateDids has to be set');\n\n              case 2:\n                newDocument = JSON.parse((0, _stringify2.default)(this.document));\n\n                if (publicProfile) {\n                  newDocument.publicProfile = publicProfile;\n                }\n\n                if (!delegateDids) {\n                  _context4.next = 15;\n                  break;\n                }\n\n                if (!(delegateDids.length !== 3)) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                throw new Error('Must provide exactly 3 DIDs');\n\n              case 7:\n                _context4.next = 9;\n                return _promise2.default.all(delegateDids.map(function () {\n                  var _ref3 = (0, _asyncToGenerator3.default)(\n                  /*#__PURE__*/\n                  _regenerator2.default.mark(function _callee2(did) {\n                    return _regenerator2.default.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            _context2.next = 2;\n                            return MuPort.resolveIdentityDocument(did);\n\n                          case 2:\n                            return _context2.abrupt('return', _context2.sent.asymEncryptionKey);\n\n                          case 3:\n                          case 'end':\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2, _this2);\n                  }));\n\n                  return function (_x5) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }()));\n\n              case 9:\n                didsPublicKeys = _context4.sent;\n                _context4.next = 12;\n                return this.keyring.createShares(delegateDids, didsPublicKeys);\n\n              case 12:\n                newDocument.recoveryNetwork = _context4.sent; // save guardians\n\n                newDocument.symEncryptedData = newDocument.symEncryptedData || {};\n                newDocument.symEncryptedData.symEncDids = delegateDids.map(function (did) {\n                  return _this2.keyring.symEncrypt(didToBuffer(did));\n                });\n\n              case 15:\n                _context4.next = 17;\n                return ipfs.addJSONAsync(newDocument);\n\n              case 17:\n                newDocumentHash = _context4.sent; // prepare ethereum tx\n\n                address = this.keyring.getManagementAddress();\n                _context4.next = 21;\n                return this.ethUtils.createPublishTxParams(newDocumentHash, address);\n\n              case 21:\n                txParams = _context4.sent;\n                costInEther = this.ethUtils.calculateTxCost(txParams);\n                signedTx = this.keyring.externalMgmtKey ? null : this.keyring.signManagementTx(txParams);\n                return _context4.abrupt('return', {\n                  txParams: txParams,\n                  address: address,\n                  costInEther: costInEther,\n                  finishUpdate: function () {\n                    var _ref4 = (0, _asyncToGenerator3.default)(\n                    /*#__PURE__*/\n                    _regenerator2.default.mark(function _callee3(txHash) {\n                      return _regenerator2.default.wrap(function _callee3$(_context3) {\n                        while (1) {\n                          switch (_context3.prev = _context3.next) {\n                            case 0:\n                              _context3.t0 = txHash;\n\n                              if (_context3.t0) {\n                                _context3.next = 5;\n                                break;\n                              }\n\n                              _context3.next = 4;\n                              return _this2.ethUtils.sendRawTx(signedTx);\n\n                            case 4:\n                              _context3.t0 = _context3.sent;\n\n                            case 5:\n                              txHash = _context3.t0;\n                              _context3.prev = 6;\n                              _context3.next = 9;\n                              return _this2.ethUtils.waitForTx(txHash);\n\n                            case 9:\n                              _this2.document = newDocument;\n                              _this2.documentHash = newDocumentHash;\n                              _context3.next = 16;\n                              break;\n\n                            case 13:\n                              _context3.prev = 13;\n                              _context3.t1 = _context3['catch'](6);\n                              throw new Error('There was a problem with sending the transaction' + _context3.t1);\n\n                            case 16:\n                            case 'end':\n                              return _context3.stop();\n                          }\n                        }\n                      }, _callee3, _this2, [[6, 13]]);\n                    }));\n\n                    function finishUpdate(_x6) {\n                      return _ref4.apply(this, arguments);\n                    }\n\n                    return finishUpdate;\n                  }()\n                });\n\n              case 25:\n              case 'end':\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function updateIdentity(_x3, _x4) {\n        return _ref2.apply(this, arguments);\n      }\n\n      return updateIdentity;\n    }()\n    /**\n     * Signs the given payload (claim) and return a promis with the JWT.\n     *\n     * @return    {Promise<String, Error>}        a promise that resolves to a JWT\n     */\n\n  }, {\n    key: 'signJWT',\n    value: function () {\n      var _ref5 = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee5(payload) {\n        var settings;\n        return _regenerator2.default.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                settings = {\n                  signer: this.keyring.getJWTSigner(),\n                  issuer: this.did // TODO - should we have an expiry?\n\n                };\n                return _context5.abrupt('return', didJWT.createJWT(payload, settings));\n\n              case 2:\n              case 'end':\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function signJWT(_x7) {\n        return _ref5.apply(this, arguments);\n      }\n\n      return signJWT;\n    }()\n    /**\n     * Verifies a JWT.\n     *\n     * @param     {String}        jwt                 the JWT to verify\n     * @param     {String}        audience=this.did   the audience, defaults to did of current identity\n     * @return    {Promise<Object, Error>}            a promise that resolves to the decoded JWT\n     */\n\n  }, {\n    key: 'verifyJWT',\n    value: function () {\n      var _ref6 = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee6(jwt) {\n        var audience = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.did;\n        return _regenerator2.default.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt('return', didJWT.verifyJWT(jwt, {\n                  audience: audience\n                }));\n\n              case 1:\n              case 'end':\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function verifyJWT(_x9) {\n        return _ref6.apply(this, arguments);\n      }\n\n      return verifyJWT;\n    }()\n    /**\n     * Asymmetrically encrypt a message\n     *\n     * @param     {String}        msg                 the message to encrypt\n     * @param     {String}        toPublic            the public key to encrypt to, encoded as a base64 string\n     * @param     {String}        nonce               (optional) the nonce, encoded as a base64 string\n     * @return    {Object}                            an object containing the nonce and the ciphertext\n     */\n\n  }, {\n    key: 'encrypt',\n    value: function encrypt(msg, toPublic, nonce) {\n      return this.keyring.encrypt(msg, toPublic, nonce);\n    }\n    /**\n     * Decrypt an asymmetrically encrypted message\n     *\n     * @param     {String}            ciphertext          the ciphertext to decrypt, encoded as a base64 string\n     * @param     {String}            fromPublic          the public key of the entity that encrypted the msg, encoded as a base64 string\n     * @param     {String}            nonce               the nonce, encoded as a base64 string\n     * @param     {Boolean}           toBuffer            a boolean deciding whether to\n     * @return    {String | Buffer}                       the decrypted message\n     */\n\n  }, {\n    key: 'decrypt',\n    value: function decrypt(ciphertext, fromPublic, nonce, toBuffer) {\n      return this.keyring.decrypt(ciphertext, fromPublic, nonce, toBuffer);\n    }\n    /**\n     * Symmetrically encrypt a message\n     *\n     * @param     {String}        msg                 the message to encrypt\n     * @param     {String}        nonce               (optional) the nonce, encoded as a base64 string\n     * @return    {Object}                            an object containing the nonce and the ciphertext\n     */\n\n  }, {\n    key: 'symEncrypt',\n    value: function symEncrypt(msg, nonce) {\n      return this.keyring.symEncrypt(msg, nonce);\n    }\n    /**\n     * Decrypt a symmetrically encrypted message\n     *\n     * @param     {String}            ciphertext          the ciphertext to decrypt, encoded as a base64 string\n     * @param     {String}            nonce               the nonce, encoded as a base64 string\n     * @param     {Boolean}           toBuffer            a boolean deciding whether to\n     * @return    {String | Buffer}                       the decrypted message\n     */\n\n  }, {\n    key: 'symDecrypt',\n    value: function symDecrypt(ciphertext, nonce, toBuffer) {\n      return this.keyring.symDecrypt(ciphertext, nonce, toBuffer);\n    }\n    /**\n     * Serialize the state of the current identity to be able to reconstruct it later.\n     *\n     * @return    {String}    the serialized state\n     */\n\n  }, {\n    key: 'serializeState',\n    value: function serializeState() {\n      return (0, _stringify2.default)({\n        did: this.did,\n        document: this.document,\n        documentHash: this.documentHash,\n        keyring: this.keyring.serialize()\n      });\n    }\n    /**\n     * Creates a new µPort identity.\n     *\n     * @param     {Object}            publicProfile           a public profile for the new identity\n     * @param     {Array<String>}     delegateDids            three DIDs that can be used to recover the identity at a later point (optional)\n     * @param     {Object}            [opts]                  optional parameters\n     * @param     {String}            opts.externalMgmtKey    an ethereum address to be used as an external managementKey\n     * @param     {Object}            opts.ipfsConf           configuration options for ipfs-mini\n     * @param     {String}            opts.rpcProviderUrl     rpc url to a custom ethereum node\n     * @return    {Promise<MuPort, Error>}                    a promise that resolves to an instance of the MuPort class\n     */\n\n  }], [{\n    key: 'newIdentity',\n    value: function () {\n      var _ref7 = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee8(publicProfile, delegateDids) {\n        var _this3 = this;\n\n        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var keyring, recoveryNetwork, symEncryptedData, didsPublicKeys, symEncryptedDelegateDids, publicKeys, doc, docHash, did;\n        return _regenerator2.default.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                initIpfs(opts.ipfsConf);\n                keyring = new Keyring(opts);\n                recoveryNetwork = void 0;\n                symEncryptedData = void 0;\n\n                if (!delegateDids) {\n                  _context8.next = 13;\n                  break;\n                }\n\n                _context8.next = 7;\n                return _promise2.default.all(delegateDids.map(function () {\n                  var _ref8 = (0, _asyncToGenerator3.default)(\n                  /*#__PURE__*/\n                  _regenerator2.default.mark(function _callee7(did) {\n                    return _regenerator2.default.wrap(function _callee7$(_context7) {\n                      while (1) {\n                        switch (_context7.prev = _context7.next) {\n                          case 0:\n                            _context7.next = 2;\n                            return MuPort.resolveIdentityDocument(did, opts);\n\n                          case 2:\n                            return _context7.abrupt('return', _context7.sent.asymEncryptionKey);\n\n                          case 3:\n                          case 'end':\n                            return _context7.stop();\n                        }\n                      }\n                    }, _callee7, _this3);\n                  }));\n\n                  return function (_x13) {\n                    return _ref8.apply(this, arguments);\n                  };\n                }()));\n\n              case 7:\n                didsPublicKeys = _context8.sent;\n                _context8.next = 10;\n                return keyring.createShares(delegateDids, didsPublicKeys);\n\n              case 10:\n                recoveryNetwork = _context8.sent;\n                symEncryptedDelegateDids = delegateDids.map(function (did) {\n                  return keyring.symEncrypt(didToBuffer(did));\n                });\n                symEncryptedData = {\n                  symEncDids: symEncryptedDelegateDids\n                };\n\n              case 13:\n                publicKeys = keyring.getPublicKeys();\n                doc = createMuportDocument(publicKeys, recoveryNetwork, publicProfile, symEncryptedData);\n                _context8.next = 17;\n                return ipfs.addJSONAsync(doc);\n\n              case 17:\n                docHash = _context8.sent;\n                did = 'did:muport:' + docHash;\n                return _context8.abrupt('return', new MuPort((0, _stringify2.default)({\n                  did: did,\n                  document: doc,\n                  documentHash: docHash,\n                  keyring: keyring.serialize()\n                }), opts));\n\n              case 20:\n              case 'end':\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function newIdentity(_x11, _x12) {\n        return _ref7.apply(this, arguments);\n      }\n\n      return newIdentity;\n    }()\n    /**\n     * Recovers a µPort identity.\n     *\n     * @param     {String}            did                     the DID of the identity to be recovered\n     * @param     {Array<String>}     shares                  atleast two shares that your delegates helped recover\n     * @param     {Object}            [opts]                  optional parameters\n     * @param     {Object}            opts.ipfsConf           configuration options for ipfs-mini\n     * @param     {String}            opts.rpcProviderUrl     rpc url to a custom ethereum node\n     * @return    {Promise<MuPort, Error>}                    a promise that resolves to an instance of the MuPort class\n     */\n\n  }, {\n    key: 'recoverIdentity',\n    value: function () {\n      var _ref9 = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee9(did, shares) {\n        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return _regenerator2.default.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                initIpfs(opts.ipfsConf);\n                _context9.t0 = MuPort;\n                _context9.t1 = _stringify2.default;\n                _context9.t2 = did;\n                _context9.next = 6;\n                return MuPort.resolveIdentityDocument(did, opts);\n\n              case 6:\n                _context9.t3 = _context9.sent;\n                _context9.next = 9;\n                return Keyring.recoverKeyring(shares);\n\n              case 9:\n                _context9.t4 = _context9.sent.serialize();\n                _context9.t5 = {\n                  did: _context9.t2,\n                  document: _context9.t3,\n                  keyring: _context9.t4\n                };\n                _context9.t6 = (0, _context9.t1)(_context9.t5);\n                _context9.t7 = opts;\n                return _context9.abrupt('return', new _context9.t0(_context9.t6, _context9.t7));\n\n              case 14:\n              case 'end':\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function recoverIdentity(_x15, _x16) {\n        return _ref9.apply(this, arguments);\n      }\n\n      return recoverIdentity;\n    }()\n    /**\n     * Resovles the identity document for the given DID.\n     *\n     * @param     {String}            did                     the DID of the identity\n     * @param     {Object}            [opts]                  optional parameters\n     * @param     {Object}            opts.ipfsConf           configuration options for ipfs-mini\n     * @param     {String}            opts.rpcProviderUrl     rpc url to a custom ethereum node\n     * @return    {Promise<Object, Error>}                    a promise that resolves to the identity document\n     */\n\n  }, {\n    key: 'resolveIdentityDocument',\n    value: function () {\n      var _ref10 = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee10(did, opts) {\n        var didDoc, managementKeyStruct, publicKeys, recoveryNetwork, publicProfile, symEncryptedData;\n        return _regenerator2.default.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (opts) {\n                  registerMuportResolver({\n                    ipfsConf: opts.ipfsConf,\n                    rpcProviderUrl: opts.rpcProviderUrl\n                  });\n                }\n\n                _context10.next = 3;\n                return resolve(did);\n\n              case 3:\n                didDoc = _context10.sent;\n                managementKeyStruct = didDoc.publicKey.find(function (key) {\n                  return key.id.indexOf('#managementKey') !== -1;\n                });\n                publicKeys = {\n                  signingKey: didDoc.publicKey.find(function (key) {\n                    return key.id.indexOf('#signingKey') !== -1;\n                  }).publicKeyHex,\n                  managementKey: managementKeyStruct.publicKeyHex || managementKeyStruct.ethereumAddress,\n                  asymEncryptionKey: didDoc.publicKey.find(function (key) {\n                    return key.id.indexOf('#encryptionKey') !== -1;\n                  }).publicKeyBase64\n                };\n                recoveryNetwork = didDoc.muportData.recoveryNetwork;\n                publicProfile = didDoc.uportProfile;\n                symEncryptedData = didDoc.muportData.symEncryptedData;\n                return _context10.abrupt('return', createMuportDocument(publicKeys, recoveryNetwork, publicProfile, symEncryptedData));\n\n              case 10:\n              case 'end':\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function resolveIdentityDocument(_x17, _x18) {\n        return _ref10.apply(this, arguments);\n      }\n\n      return resolveIdentityDocument;\n    }()\n  }]);\n  return MuPort;\n}();\n\nvar initIpfs = function initIpfs(ipfsConf) {\n  ipfs = promisifyAll(new IPFS(ipfsConf || IPFS_CONF));\n};\n\nvar createMuportDocument = function createMuportDocument(publicKeys, recoveryNetwork, publicProfile, symEncryptedData) {\n  var doc = (0, _extends3.default)({\n    version: 1\n  }, publicKeys);\n\n  if (recoveryNetwork) {\n    doc.recoveryNetwork = recoveryNetwork;\n  }\n\n  if (publicProfile) {\n    doc.publicProfile = publicProfile;\n  }\n\n  if (symEncryptedData) {\n    doc.symEncryptedData = symEncryptedData;\n  }\n\n  return doc;\n};\n\nvar bufferToDid = function bufferToDid(didBuffer) {\n  return 'did:muport:' + bs58.encode(didBuffer);\n};\n\nvar didToBuffer = function didToBuffer(didUri) {\n  var hash = didUri.split(':')[2];\n  return bs58.decode(hash);\n};\n\nmodule.exports = MuPort;","map":null,"metadata":{},"sourceType":"script"}