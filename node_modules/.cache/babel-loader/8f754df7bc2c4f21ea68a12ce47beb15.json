{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar waterfall = require('async/waterfall');\n\nvar series = require('async/series');\n\nvar parallel = require('async/parallel');\n\nvar each = require('async/each');\n\nvar _get = require('lodash.get');\n\nvar assert = require('assert');\n\nvar path = require('path');\n\nvar debug = require('debug');\n\nvar Big = require('big.js');\n\nvar pull = require('pull-stream');\n\nvar backends = require('./backends');\n\nvar version = require('./version');\n\nvar config = require('./config');\n\nvar spec = require('./spec');\n\nvar apiAddr = require('./api-addr');\n\nvar blockstore = require('./blockstore');\n\nvar defaultOptions = require('./default-options');\n\nvar defaultDatastore = require('./default-datastore');\n\nvar ERRORS = require('./errors');\n\nvar log = debug('repo');\nvar noLimit = Number.MAX_SAFE_INTEGER;\nvar lockers = {\n  memory: require('./lock-memory'),\n  fs: require('./lock')\n};\n\nvar repoVersion = require('./constants').repoVersion;\n/**\n * IpfsRepo implements all required functionality to read and write to an ipfs repo.\n *\n */\n\n\nvar IpfsRepo =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {string} repoPath - path where the repo is stored\n   * @param {object} options - Configuration\n   */\n  function IpfsRepo(repoPath, options) {\n    _classCallCheck(this, IpfsRepo);\n\n    assert.equal(typeof repoPath, 'string', 'missing repoPath');\n    this.options = buildOptions(options);\n    this.closed = true;\n    this.path = repoPath;\n    this._locker = this._getLocker();\n    this.root = backends.create('root', this.path, this.options);\n    this.version = version(this.root);\n    this.config = config(this.root);\n    this.spec = spec(this.root);\n    this.apiAddr = apiAddr(this.root);\n  }\n  /**\n   * Initialize a new repo.\n   *\n   * @param {Object} config - config to write into `config`.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  _createClass(IpfsRepo, [{\n    key: \"init\",\n    value: function init(config, callback) {\n      var _this = this;\n\n      log('initializing at: %s', this.path);\n      series([function (cb) {\n        return _this.root.open(ignoringAlreadyOpened(cb));\n      }, function (cb) {\n        return _this.config.set(buildConfig(config), cb);\n      }, function (cb) {\n        return _this.spec.set(buildDatastoreSpec(config), cb);\n      }, function (cb) {\n        return _this.version.set(repoVersion, cb);\n      }], callback);\n    }\n    /**\n     * Open the repo. If the repo is already open no action will be taken.\n     * If the repo is not initialized it will return an error.\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"open\",\n    value: function open(callback) {\n      var _this2 = this;\n\n      if (!this.closed) {\n        setImmediate(function () {\n          return callback(new Error('repo is already open'));\n        });\n        return; // early\n      }\n\n      log('opening at: %s', this.path); // check if the repo is already initialized\n\n      waterfall([function (cb) {\n        return _this2.root.open(ignoringAlreadyOpened(cb));\n      }, function (cb) {\n        return _this2._isInitialized(cb);\n      }, function (cb) {\n        return _this2._openLock(_this2.path, cb);\n      }, function (lck, cb) {\n        log('aquired repo.lock');\n        _this2.lockfile = lck;\n        cb();\n      }, function (cb) {\n        log('creating datastore');\n        _this2.datastore = backends.create('datastore', path.join(_this2.path, 'datastore'), _this2.options);\n        log('creating blocks');\n        var blocksBaseStore = backends.create('blocks', path.join(_this2.path, 'blocks'), _this2.options);\n        blockstore(blocksBaseStore, _this2.options.storageBackendOptions.blocks, cb);\n      }, function (blocks, cb) {\n        _this2.blocks = blocks;\n        cb();\n      }, function (cb) {\n        log('creating keystore');\n        _this2.keys = backends.create('keys', path.join(_this2.path, 'keys'), _this2.options);\n        cb();\n      }, function (cb) {\n        _this2.closed = false;\n        log('all opened');\n        cb();\n      }], function (err) {\n        if (err && _this2.lockfile) {\n          _this2._closeLock(function (err2) {\n            if (!err2) {\n              _this2.lockfile = null;\n            } else {\n              log('error removing lock', err2);\n            }\n\n            callback(err);\n          });\n        } else {\n          callback(err);\n        }\n      });\n    }\n    /**\n     * Returns the repo locker to be used. Null will be returned if no locker is requested\n     *\n     * @private\n     * @returns {Locker}\n     */\n\n  }, {\n    key: \"_getLocker\",\n    value: function _getLocker() {\n      if (typeof this.options.lock === 'string') {\n        assert(lockers[this.options.lock], 'Unknown lock type: ' + this.options.lock);\n        return lockers[this.options.lock];\n      }\n\n      assert(this.options.lock, 'No lock provided');\n      return this.options.lock;\n    }\n    /**\n     * Creates a lock on the repo if a locker is specified. The lockfile object will\n     * be returned in the callback if one has been created.\n     *\n     * @param {string} path\n     * @param {function(Error, lockfile)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_openLock\",\n    value: function _openLock(path, callback) {\n      this._locker.lock(path, function (err, lockfile) {\n        if (err) {\n          return callback(err, null);\n        }\n\n        assert.equal(typeof lockfile.close, 'function', 'Locks must have a close method');\n        callback(null, lockfile);\n      });\n    }\n    /**\n     * Closes the lock on the repo\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_closeLock\",\n    value: function _closeLock(callback) {\n      if (this.lockfile) {\n        return this.lockfile.close(callback);\n      }\n\n      callback();\n    }\n    /**\n     * Check if the repo is already initialized.\n     *\n     * @private\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_isInitialized\",\n    value: function _isInitialized(callback) {\n      var _this3 = this;\n\n      log('init check');\n      parallel({\n        config: function config(cb) {\n          return _this3.config.exists(cb);\n        },\n        spec: function spec(cb) {\n          return _this3.spec.exists(cb);\n        },\n        version: function version(cb) {\n          return _this3.version.check(repoVersion, cb);\n        }\n      }, function (err, res) {\n        log('init', err, res);\n\n        if (err && !res.config) {\n          return callback(Object.assign(new Error('repo is not initialized yet'), {\n            code: ERRORS.ERR_REPO_NOT_INITIALIZED,\n            path: _this3.path\n          }));\n        }\n\n        callback(err);\n      });\n    }\n    /**\n     * Close the repo and cleanup.\n     *\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(callback) {\n      var _this4 = this;\n\n      if (this.closed) {\n        return callback(new Error('repo is already closed'));\n      }\n\n      log('closing at: %s', this.path);\n      series([function (cb) {\n        return _this4.apiAddr.delete(ignoringNotFound(cb));\n      }, function (cb) {\n        each([_this4.blocks, _this4.keys, _this4.datastore], function (store, callback) {\n          return store.close(callback);\n        }, cb);\n      }, function (cb) {\n        log('unlocking');\n        _this4.closed = true;\n\n        _this4._closeLock(cb);\n      }, function (cb) {\n        _this4.lockfile = null;\n        cb();\n      }], function (err) {\n        return callback(err);\n      });\n    }\n    /**\n     * Check if a repo exists.\n     *\n     * @param {function(Error, bool)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"exists\",\n    value: function exists(callback) {\n      this.version.exists(callback);\n    }\n    /**\n     * Get repo status.\n     *\n     * @param {Object}  options\n     * @param {Boolean} options.human\n     * @param {function(Error, Object)} callback\n     * @return {void}\n     */\n\n  }, {\n    key: \"stat\",\n    value: function stat(options, callback) {\n      var _this5 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = Object.assign({}, {\n        human: false\n      }, options);\n      parallel({\n        storageMax: function storageMax(cb) {\n          return _this5.config.get('Datastore.StorageMax', function (err, max) {\n            if (err) {\n              cb(null, new Big(noLimit));\n            } else {\n              cb(null, new Big(max));\n            }\n          });\n        },\n        version: function version(cb) {\n          return _this5.version.get(cb);\n        },\n        blocks: function blocks(cb) {\n          return _this5.blocks.query({}, function (err, list) {\n            list = list || [];\n            var count = new Big(list.length);\n            var size = new Big(0);\n            list.forEach(function (block) {\n              size = size.plus(block.value.byteLength).plus(block.key._buf.byteLength);\n            });\n            cb(err, {\n              count: count,\n              size: size\n            });\n          });\n        },\n        datastore: function datastore(cb) {\n          return getSize(_this5.datastore, cb);\n        },\n        keys: function keys(cb) {\n          return getSize(_this5.keys, cb);\n        }\n      }, function (err, results) {\n        if (err) return callback(err);\n        var size = results.blocks.size.plus(results.datastore).plus(results.keys);\n\n        if (options.human) {\n          size = size.div(1048576);\n        }\n\n        callback(null, {\n          repoPath: _this5.path,\n          storageMax: results.storageMax,\n          version: results.version,\n          numObjects: results.blocks.count,\n          repoSize: size\n        });\n      });\n    }\n  }]);\n\n  return IpfsRepo;\n}();\n\nfunction getSize(queryFn, callback) {\n  pull(queryFn.query({}), pull.reduce(function (sum, block) {\n    return sum.plus(block.value.byteLength).plus(block.key._buf.byteLength);\n  }, new Big(0), callback));\n}\n\nmodule.exports = IpfsRepo;\nmodule.exports.repoVersion = repoVersion;\nmodule.exports.errors = ERRORS;\n\nfunction ignoringIf(cond, cb) {\n  return function (err) {\n    cb(err && !cond(err) ? err : null);\n  };\n}\n\nfunction ignoringAlreadyOpened(cb) {\n  return ignoringIf(function (err) {\n    return err.message === 'Already open';\n  }, cb);\n}\n\nfunction ignoringNotFound(cb) {\n  return ignoringIf(function (err) {\n    return err && (err.code === ERRORS.ERR_REPO_NOT_INITIALIZED || err.message.startsWith('ENOENT'));\n  }, cb);\n}\n\nfunction buildOptions(_options) {\n  var options = Object.assign({}, defaultOptions, _options);\n  options.storageBackends = Object.assign({}, defaultOptions.storageBackends, options.storageBackends);\n  options.storageBackendOptions = Object.assign({}, defaultOptions.storageBackendOptions, options.storageBackendOptions);\n  return options;\n} // TODO this should come from js-ipfs instead\n\n\nfunction buildConfig(_config) {\n  _config.datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore', {}));\n  return _config;\n}\n\nfunction buildDatastoreSpec(_config) {\n  var spec = Object.assign({}, defaultDatastore.Spec, _get(_config, 'datastore.Spec', {}));\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map(function (mounting) {\n      return {\n        mountpoint: mounting.mountpoint,\n        type: mounting.child.type,\n        path: mounting.child.path,\n        shardFunc: mounting.child.shardFunc\n      };\n    })\n  };\n}","map":null,"metadata":{},"sourceType":"script"}