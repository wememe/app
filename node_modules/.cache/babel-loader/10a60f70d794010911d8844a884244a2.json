{"ast":null,"code":"var util = require('util');\n\nvar AbstractIterator = require('abstract-leveldown').AbstractIterator;\n\nvar ltgt = require('ltgt');\n\nvar idbReadableStream = require('idb-readable-stream');\n\nvar stream = require('stream');\n\nvar xtend = require('xtend');\n\nvar Writable = stream.Writable;\nmodule.exports = Iterator;\n/**\n * Open IndexedDB cursor.\n *\n * @param {Object} db  db instance\n * @param {Object} [options]  options\n *\n * options:\n *   snapshot {Boolean}  Whether to use snapshot mode, that may lead to memory\n *     spikes, or use back pressure, that can't guarantee the same snapshot. This\n *     option is true by default.\n */\n\nfunction Iterator(db, options) {\n  this._db = db._db;\n  this._idbOpts = db._idbOpts;\n  AbstractIterator.call(this, db);\n  this._options = xtend({\n    snapshot: true\n  }, this._idbOpts, options);\n  this._limit = this._options.limit;\n\n  if (this._limit == null || this._limit === -1) {\n    this._limit = Infinity;\n  }\n\n  if (typeof this._limit !== 'number') throw new TypeError('options.limit must be a number');\n  if (this._limit === 0) return; // skip further processing and wait for first call to _next\n\n  this._count = 0;\n\n  this._startCursor(this._options);\n}\n\nutil.inherits(Iterator, AbstractIterator);\n\nIterator.prototype._startCursor = function (options) {\n  options = xtend(this._options, options);\n  var self = this;\n  var keyRange = null;\n  var lower = ltgt.lowerBound(options);\n  var upper = ltgt.upperBound(options);\n  var lowerOpen = ltgt.lowerBoundExclusive(options);\n  var upperOpen = ltgt.upperBoundExclusive(options);\n  var direction = options.reverse ? 'prev' : 'next'; // support binary keys for any iterable type via array (ArrayBuffers as keys are only supported in IndexedDB Second Edition)\n\n  if (lower) if (options.keyEncoding === 'binary' && !Array.isArray(lower)) lower = Array.prototype.slice.call(lower);\n  if (upper) if (options.keyEncoding === 'binary' && !Array.isArray(upper)) upper = Array.prototype.slice.call(upper);\n  if (lower && upper) try {\n    keyRange = IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen);\n  } catch (err) {\n    // skip the iterator and return 0 results if IDBKeyRange throws a DataError (if keys overlap)\n    this._keyRangeError = true;\n    return;\n  } else if (lower) keyRange = IDBKeyRange.lowerBound(lower, lowerOpen);else if (upper) keyRange = IDBKeyRange.upperBound(upper, upperOpen);\n  this._reader = idbReadableStream(this._db, this._idbOpts.storeName, xtend(options, {\n    range: keyRange,\n    direction: direction\n  }));\n\n  this._reader.on('error', function (err) {\n    var cb = self._callback;\n    self._callback = false;\n    if (cb) cb(err);else // else wait for _next\n      self._readNext = function (cb) {\n        cb(err);\n      };\n  });\n\n  this._reader.pipe(new Writable({\n    objectMode: true,\n    write: function write(item, enc, cb) {\n      if (self._count++ >= self._limit) {\n        // limit reached, finish\n        self._reader.pause();\n\n        self._reader.unpipe(this);\n\n        cb();\n        this.end();\n        return;\n      }\n\n      var cb2 = self._callback;\n      self._callback = false;\n      if (cb2) self._processItem(item, function (err, key, value) {\n        cb(err); // proceed with next item\n\n        cb2(err, key, value);\n      });else // else wait for _next\n        self._readNext = function (cb2) {\n          self._processItem(item, function (err, key, value) {\n            cb(err); // proceed with next item\n\n            cb2(err, key, value);\n          });\n        };\n    }\n  })).on('finish', function () {\n    var cb = self._callback;\n    self._callback = false;\n    if (cb) cb();else // else wait for _next\n      self._readNext = function (cb) {\n        cb();\n      };\n  });\n};\n\nIterator.prototype._processItem = function (item, cb) {\n  if (typeof cb !== 'function') throw new TypeError('cb must be a function');\n  var key = item.key;\n  var value = item.value; // automatically convert Uint8Array values to Buffer\n\n  if (value instanceof Uint8Array) value = new Buffer(value);\n  if (this._options.keyEncoding === 'binary' && Array.isArray(key)) key = new Buffer(key);\n  if (this._options.valueEncoding === 'binary' && !Buffer.isBuffer(value)) value = new Buffer(value);\n\n  if (this._options.keyAsBuffer && !Buffer.isBuffer(key)) {\n    if (key == null) key = new Buffer(0);else if (typeof key === 'string') key = new Buffer(key); // defaults to utf8, should the encoding be utf16? (DOMString)\n    else if (typeof key === 'boolean') key = new Buffer(String(key)); // compatible with leveldb\n      else if (typeof key === 'number') key = new Buffer(String(key)); // compatible with leveldb\n        else if (Array.isArray(key)) key = new Buffer(String(key)); // compatible with leveldb\n          else if (key instanceof Uint8Array) key = new Buffer(key);else throw new TypeError('can\\'t coerce `' + key.constructor.name + '` into a Buffer');\n  }\n\n  if (this._options.valueAsBuffer && !Buffer.isBuffer(value)) {\n    if (value == null) value = new Buffer(0);else if (typeof value === 'string') value = new Buffer(value); // defaults to utf8, should the encoding be utf16? (DOMString)\n    else if (typeof value === 'boolean') value = new Buffer(String(value)); // compatible with leveldb\n      else if (typeof value === 'number') value = new Buffer(String(value)); // compatible with leveldb\n        else if (Array.isArray(value)) value = new Buffer(String(value)); // compatible with leveldb\n          else if (value instanceof Uint8Array) value = new Buffer(value);else throw new TypeError('can\\'t coerce `' + value.constructor.name + '` into a Buffer');\n  }\n\n  cb(null, key, value);\n}; // register a callback, only call it directly if a nextHandler is registered\n\n\nIterator.prototype._next = function (callback) {\n  if (this._callback) throw new Error('callback already exists'); // each callback should be invoked exactly once\n\n  if (this._keyRangeError || this._limit === 0) return void callback();\n  var readNext = this._readNext;\n  this._readNext = false;\n\n  if (readNext) {\n    process.nextTick(function () {\n      readNext(callback);\n    });\n  } else {\n    this._callback = callback;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}