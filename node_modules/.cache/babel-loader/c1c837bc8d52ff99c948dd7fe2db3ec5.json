{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar waterfall = require('async/waterfall');\n\nvar reject = require('async/reject');\n\nvar each = require('async/each');\n\nvar series = require('async/series');\n\nvar map = require('async/map');\n\nvar nextTick = require('async/nextTick');\n\nvar WantManager = require('./want-manager');\n\nvar Network = require('./network');\n\nvar DecisionEngine = require('./decision-engine');\n\nvar Notifications = require('./notifications');\n\nvar logger = require('./utils').logger;\n\nvar Stats = require('./stats');\n\nvar defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n};\nvar statsKeys = ['blocksReceived', 'dataReceived', 'dupBlksReceived', 'dupDataReceived', 'blocksSent', 'dataSent', 'providesBufferLength', 'wantListLength', 'peerCount'];\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @param {Libp2p} libp2p\n * @param {Blockstore} blockstore\n */\n\nvar Bitswap =\n/*#__PURE__*/\nfunction () {\n  function Bitswap(libp2p, blockstore, options) {\n    _classCallCheck(this, Bitswap);\n\n    this._libp2p = libp2p;\n    this._log = logger(this.peerInfo.id);\n    this._options = Object.assign({}, defaultOptions, options); // stats\n\n    this._stats = new Stats(statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    }); // the network delivers messages\n\n    this.network = new Network(libp2p, this, {}, this._stats); // local database\n\n    this.blockstore = blockstore;\n    this.engine = new DecisionEngine(this.peerInfo.id, blockstore, this.network, this._stats); // handle message sending\n\n    this.wm = new WantManager(this.peerInfo.id, this.network, this._stats);\n    this.notifications = new Notifications(this.peerInfo.id);\n  }\n\n  _createClass(Bitswap, [{\n    key: \"_receiveMessage\",\n    // handle messages received through the network\n    value: function _receiveMessage(peerId, incoming, callback) {\n      var _this = this;\n\n      this.engine.messageReceived(peerId, incoming, function (err) {\n        if (err) {\n          // Only logging the issue to process as much as possible\n          // of the message. Currently `messageReceived` does not\n          // return any errors, but this could change in the future.\n          _this._log('failed to receive message', incoming);\n        }\n\n        if (incoming.blocks.size === 0) {\n          return callback();\n        }\n\n        var blocks = Array.from(incoming.blocks.values()); // quickly send out cancels, reduces chances of duplicate block receives\n\n        var toCancel = blocks.filter(function (b) {\n          return _this.wm.wantlist.contains(b.cid);\n        }).map(function (b) {\n          return b.cid;\n        });\n\n        _this.wm.cancelWants(toCancel);\n\n        each(blocks, function (b, cb) {\n          return _this._handleReceivedBlock(peerId, b, cb);\n        }, callback);\n      });\n    }\n  }, {\n    key: \"_handleReceivedBlock\",\n    value: function _handleReceivedBlock(peerId, block, callback) {\n      var _this2 = this;\n\n      this._log('received block');\n\n      waterfall([function (cb) {\n        return _this2.blockstore.has(block.cid, cb);\n      }, function (has, cb) {\n        _this2._updateReceiveCounters(peerId.toB58String(), block, has);\n\n        if (has) {\n          return nextTick(cb);\n        }\n\n        _this2._putBlock(block, cb);\n      }], callback);\n    }\n  }, {\n    key: \"_updateReceiveCounters\",\n    value: function _updateReceiveCounters(peerId, block, exists) {\n      this._stats.push(peerId, 'blocksReceived', 1);\n\n      this._stats.push(peerId, 'dataReceived', block.data.length);\n\n      if (exists) {\n        this._stats.push(peerId, 'dupBlksReceived', 1);\n\n        this._stats.push(peerId, 'dupDataReceived', block.data.length);\n      }\n    } // handle errors on the receiving channel\n\n  }, {\n    key: \"_receiveError\",\n    value: function _receiveError(err) {\n      this._log.error('ReceiveError: %s', err.message);\n    } // handle new peers\n\n  }, {\n    key: \"_onPeerConnected\",\n    value: function _onPeerConnected(peerId) {\n      this.wm.connected(peerId);\n    } // handle peers being disconnected\n\n  }, {\n    key: \"_onPeerDisconnected\",\n    value: function _onPeerDisconnected(peerId) {\n      this.wm.disconnected(peerId);\n      this.engine.peerDisconnected(peerId);\n\n      this._stats.disconnected(peerId);\n    }\n  }, {\n    key: \"_putBlock\",\n    value: function _putBlock(block, callback) {\n      var _this3 = this;\n\n      this.blockstore.put(block, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this3.notifications.hasBlock(block);\n\n        _this3.network.provide(block.cid, function (err) {\n          if (err) {\n            _this3._log.error('Failed to provide: %s', err.message);\n          }\n        });\n\n        _this3.engine.receivedBlocks([block.cid]);\n\n        callback();\n      });\n    }\n  }, {\n    key: \"enableStats\",\n    value: function enableStats() {\n      this._stats.enable();\n    }\n  }, {\n    key: \"disableStats\",\n    value: function disableStats() {\n      this._stats.disable();\n    }\n    /**\n     * Return the current wantlist for a given `peerId`\n     *\n     * @param {PeerId} peerId\n     * @returns {Wantlist}\n     */\n\n  }, {\n    key: \"wantlistForPeer\",\n    value: function wantlistForPeer(peerId) {\n      return this.engine.wantlistForPeer(peerId);\n    }\n    /**\n     * Return ledger information for a given `peerId`\n     *\n     * @param {PeerId} peerId\n     * @returns {?Object}\n     */\n\n  }, {\n    key: \"ledgerForPeer\",\n    value: function ledgerForPeer(peerId) {\n      return this.engine.ledgerForPeer(peerId);\n    }\n    /**\n     * Fetch a given block by cid. If the block is in the local\n     * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n     *\n     * @param {CID} cid\n     * @param {function(Error, Block)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(cid, callback) {\n      this.getMany([cid], function (err, blocks) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (blocks && blocks.length > 0) {\n          callback(null, blocks[0]);\n        } else {\n          // when a unwant happens\n          callback();\n        }\n      });\n    }\n    /**\n     * Fetch a a list of blocks by cid. If the blocks are in the local\n     * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n     *\n     * @param {Array<CID>} cids\n     * @param {function(Error, Blocks)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"getMany\",\n    value: function getMany(cids, callback) {\n      var _this4 = this;\n\n      var pendingStart = cids.length;\n      var wantList = [];\n      var promptedNetwork = false;\n\n      var getFromOutside = function getFromOutside(cid, cb) {\n        wantList.push(cid);\n\n        _this4.notifications.wantBlock(cid, // called on block receive\n        function (block) {\n          _this4.wm.cancelWants([cid]);\n\n          cb(null, block);\n        }, // called on unwant\n        function () {\n          _this4.wm.cancelWants([cid]);\n\n          cb(null, undefined);\n        });\n\n        if (!pendingStart) {\n          _this4.wm.wantBlocks(wantList);\n        }\n      };\n\n      map(cids, function (cid, cb) {\n        waterfall([function (cb) {\n          return _this4.blockstore.has(cid, cb);\n        }, function (has, cb) {\n          pendingStart--;\n\n          if (has) {\n            if (!pendingStart) {\n              _this4.wm.wantBlocks(wantList);\n            }\n\n            return _this4.blockstore.get(cid, cb);\n          }\n\n          if (!promptedNetwork) {\n            promptedNetwork = true;\n\n            _this4.network.findAndConnect(cids[0], function (err) {\n              if (err) {\n                _this4._log.error(err);\n              }\n            });\n          } // we don't have the block here\n\n\n          getFromOutside(cid, cb);\n        }], cb);\n      }, callback);\n    } // removes the given cids from the wantlist independent of any ref counts\n\n  }, {\n    key: \"unwant\",\n    value: function unwant(cids) {\n      var _this5 = this;\n\n      if (!Array.isArray(cids)) {\n        cids = [cids];\n      }\n\n      this.wm.unwantBlocks(cids);\n      cids.forEach(function (cid) {\n        return _this5.notifications.unwantBlock(cid);\n      });\n    } // removes the given keys from the want list\n\n  }, {\n    key: \"cancelWants\",\n    value: function cancelWants(cids) {\n      if (!Array.isArray(cids)) {\n        cids = [cids];\n      }\n\n      this.wm.cancelWants(cids);\n    }\n    /**\n     * Put the given block to the underlying blockstore and\n     * send it to nodes that have it in their wantlist.\n     *\n     * @param {Block} block\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(block, callback) {\n      var _this6 = this;\n\n      this._log('putting block');\n\n      waterfall([function (cb) {\n        return _this6.blockstore.has(block.cid, cb);\n      }, function (has, cb) {\n        if (has) {\n          return nextTick(cb);\n        }\n\n        _this6._putBlock(block, cb);\n      }], callback);\n    }\n    /**\n     * Put the given blocks to the underlying blockstore and\n     * send it to nodes that have it them their wantlist.\n     *\n     * @param {Array<Block>} blocks\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"putMany\",\n    value: function putMany(blocks, callback) {\n      var _this7 = this;\n\n      waterfall([function (cb) {\n        return reject(blocks, function (b, cb) {\n          _this7.blockstore.has(b.cid, cb);\n        }, cb);\n      }, function (newBlocks, cb) {\n        return _this7.blockstore.putMany(newBlocks, function (err) {\n          if (err) {\n            return cb(err);\n          }\n\n          newBlocks.forEach(function (block) {\n            _this7.notifications.hasBlock(block);\n\n            _this7.engine.receivedBlocks([block.cid]);\n\n            _this7.network.provide(block.cid, function (err) {\n              if (err) {\n                _this7._log.error('Failed to provide: %s', err.message);\n              }\n            });\n          });\n          cb();\n        });\n      }], callback);\n    }\n    /**\n     * Get the current list of wants.\n     *\n     * @returns {Iterator<WantlistEntry>}\n     */\n\n  }, {\n    key: \"getWantlist\",\n    value: function getWantlist() {\n      return this.wm.wantlist.entries();\n    }\n    /**\n     * Get the current list of partners.\n     *\n     * @returns {Array<PeerId>}\n     */\n\n  }, {\n    key: \"peers\",\n    value: function peers() {\n      return this.engine.peers();\n    }\n    /**\n     * Get stats about the bitswap node.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"stat\",\n    value: function stat() {\n      return this._stats;\n    }\n    /**\n     * Start the bitswap node.\n     *\n     * @param {function(Error)} callback\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(callback) {\n      var _this8 = this;\n\n      series([function (cb) {\n        return _this8.wm.start(cb);\n      }, function (cb) {\n        return _this8.network.start(cb);\n      }, function (cb) {\n        return _this8.engine.start(cb);\n      }], callback);\n    }\n    /**\n     * Stop the bitswap node.\n     *\n     * @param {function(Error)} callback\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      var _this9 = this;\n\n      this._stats.stop();\n\n      series([function (cb) {\n        return _this9.wm.stop(cb);\n      }, function (cb) {\n        return _this9.network.stop(cb);\n      }, function (cb) {\n        return _this9.engine.stop(cb);\n      }], callback);\n    }\n  }, {\n    key: \"peerInfo\",\n    get: function get() {\n      return this._libp2p.peerInfo;\n    }\n  }]);\n\n  return Bitswap;\n}();\n\nmodule.exports = Bitswap;","map":null,"metadata":{},"sourceType":"script"}