{"ast":null,"code":"'use strict';\n\nvar scrypt = require('scrypt-js');\n\nvar utils = function () {\n  var convert = require('../utils/convert');\n\n  return {\n    defineProperty: require('../utils/properties').defineProperty,\n    arrayify: convert.arrayify,\n    concat: convert.concat,\n    hexlify: convert.hexlify,\n    stripZeros: convert.stripZeros,\n    hexZeroPad: convert.hexZeroPad,\n    bigNumberify: require('../utils/bignumber').bigNumberify,\n    toUtf8Bytes: require('../utils/utf8').toUtf8Bytes,\n    getAddress: require('../utils/address').getAddress,\n    keccak256: require('../utils/keccak256'),\n    //randomBytes: require('../utils/random-bytes'),\n    randomBytes: require('../utils').randomBytes,\n    RLP: require('../utils/rlp')\n  };\n}();\n\nvar errors = require('../utils/errors');\n\nvar HDNode = require('./hdnode');\n\nvar secretStorage = require('./secret-storage');\n\nvar SigningKey = require('./signing-key'); // This ensures we inject a setImmediate into the global space, which\n// dramatically improves the performance of the scrypt PBKDF.\n\n\nrequire('setimmediate');\n\nvar defaultPath = \"m/44'/60'/0'/0/0\";\nvar transactionFields = [{\n  name: 'nonce',\n  maxLength: 32\n}, {\n  name: 'gasPrice',\n  maxLength: 32\n}, {\n  name: 'gasLimit',\n  maxLength: 32\n}, {\n  name: 'to',\n  length: 20\n}, {\n  name: 'value',\n  maxLength: 32\n}, {\n  name: 'data'\n}];\n\nfunction Wallet(privateKey, provider) {\n  errors.checkNew(this, Wallet); // Make sure we have a valid signing key\n\n  var signingKey = privateKey;\n\n  if (!(privateKey instanceof SigningKey)) {\n    signingKey = new SigningKey(privateKey);\n  }\n\n  utils.defineProperty(this, 'privateKey', signingKey.privateKey); // Provider\n\n  Object.defineProperty(this, 'provider', {\n    enumerable: true,\n    get: function get() {\n      return provider;\n    },\n    set: function set(value) {\n      provider = value;\n    }\n  });\n\n  if (provider) {\n    this.provider = provider;\n  }\n\n  var defaultGasLimit = 1500000;\n  Object.defineProperty(this, 'defaultGasLimit', {\n    enumerable: true,\n    get: function get() {\n      return defaultGasLimit;\n    },\n    set: function set(value) {\n      if (typeof value !== 'number') {\n        throw new Error('invalid defaultGasLimit');\n      }\n\n      defaultGasLimit = value;\n    }\n  });\n  utils.defineProperty(this, 'address', signingKey.address);\n  utils.defineProperty(this, 'sign', function (transaction) {\n    var chainId = transaction.chainId;\n\n    if (chainId == null && this.provider) {\n      chainId = this.provider.chainId;\n    }\n\n    if (!chainId) {\n      chainId = 0;\n    }\n\n    var raw = [];\n    transactionFields.forEach(function (fieldInfo) {\n      var value = transaction[fieldInfo.name] || [];\n      value = utils.arrayify(utils.hexlify(value), fieldInfo.name); // Fixed-width field\n\n      if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n        var error = new Error('invalid ' + fieldInfo.name);\n        error.reason = 'wrong length';\n        error.value = value;\n        throw error;\n      } // Variable-width (with a maximum)\n\n\n      if (fieldInfo.maxLength) {\n        value = utils.stripZeros(value);\n\n        if (value.length > fieldInfo.maxLength) {\n          var error = new Error('invalid ' + fieldInfo.name);\n          error.reason = 'too long';\n          error.value = value;\n          throw error;\n        }\n      }\n\n      raw.push(utils.hexlify(value));\n    });\n\n    if (chainId) {\n      raw.push(utils.hexlify(chainId));\n      raw.push('0x');\n      raw.push('0x');\n    }\n\n    var digest = utils.keccak256(utils.RLP.encode(raw));\n    var signature = signingKey.signDigest(digest);\n    var v = 27 + signature.recoveryParam;\n\n    if (chainId) {\n      raw.pop();\n      raw.pop();\n      raw.pop();\n      v += chainId * 2 + 8;\n    }\n\n    raw.push(utils.hexlify(v));\n    raw.push(utils.stripZeros(utils.arrayify(signature.r)));\n    raw.push(utils.stripZeros(utils.arrayify(signature.s)));\n    return utils.RLP.encode(raw);\n  });\n}\n\nutils.defineProperty(Wallet, 'parseTransaction', function (rawTransaction) {\n  rawTransaction = utils.hexlify(rawTransaction, 'rawTransaction');\n  var signedTransaction = utils.RLP.decode(rawTransaction);\n\n  if (signedTransaction.length !== 9) {\n    throw new Error('invalid transaction');\n  }\n\n  var raw = [];\n  var transaction = {};\n  transactionFields.forEach(function (fieldInfo, index) {\n    transaction[fieldInfo.name] = signedTransaction[index];\n    raw.push(signedTransaction[index]);\n  });\n\n  if (transaction.to) {\n    if (transaction.to == '0x') {\n      delete transaction.to;\n    } else {\n      transaction.to = utils.getAddress(transaction.to);\n    }\n  }\n\n  ['gasPrice', 'gasLimit', 'nonce', 'value'].forEach(function (name) {\n    if (!transaction[name]) {\n      return;\n    }\n\n    if (transaction[name].length === 0) {\n      transaction[name] = utils.bigNumberify(0);\n    } else {\n      transaction[name] = utils.bigNumberify(transaction[name]);\n    }\n  });\n\n  if (transaction.nonce) {\n    transaction.nonce = transaction.nonce.toNumber();\n  } else {\n    transaction.nonce = 0;\n  }\n\n  var v = utils.arrayify(signedTransaction[6]);\n  var r = utils.arrayify(signedTransaction[7]);\n  var s = utils.arrayify(signedTransaction[8]);\n\n  if (v.length >= 1 && r.length >= 1 && r.length <= 32 && s.length >= 1 && s.length <= 32) {\n    transaction.v = utils.bigNumberify(v).toNumber();\n    transaction.r = signedTransaction[7];\n    transaction.s = signedTransaction[8];\n    var chainId = (transaction.v - 35) / 2;\n\n    if (chainId < 0) {\n      chainId = 0;\n    }\n\n    chainId = parseInt(chainId);\n    transaction.chainId = chainId;\n    var recoveryParam = transaction.v - 27;\n\n    if (chainId) {\n      raw.push(utils.hexlify(chainId));\n      raw.push('0x');\n      raw.push('0x');\n      recoveryParam -= chainId * 2 + 8;\n    }\n\n    var digest = utils.keccak256(utils.RLP.encode(raw));\n\n    try {\n      transaction.from = SigningKey.recover(digest, r, s, recoveryParam);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  return transaction;\n});\nutils.defineProperty(Wallet.prototype, 'getAddress', function () {\n  return this.address;\n});\nutils.defineProperty(Wallet.prototype, 'getBalance', function (blockTag) {\n  if (!this.provider) {\n    throw new Error('missing provider');\n  }\n\n  return this.provider.getBalance(this.address, blockTag);\n});\nutils.defineProperty(Wallet.prototype, 'getTransactionCount', function (blockTag) {\n  if (!this.provider) {\n    throw new Error('missing provider');\n  }\n\n  return this.provider.getTransactionCount(this.address, blockTag);\n});\nutils.defineProperty(Wallet.prototype, 'estimateGas', function (transaction) {\n  if (!this.provider) {\n    throw new Error('missing provider');\n  }\n\n  var calculate = {};\n  ['from', 'to', 'data', 'value'].forEach(function (key) {\n    if (transaction[key] == null) {\n      return;\n    }\n\n    calculate[key] = transaction[key];\n  });\n\n  if (transaction.from == null) {\n    calculate.from = this.address;\n  }\n\n  return this.provider.estimateGas(calculate);\n});\nutils.defineProperty(Wallet.prototype, 'sendTransaction', function (transaction) {\n  if (!this.provider) {\n    throw new Error('missing provider');\n  }\n\n  if (!transaction || typeof transaction !== 'object') {\n    throw new Error('invalid transaction object');\n  }\n\n  var gasLimit = transaction.gasLimit;\n\n  if (gasLimit == null) {\n    gasLimit = this.defaultGasLimit;\n  }\n\n  var self = this;\n  var gasPricePromise = null;\n\n  if (transaction.gasPrice) {\n    gasPricePromise = Promise.resolve(transaction.gasPrice);\n  } else {\n    gasPricePromise = this.provider.getGasPrice();\n  }\n\n  var noncePromise = null;\n\n  if (transaction.nonce) {\n    noncePromise = Promise.resolve(transaction.nonce);\n  } else {\n    noncePromise = this.provider.getTransactionCount(self.address, 'pending');\n  }\n\n  var chainId = this.provider.chainId;\n  var toPromise = null;\n\n  if (transaction.to) {\n    toPromise = this.provider.resolveName(transaction.to);\n  } else {\n    toPromise = Promise.resolve(undefined);\n  }\n\n  var data = utils.hexlify(transaction.data || '0x');\n  var value = utils.hexlify(transaction.value || 0);\n  return Promise.all([gasPricePromise, noncePromise, toPromise]).then(function (results) {\n    var signedTransaction = self.sign({\n      to: results[2],\n      data: data,\n      gasLimit: gasLimit,\n      gasPrice: results[0],\n      nonce: results[1],\n      value: value,\n      chainId: chainId\n    });\n    return self.provider.sendTransaction(signedTransaction).then(function (hash) {\n      var transaction = Wallet.parseTransaction(signedTransaction);\n      transaction.hash = hash;\n\n      transaction.wait = function () {\n        return self.provider.waitForTransaction(hash);\n      };\n\n      return transaction;\n    });\n  });\n});\nutils.defineProperty(Wallet.prototype, 'send', function (addressOrName, amountWei, options) {\n  if (!options) {\n    options = {};\n  }\n\n  return this.sendTransaction({\n    to: addressOrName,\n    gasLimit: options.gasLimit,\n    gasPrice: options.gasPrice,\n    nonce: options.nonce,\n    value: amountWei\n  });\n});\nutils.defineProperty(Wallet, 'hashMessage', function (message) {\n  var payload = utils.concat([utils.toUtf8Bytes('\\x19Ethereum Signed Message:\\n'), utils.toUtf8Bytes(String(message.length)), typeof message === 'string' ? utils.toUtf8Bytes(message) : message]);\n  return utils.keccak256(payload);\n});\nutils.defineProperty(Wallet.prototype, 'signMessage', function (message) {\n  var signingKey = new SigningKey(this.privateKey);\n  var sig = signingKey.signDigest(Wallet.hashMessage(message));\n  return utils.hexZeroPad(sig.r, 32) + utils.hexZeroPad(sig.s, 32).substring(2) + (sig.recoveryParam ? '1c' : '1b');\n});\nutils.defineProperty(Wallet, 'verifyMessage', function (message, signature) {\n  signature = utils.hexlify(signature);\n\n  if (signature.length != 132) {\n    throw new Error('invalid signature');\n  }\n\n  var digest = Wallet.hashMessage(message);\n  var recoveryParam = parseInt(signature.substring(130), 16);\n\n  if (recoveryParam >= 27) {\n    recoveryParam -= 27;\n  }\n\n  if (recoveryParam < 0) {\n    throw new Error('invalid signature');\n  }\n\n  return SigningKey.recover(digest, signature.substring(0, 66), '0x' + signature.substring(66, 130), recoveryParam);\n});\nutils.defineProperty(Wallet.prototype, 'encrypt', function (password, options, progressCallback) {\n  if (typeof options === 'function' && !progressCallback) {\n    progressCallback = options;\n    options = {};\n  }\n\n  if (progressCallback && typeof progressCallback !== 'function') {\n    throw new Error('invalid callback');\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (this.mnemonic) {\n    // Make sure we don't accidentally bubble the mnemonic up the call-stack\n    var safeOptions = {};\n\n    for (var key in options) {\n      safeOptions[key] = options[key];\n    }\n\n    options = safeOptions; // Set the mnemonic and path\n\n    options.mnemonic = this.mnemonic;\n    options.path = this.path;\n  }\n\n  return secretStorage.encrypt(this.privateKey, password, options, progressCallback);\n});\nutils.defineProperty(Wallet, 'isEncryptedWallet', function (json) {\n  return secretStorage.isValidWallet(json) || secretStorage.isCrowdsaleWallet(json);\n});\nutils.defineProperty(Wallet, 'createRandom', function (options) {\n  var entropy = utils.randomBytes(16);\n\n  if (!options) {\n    options = {};\n  }\n\n  if (options.extraEntropy) {\n    entropy = utils.keccak256(utils.concat([entropy, options.extraEntropy])).substring(0, 34);\n  }\n\n  var mnemonic = HDNode.entropyToMnemonic(entropy);\n  return Wallet.fromMnemonic(mnemonic, options.path);\n});\nutils.defineProperty(Wallet, 'fromEncryptedWallet', function (json, password, progressCallback) {\n  if (progressCallback && typeof progressCallback !== 'function') {\n    throw new Error('invalid callback');\n  }\n\n  return new Promise(function (resolve, reject) {\n    if (secretStorage.isCrowdsaleWallet(json)) {\n      try {\n        var privateKey = secretStorage.decryptCrowdsale(json, password);\n        resolve(new Wallet(privateKey));\n      } catch (error) {\n        reject(error);\n      }\n    } else if (secretStorage.isValidWallet(json)) {\n      secretStorage.decrypt(json, password, progressCallback).then(function (signingKey) {\n        var wallet = new Wallet(signingKey);\n\n        if (signingKey.mnemonic && signingKey.path) {\n          utils.defineProperty(wallet, 'mnemonic', signingKey.mnemonic);\n          utils.defineProperty(wallet, 'path', signingKey.path);\n        }\n\n        resolve(wallet);\n        return null;\n      }, function (error) {\n        reject(error);\n      }).catch(function (error) {\n        reject(error);\n      });\n    } else {\n      reject('invalid wallet JSON');\n    }\n  });\n});\nutils.defineProperty(Wallet, 'fromMnemonic', function (mnemonic, path) {\n  if (!path) {\n    path = defaultPath;\n  }\n\n  var hdnode = HDNode.fromMnemonic(mnemonic).derivePath(path);\n  var wallet = new Wallet(hdnode.privateKey);\n  utils.defineProperty(wallet, 'mnemonic', mnemonic);\n  utils.defineProperty(wallet, 'path', path);\n  return wallet;\n});\nutils.defineProperty(Wallet, 'fromBrainWallet', function (username, password, progressCallback) {\n  if (progressCallback && typeof progressCallback !== 'function') {\n    throw new Error('invalid callback');\n  }\n\n  if (typeof username === 'string') {\n    username = utils.toUtf8Bytes(username, 'NFKC');\n  } else {\n    username = utils.arrayify(username, 'password');\n  }\n\n  if (typeof password === 'string') {\n    password = utils.toUtf8Bytes(password, 'NFKC');\n  } else {\n    password = utils.arrayify(password, 'password');\n  }\n\n  return new Promise(function (resolve, reject) {\n    scrypt(password, username, 1 << 18, 8, 1, 32, function (error, progress, key) {\n      if (error) {\n        reject(error);\n      } else if (key) {\n        resolve(new Wallet(utils.hexlify(key)));\n      } else if (progressCallback) {\n        return progressCallback(progress);\n      }\n    });\n  });\n}); //utils.defineProperty(Wallet, 'isCrowdsaleWallet', secretStorage.isCrowdsaleWallet);\n//utils.defineProperty(Wallet, 'decryptCrowdsale', function(json, password) {\n//    return new Wallet(secretStorage.decryptCrowdsale(json, password));\n//});\n\nmodule.exports = Wallet;","map":null,"metadata":{},"sourceType":"script"}