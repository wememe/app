{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar path = require('path');\n\nvar EventStore = require('orbit-db-eventstore');\n\nvar FeedStore = require('orbit-db-feedstore');\n\nvar KeyValueStore = require('orbit-db-kvstore');\n\nvar CounterStore = require('orbit-db-counterstore');\n\nvar DocumentStore = require('orbit-db-docstore');\n\nvar Pubsub = require('orbit-db-pubsub');\n\nvar Cache = require('orbit-db-cache');\n\nvar Keystore = require('orbit-db-keystore');\n\nvar AccessController = require('./ipfs-access-controller');\n\nvar OrbitDBAddress = require('./orbit-db-address');\n\nvar createDBManifest = require('./db-manifest');\n\nvar exchangeHeads = require('./exchange-heads');\n\nvar Logger = require('logplease');\n\nvar logger = Logger.create(\"orbit-db\");\nLogger.setLogLevel('ERROR'); // Mapping for 'database type' -> Class\n\nvar databaseTypes = {\n  'counter': CounterStore,\n  'eventlog': EventStore,\n  'feed': FeedStore,\n  'docstore': DocumentStore,\n  'keyvalue': KeyValueStore\n};\n\nvar OrbitDB =\n/*#__PURE__*/\nfunction () {\n  function OrbitDB(ipfs, directory) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, OrbitDB);\n\n    this._ipfs = ipfs;\n    this.id = options.peerId || (this._ipfs._peerInfo ? this._ipfs._peerInfo.id._idB58String : 'default');\n    this._pubsub = options && options.broker ? new options.broker(this._ipfs) : new Pubsub(this._ipfs, this.id);\n    this.stores = {};\n    this.directory = directory || './orbitdb';\n    this.keystore = options.keystore || Keystore.create(path.join(this.directory, this.id, '/keystore'));\n    this.cache = options.cache || Cache;\n    this.key = this.keystore.getKey(this.id) || this.keystore.createKey(this.id);\n    this._directConnections = {};\n  }\n  /* Databases */\n\n\n  _createClass(OrbitDB, [{\n    key: \"feed\",\n    value: function () {\n      var _feed = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(address) {\n        var options,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                options = Object.assign({\n                  create: true,\n                  type: 'feed'\n                }, options);\n                return _context.abrupt(\"return\", this.open(address, options));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function feed(_x) {\n        return _feed.apply(this, arguments);\n      }\n\n      return feed;\n    }()\n  }, {\n    key: \"log\",\n    value: function () {\n      var _log = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(address, options) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = Object.assign({\n                  create: true,\n                  type: 'eventlog'\n                }, options);\n                return _context2.abrupt(\"return\", this.open(address, options));\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function log(_x2, _x3) {\n        return _log.apply(this, arguments);\n      }\n\n      return log;\n    }()\n  }, {\n    key: \"eventlog\",\n    value: function () {\n      var _eventlog = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(address) {\n        var options,\n            _args3 = arguments;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n                return _context3.abrupt(\"return\", this.log(address, options));\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function eventlog(_x4) {\n        return _eventlog.apply(this, arguments);\n      }\n\n      return eventlog;\n    }()\n  }, {\n    key: \"keyvalue\",\n    value: function () {\n      var _keyvalue = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(address, options) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                options = Object.assign({\n                  create: true,\n                  type: 'keyvalue'\n                }, options);\n                return _context4.abrupt(\"return\", this.open(address, options));\n\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function keyvalue(_x5, _x6) {\n        return _keyvalue.apply(this, arguments);\n      }\n\n      return keyvalue;\n    }()\n  }, {\n    key: \"kvstore\",\n    value: function () {\n      var _kvstore = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(address, options) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this.keyvalue(address, options));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function kvstore(_x7, _x8) {\n        return _kvstore.apply(this, arguments);\n      }\n\n      return kvstore;\n    }()\n  }, {\n    key: \"counter\",\n    value: function () {\n      var _counter = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(address) {\n        var options,\n            _args6 = arguments;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                options = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};\n                options = Object.assign({\n                  create: true,\n                  type: 'counter'\n                }, options);\n                return _context6.abrupt(\"return\", this.open(address, options));\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function counter(_x9) {\n        return _counter.apply(this, arguments);\n      }\n\n      return counter;\n    }()\n  }, {\n    key: \"docs\",\n    value: function () {\n      var _docs = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7(address) {\n        var options,\n            _args7 = arguments;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n                options = Object.assign({\n                  create: true,\n                  type: 'docstore'\n                }, options);\n                return _context7.abrupt(\"return\", this.open(address, options));\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function docs(_x10) {\n        return _docs.apply(this, arguments);\n      }\n\n      return docs;\n    }()\n  }, {\n    key: \"docstore\",\n    value: function () {\n      var _docstore = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8(address) {\n        var options,\n            _args8 = arguments;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};\n                return _context8.abrupt(\"return\", this.docs(address, options));\n\n              case 2:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function docstore(_x11) {\n        return _docstore.apply(this, arguments);\n      }\n\n      return docstore;\n    }()\n  }, {\n    key: \"disconnect\",\n    value: function () {\n      var _disconnect = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee9() {\n        var _this = this;\n\n        var databases, _i, db, removeDirectConnect;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                // Close all open databases\n                databases = Object.values(this.stores);\n                _i = 0;\n\n              case 2:\n                if (!(_i < databases.length)) {\n                  _context9.next = 10;\n                  break;\n                }\n\n                db = databases[_i];\n                _context9.next = 6;\n                return db.close();\n\n              case 6:\n                delete this.stores[db.address.toString()];\n\n              case 7:\n                _i++;\n                _context9.next = 2;\n                break;\n\n              case 10:\n                // Close a direct connection and remove it from internal state\n                removeDirectConnect = function removeDirectConnect(e) {\n                  _this._directConnections[e].close();\n\n                  delete _this._directConnections[e];\n                }; // Close all direct connections to peers\n\n\n                Object.keys(this._directConnections).forEach(removeDirectConnect); // Disconnect from pubsub\n\n                if (!this._pubsub) {\n                  _context9.next = 15;\n                  break;\n                }\n\n                _context9.next = 15;\n                return this._pubsub.disconnect();\n\n              case 15:\n                // Remove all databases from the state\n                this.stores = {};\n\n              case 16:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function disconnect() {\n        return _disconnect.apply(this, arguments);\n      }\n\n      return disconnect;\n    }() // Alias for disconnect()\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee10() {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.disconnect();\n\n              case 2:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /* Private methods */\n\n  }, {\n    key: \"_createStore\",\n    value: function () {\n      var _createStore2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee11(type, address, options) {\n        var Store, accessController, cache, opts, store, addr;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                // Get the type -> class mapping\n                Store = databaseTypes[type];\n\n                if (Store) {\n                  _context11.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Invalid database type '\".concat(type, \"'\"));\n\n              case 3:\n                if (!options.accessControllerAddress) {\n                  _context11.next = 7;\n                  break;\n                }\n\n                accessController = new AccessController(this._ipfs);\n                _context11.next = 7;\n                return accessController.load(options.accessControllerAddress);\n\n              case 7:\n                _context11.next = 9;\n                return this._loadCache(this.directory, address);\n\n              case 9:\n                cache = _context11.sent;\n                opts = Object.assign({\n                  replicate: true\n                }, options, {\n                  accessController: accessController,\n                  keystore: this.keystore,\n                  cache: cache,\n                  onClose: this._onClose.bind(this)\n                });\n                store = new Store(this._ipfs, this.id, address, opts);\n                store.events.on('write', this._onWrite.bind(this)); // ID of the store is the address as a string\n\n                addr = address.toString();\n                this.stores[addr] = store; // Subscribe to pubsub to get updates from peers,\n                // this is what hooks us into the message propagation layer\n                // and the p2p network\n\n                if (opts.replicate && this._pubsub) this._pubsub.subscribe(addr, this._onMessage.bind(this), this._onPeerConnected.bind(this));\n                return _context11.abrupt(\"return\", store);\n\n              case 17:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function _createStore(_x12, _x13, _x14) {\n        return _createStore2.apply(this, arguments);\n      }\n\n      return _createStore;\n    }() // Callback for local writes to the database. We the update to pubsub.\n\n  }, {\n    key: \"_onWrite\",\n    value: function _onWrite(address, entry, heads) {\n      if (!heads) throw new Error(\"'heads' not defined\");\n      if (this._pubsub) this._pubsub.publish(address, heads);\n    } // Callback for receiving a message from the network\n\n  }, {\n    key: \"_onMessage\",\n    value: function () {\n      var _onMessage2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee12(address, heads) {\n        var store;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                store = this.stores[address];\n                _context12.prev = 1;\n                logger.debug(\"Received \".concat(heads.length, \" heads for '\").concat(address, \"':\\n\"), JSON.stringify(heads.map(function (e) {\n                  return e.hash;\n                }), null, 2));\n\n                if (!(store && heads && heads.length > 0)) {\n                  _context12.next = 6;\n                  break;\n                }\n\n                _context12.next = 6;\n                return store.sync(heads);\n\n              case 6:\n                _context12.next = 11;\n                break;\n\n              case 8:\n                _context12.prev = 8;\n                _context12.t0 = _context12[\"catch\"](1);\n                logger.error(_context12.t0);\n\n              case 11:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[1, 8]]);\n      }));\n\n      function _onMessage(_x15, _x16) {\n        return _onMessage2.apply(this, arguments);\n      }\n\n      return _onMessage;\n    }() // Callback for when a peer connected to a database\n\n  }, {\n    key: \"_onPeerConnected\",\n    value: function () {\n      var _onPeerConnected2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee13(address, peer) {\n        var _this2 = this;\n\n        var getStore, getDirectConnection, onChannelCreated, onMessage, channel;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                logger.debug(\"New peer '\".concat(peer, \"' connected to '\").concat(address, \"'\"));\n\n                getStore = function getStore(address) {\n                  return _this2.stores[address];\n                };\n\n                getDirectConnection = function getDirectConnection(peer) {\n                  return _this2._directConnections[peer];\n                };\n\n                onChannelCreated = function onChannelCreated(channel) {\n                  return _this2._directConnections[channel._receiverID] = channel;\n                };\n\n                onMessage = function onMessage(address, heads) {\n                  return _this2._onMessage(address, heads);\n                };\n\n                _context13.next = 7;\n                return exchangeHeads(this._ipfs, address, peer, getStore, getDirectConnection, onMessage, onChannelCreated);\n\n              case 7:\n                channel = _context13.sent;\n                if (getStore(address)) getStore(address).events.emit('peer', peer);\n\n              case 9:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function _onPeerConnected(_x17, _x18) {\n        return _onPeerConnected2.apply(this, arguments);\n      }\n\n      return _onPeerConnected;\n    }() // Callback when database was closed\n\n  }, {\n    key: \"_onClose\",\n    value: function () {\n      var _onClose2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee14(address) {\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                logger.debug(\"Close \".concat(address)); // Unsubscribe from pubsub\n\n                if (!this._pubsub) {\n                  _context14.next = 4;\n                  break;\n                }\n\n                _context14.next = 4;\n                return this._pubsub.unsubscribe(address);\n\n              case 4:\n                delete this.stores[address];\n\n              case 5:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function _onClose(_x19) {\n        return _onClose2.apply(this, arguments);\n      }\n\n      return _onClose;\n    }()\n    /* Create and Open databases */\n\n    /*\n      options = {\n        admin: [], // array of keys that are the admins of this database (same as write access)\n        write: [], // array of keys that can write to this database\n        directory: './orbitdb', // directory in which to place the database files\n        overwrite: false, // whether we should overwrite the existing database if it exists\n      }\n    */\n\n  }, {\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee15(name, type) {\n        var options,\n            directory,\n            accessController,\n            accessControllerAddress,\n            manifestHash,\n            dbAddress,\n            cache,\n            haveDB,\n            _args15 = arguments;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                options = _args15.length > 2 && _args15[2] !== undefined ? _args15[2] : {};\n                logger.debug(\"create()\");\n\n                if (OrbitDB.isValidType(type)) {\n                  _context15.next = 4;\n                  break;\n                }\n\n                throw new Error(\"Invalid database type '\".concat(type, \"'\"));\n\n              case 4:\n                // The directory to look databases from can be passed in as an option\n                directory = options.directory || this.directory;\n                logger.debug(\"Creating database '\".concat(name, \"' as \").concat(type, \" in '\").concat(directory, \"'\"));\n\n                if (!OrbitDBAddress.isValid(name)) {\n                  _context15.next = 8;\n                  break;\n                }\n\n                throw new Error(\"Given database name is an address. Please give only the name of the database!\");\n\n              case 8:\n                // Create an AccessController\n                accessController = new AccessController(this._ipfs);\n                /* Disabled temporarily until we do something with the admin keys */\n                // Add admins of the database to the access controller\n                // if (options && options.admin) {\n                //   options.admin.forEach(e => accessController.add('admin', e))\n                // } else {\n                //   // Default is to add ourselves as the admin of the database\n                //   accessController.add('admin', this.key.getPublic('hex'))\n                // }\n                // Add keys that can write to the database\n\n                if (options && options.write && options.write.length > 0) {\n                  options.write.forEach(function (e) {\n                    return accessController.add('write', e);\n                  });\n                } else {\n                  // Default is to add ourselves as the admin of the database\n                  accessController.add('write', this.key.getPublic('hex'));\n                } // Save the Access Controller in IPFS\n\n\n                _context15.next = 12;\n                return accessController.save();\n\n              case 12:\n                accessControllerAddress = _context15.sent;\n                _context15.next = 15;\n                return createDBManifest(this._ipfs, name, type, accessControllerAddress);\n\n              case 15:\n                manifestHash = _context15.sent;\n                // Create the database address\n                dbAddress = OrbitDBAddress.parse(path.join('/orbitdb', manifestHash, name)); // Load the locally saved database information\n\n                _context15.next = 19;\n                return this._loadCache(directory, dbAddress);\n\n              case 19:\n                cache = _context15.sent;\n                _context15.next = 22;\n                return this._haveLocalData(cache, dbAddress);\n\n              case 22:\n                haveDB = _context15.sent;\n\n                if (!(haveDB && !options.overwrite)) {\n                  _context15.next = 25;\n                  break;\n                }\n\n                throw new Error(\"Database '\".concat(dbAddress, \"' already exists!\"));\n\n              case 25:\n                _context15.next = 27;\n                return this._saveDBManifest(directory, dbAddress);\n\n              case 27:\n                logger.debug(\"Created database '\".concat(dbAddress, \"'\")); // Open the database\n\n                return _context15.abrupt(\"return\", this.open(dbAddress, options));\n\n              case 29:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function create(_x20, _x21) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n    /*\n        options = {\n          localOnly: false // if set to true, throws an error if database can't be found locally\n          create: false // whether to create the database\n          type: TODO\n          overwrite: TODO\n         }\n     */\n\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee16(address) {\n        var options,\n            directory,\n            dbAddress,\n            cache,\n            haveDB,\n            dag,\n            manifest,\n            _args16 = arguments;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                options = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : {};\n                logger.debug(\"open()\");\n                options = Object.assign({\n                  localOnly: false,\n                  create: false\n                }, options);\n                logger.debug(\"Open database '\".concat(address, \"'\")); // The directory to look databases from can be passed in as an option\n\n                directory = options.directory || this.directory;\n                logger.debug(\"Look from '\".concat(directory, \"'\")); // If address is just the name of database, check the options to crate the database\n\n                if (OrbitDBAddress.isValid(address)) {\n                  _context16.next = 18;\n                  break;\n                }\n\n                if (options.create) {\n                  _context16.next = 11;\n                  break;\n                }\n\n                throw new Error(\"'options.create' set to 'false'. If you want to create a database, set 'options.create' to 'true'.\");\n\n              case 11:\n                if (!(options.create && !options.type)) {\n                  _context16.next = 15;\n                  break;\n                }\n\n                throw new Error(\"Database type not provided! Provide a type with 'options.type' (\".concat(OrbitDB.databaseTypes.join('|'), \")\"));\n\n              case 15:\n                logger.warn(\"Not a valid OrbitDB address '\".concat(address, \"', creating the database\"));\n                options.overwrite = options.overwrite ? options.overwrite : true;\n                return _context16.abrupt(\"return\", this.create(address, options.type, options));\n\n              case 18:\n                // Parse the database address\n                dbAddress = OrbitDBAddress.parse(address); // Load the locally saved db information\n\n                _context16.next = 21;\n                return this._loadCache(directory, dbAddress);\n\n              case 21:\n                cache = _context16.sent;\n                _context16.next = 24;\n                return this._haveLocalData(cache, dbAddress);\n\n              case 24:\n                haveDB = _context16.sent;\n                logger.debug((haveDB ? 'Found' : 'Didn\\'t find') + \" database '\".concat(dbAddress, \"'\")); // If we want to try and open the database local-only, throw an error\n                // if we don't have the database locally\n\n                if (!(options.localOnly && !haveDB)) {\n                  _context16.next = 29;\n                  break;\n                }\n\n                logger.warn(\"Database '\".concat(dbAddress, \"' doesn't exist!\"));\n                throw new Error(\"Database '\".concat(dbAddress, \"' doesn't exist!\"));\n\n              case 29:\n                logger.debug(\"Loading Manifest for '\".concat(dbAddress, \"'\")); // Get the database manifest from IPFS\n\n                _context16.next = 32;\n                return this._ipfs.object.get(dbAddress.root);\n\n              case 32:\n                dag = _context16.sent;\n                manifest = JSON.parse(dag.toJSON().data);\n                logger.debug(\"Manifest for '\".concat(dbAddress, \"':\\n\").concat(JSON.stringify(manifest, null, 2))); // Make sure the type from the manifest matches the type that was given as an option\n\n                if (!(options.type && manifest.type !== options.type)) {\n                  _context16.next = 37;\n                  break;\n                }\n\n                throw new Error(\"Database '\".concat(dbAddress, \"' is type '\").concat(manifest.type, \"' but was opened as '\").concat(options.type, \"'\"));\n\n              case 37:\n                _context16.next = 39;\n                return this._saveDBManifest(directory, dbAddress);\n\n              case 39:\n                // Open the the database\n                options = Object.assign({}, options, {\n                  accessControllerAddress: manifest.accessController\n                });\n                return _context16.abrupt(\"return\", this._createStore(manifest.type, dbAddress, options));\n\n              case 41:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function open(_x22) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }() // Save the database locally\n\n  }, {\n    key: \"_saveDBManifest\",\n    value: function () {\n      var _saveDBManifest2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee17(directory, dbAddress) {\n        var cache;\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.next = 2;\n                return this._loadCache(directory, dbAddress);\n\n              case 2:\n                cache = _context17.sent;\n                _context17.next = 5;\n                return cache.set(path.join(dbAddress.toString(), '_manifest'), dbAddress.root);\n\n              case 5:\n                logger.debug(\"Saved manifest to IPFS as '\".concat(dbAddress.root, \"'\"));\n\n              case 6:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function _saveDBManifest(_x23, _x24) {\n        return _saveDBManifest2.apply(this, arguments);\n      }\n\n      return _saveDBManifest;\n    }() // Loads the locally saved database information (manifest, head hashes)\n\n  }, {\n    key: \"_loadCache\",\n    value: function () {\n      var _loadCache2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee18(directory, dbAddress) {\n        var cache;\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _context18.prev = 0;\n                _context18.next = 3;\n                return this.cache.load(directory, dbAddress);\n\n              case 3:\n                cache = _context18.sent;\n                _context18.next = 10;\n                break;\n\n              case 6:\n                _context18.prev = 6;\n                _context18.t0 = _context18[\"catch\"](0);\n                console.log(_context18.t0);\n                logger.error(\"Couldn't load Cache:\", _context18.t0);\n\n              case 10:\n                return _context18.abrupt(\"return\", cache);\n\n              case 11:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this, [[0, 6]]);\n      }));\n\n      function _loadCache(_x25, _x26) {\n        return _loadCache2.apply(this, arguments);\n      }\n\n      return _loadCache;\n    }()\n    /**\n     * Check if we have the database, or part of it, saved locally\n     * @param  {[Cache]} cache [The OrbitDBCache instance containing the local data]\n     * @param  {[OrbitDBAddress]} dbAddress [Address of the database to check]\n     * @return {[Boolean]} [Returns true if we have cached the db locally, false if not]\n     */\n\n  }, {\n    key: \"_haveLocalData\",\n    value: function () {\n      var _haveLocalData2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee19(cache, dbAddress) {\n        var data;\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                if (cache) {\n                  _context19.next = 2;\n                  break;\n                }\n\n                return _context19.abrupt(\"return\", false);\n\n              case 2:\n                _context19.next = 4;\n                return cache.get(path.join(dbAddress.toString(), '_manifest'));\n\n              case 4:\n                data = _context19.sent;\n                return _context19.abrupt(\"return\", data !== undefined && data !== null);\n\n              case 6:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function _haveLocalData(_x27, _x28) {\n        return _haveLocalData2.apply(this, arguments);\n      }\n\n      return _haveLocalData;\n    }()\n    /**\n     * Returns supported database types as an Array of strings\n     * Eg. [ 'counter', 'eventlog', 'feed', 'docstore', 'keyvalue']\n     * @return {[Array]} [Supported database types]\n     */\n\n  }], [{\n    key: \"isValidType\",\n    value: function isValidType(type) {\n      return Object.keys(databaseTypes).includes(type);\n    }\n  }, {\n    key: \"addDatabaseType\",\n    value: function addDatabaseType(type, store) {\n      if (databaseTypes[type]) throw new Error(\"Type already exists: \".concat(type));\n      databaseTypes[type] = store;\n    }\n  }, {\n    key: \"getDatabaseTypes\",\n    value: function getDatabaseTypes() {\n      return databaseTypes;\n    }\n  }, {\n    key: \"isValidAddress\",\n    value: function isValidAddress(address) {\n      return OrbitDBAddress.isValid(address);\n    }\n  }, {\n    key: \"parseAddress\",\n    value: function parseAddress(address) {\n      return OrbitDBAddress.parse(address);\n    }\n  }, {\n    key: \"databaseTypes\",\n    get: function get() {\n      return Object.keys(databaseTypes);\n    }\n  }]);\n\n  return OrbitDB;\n}();\n\nmodule.exports = OrbitDB;","map":null,"metadata":{},"sourceType":"script"}