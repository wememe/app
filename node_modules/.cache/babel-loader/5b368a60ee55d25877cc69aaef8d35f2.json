{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar pull = require('pull-stream');\n\nvar lp = require('pull-length-prefixed');\n\nvar handshake = require('pull-handshake');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:circuit:stream-handler');\nlog.err = debug('libp2p:circuit:error:stream-handler');\n\nvar StreamHandler =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Create a stream handler for connection\n   *\n   * @param {Connection} conn - connection to read/write\n   * @param {Function|undefined} cb - handshake callback called on error\n   * @param {Number} timeout - handshake timeout\n   * @param {Number} maxLength - max bytes length of message\n   */\n  function StreamHandler(conn, cb, timeout, maxLength) {\n    _classCallCheck(this, StreamHandler);\n\n    this.conn = conn;\n    this.stream = null;\n    this.shake = null;\n    this.timeout = cb || 1000 * 60;\n    this.maxLength = maxLength || 4096;\n\n    if (typeof cb === 'function') {\n      this.timeout = timeout || 1000 * 60;\n    }\n\n    this.stream = handshake({\n      timeout: this.timeout\n    }, cb);\n    this.shake = this.stream.handshake;\n    pull(this.stream, conn, this.stream);\n  }\n\n  _createClass(StreamHandler, [{\n    key: \"isValid\",\n    value: function isValid() {\n      return this.conn && this.shake && this.stream;\n    }\n    /**\n     * Read and decode message\n     *\n     * @param {Function} cb\n     * @returns {void|Function}\n     */\n\n  }, {\n    key: \"read\",\n    value: function read(cb) {\n      if (!this.isValid()) {\n        cb(new Error(\"handler is not in a valid state\"));\n      }\n\n      lp.decodeFromReader(this.shake, {\n        maxLength: this.maxLength\n      }, function (err, msg) {\n        if (err) {\n          log.err(err); // this.shake.abort(err)\n\n          return cb(err);\n        }\n\n        return cb(null, msg);\n      });\n    }\n    /**\n     * Encode and write array of buffers\n     *\n     * @param {Buffer[]} msg\n     * @param {Function} [cb]\n     * @returns {Function}\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(msg, cb) {\n      var _this = this;\n\n      cb = cb || function () {};\n\n      if (!this.isValid()) {\n        cb(new Error(\"handler is not in a valid state\"));\n      }\n\n      pull(pull.values([msg]), lp.encode(), pull.collect(function (err, encoded) {\n        if (err) {\n          log.err(err);\n\n          _this.shake.abort(err);\n\n          return cb(err);\n        }\n\n        encoded.forEach(function (e) {\n          return _this.shake.write(e);\n        });\n        cb();\n      }));\n    }\n    /**\n     * Get the raw Connection\n     *\n     * @returns {null|Connection|*}\n     */\n\n  }, {\n    key: \"getRawConn\",\n    value: function getRawConn() {\n      return this.conn;\n    }\n    /**\n     * Return the handshake rest stream and invalidate handler\n     *\n     * @return {*|{source, sink}}\n     */\n\n  }, {\n    key: \"rest\",\n    value: function rest() {\n      var rest = this.shake.rest();\n      this.conn = null;\n      this.stream = null;\n      this.shake = null;\n      return rest;\n    }\n    /**\n     * Close the stream\n     *\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      // close stream\n      pull(pull.empty(), this.rest());\n    }\n  }]);\n\n  return StreamHandler;\n}();\n\nmodule.exports = StreamHandler;","map":null,"metadata":{},"sourceType":"script"}