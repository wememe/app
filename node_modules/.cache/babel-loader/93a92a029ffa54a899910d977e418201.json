{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar parallel = require('async/parallel');\n\nvar once = require('once');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:switch:transport');\n\nvar LimitDialer = require('./limit-dialer'); // number of concurrent outbound dials to make per peer, same as go-libp2p-swtch\n\n\nvar defaultPerPeerRateLimit = 8; // the amount of time a single dial has to succeed\n// TODO this should be exposed as a option\n\nvar dialTimeout = 30 * 1000;\n/**\n * Manages the transports for the switch. This simplifies dialing and listening across\n * multiple transports.\n */\n\nvar TransportManager =\n/*#__PURE__*/\nfunction () {\n  function TransportManager(_switch) {\n    _classCallCheck(this, TransportManager);\n\n    this.switch = _switch;\n    this.dialer = new LimitDialer(defaultPerPeerRateLimit, dialTimeout);\n  }\n  /**\n   * Adds a `Transport` to the list of transports on the switch, and assigns it to the given key\n   *\n   * @param {String} key\n   * @param {Transport} transport\n   * @returns {void}\n   */\n\n\n  _createClass(TransportManager, [{\n    key: \"add\",\n    value: function add(key, transport) {\n      log('adding %s', key);\n\n      if (this.switch.transports[key]) {\n        throw new Error('There is already a transport with this key');\n      }\n\n      this.switch.transports[key] = transport;\n\n      if (!this.switch.transports[key].listeners) {\n        this.switch.transports[key].listeners = [];\n      }\n    }\n    /**\n     * For a given transport `key`, dial to all that transport multiaddrs\n     *\n     * @param {String} key Key of the `Transport` to dial\n     * @param {PeerInfo} peerInfo\n     * @param {function(Error, Connection)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"dial\",\n    value: function dial(key, peerInfo, callback) {\n      var _this = this;\n\n      var transport = this.switch.transports[key];\n      var multiaddrs = peerInfo.multiaddrs.toArray();\n\n      if (!Array.isArray(multiaddrs)) {\n        multiaddrs = [multiaddrs];\n      } // filter the multiaddrs that are actually valid for this transport\n\n\n      multiaddrs = TransportManager.dialables(transport, multiaddrs);\n      log('dialing %s', key, multiaddrs.map(function (m) {\n        return m.toString();\n      })); // dial each of the multiaddrs with the given transport\n\n      this.dialer.dialMany(peerInfo.id, transport, multiaddrs, function (err, success) {\n        if (err) {\n          return callback(err);\n        }\n\n        peerInfo.connect(success.multiaddr);\n\n        _this.switch._peerBook.put(peerInfo);\n\n        callback(null, success.conn);\n      });\n    }\n    /**\n     * For a given Transport `key`, listen on all multiaddrs in the switch's `_peerInfo`.\n     * If a `handler` is not provided, the Switch's `protocolMuxer` will be used.\n     *\n     * @param {String} key\n     * @param {*} options\n     * @param {function(Connection)} handler\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"listen\",\n    value: function listen(key, options, handler, callback) {\n      var _this2 = this;\n\n      var muxerHandler; // if no handler is passed, we pass conns to protocolMuxer\n\n      if (!handler) {\n        handler = this.switch.protocolMuxer(key);\n      } // If we have a protector make the connection private\n\n\n      if (this.switch.protector) {\n        muxerHandler = handler;\n\n        handler = function handler(parentConnection) {\n          var connection = _this2.switch.protector.protect(parentConnection, function () {\n            // If we get an error here, we should stop talking to this peer\n            muxerHandler(connection);\n          });\n        };\n      }\n\n      var transport = this.switch.transports[key];\n      var multiaddrs = TransportManager.dialables(transport, this.switch._peerInfo.multiaddrs.distinct());\n\n      if (!transport.listeners) {\n        transport.listeners = [];\n      }\n\n      var freshMultiaddrs = [];\n      var createListeners = multiaddrs.map(function (ma) {\n        return function (cb) {\n          var done = once(cb);\n          var listener = transport.createListener(handler);\n          listener.once('error', done);\n          listener.listen(ma, function (err) {\n            if (err) {\n              return done(err);\n            }\n\n            listener.removeListener('error', done);\n            listener.getAddrs(function (err, addrs) {\n              if (err) {\n                return done(err);\n              }\n\n              freshMultiaddrs = freshMultiaddrs.concat(addrs);\n              transport.listeners.push(listener);\n              done();\n            });\n          });\n        };\n      });\n      parallel(createListeners, function (err) {\n        if (err) {\n          return callback(err);\n        } // cause we can listen on port 0 or 0.0.0.0\n\n\n        _this2.switch._peerInfo.multiaddrs.replace(multiaddrs, freshMultiaddrs);\n\n        callback();\n      });\n    }\n    /**\n     * Closes the transport with the given key, by closing all of its listeners\n     *\n     * @param {String} key\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(key, callback) {\n      var transport = this.switch.transports[key];\n\n      if (!transport) {\n        return callback(new Error(\"Trying to close non existing transport: \".concat(key)));\n      }\n\n      parallel(transport.listeners.map(function (listener) {\n        return function (cb) {\n          listener.close(cb);\n        };\n      }), callback);\n    }\n    /**\n     * For a given transport, return its multiaddrs that match the given multiaddrs\n     *\n     * @param {Transport} transport\n     * @param {Array<Multiaddr>} multiaddrs\n     * @returns {Array<Multiaddr>}\n     */\n\n  }], [{\n    key: \"dialables\",\n    value: function dialables(transport, multiaddrs) {\n      return transport.filter(multiaddrs);\n    }\n  }]);\n\n  return TransportManager;\n}();\n\nmodule.exports = TransportManager;","map":null,"metadata":{},"sourceType":"script"}