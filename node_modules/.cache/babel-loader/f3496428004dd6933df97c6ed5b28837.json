{"ast":null,"code":"'use strict';\n\nvar bigNumberify = require('./bignumber').bigNumberify;\n\nvar convert = require('./convert');\n\nvar getAddress = require('./address').getAddress;\n\nvar utf8 = require('./utf8');\n\nvar hashKeccak256 = require('./keccak256');\n\nvar hashSha256 = require('./sha2').sha256;\n\nvar regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nvar regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nvar regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\nvar Zeros = '0000000000000000000000000000000000000000000000000000000000000000';\n\nfunction _pack(type, value, isArray) {\n  switch (type) {\n    case 'address':\n      if (isArray) {\n        return convert.padZeros(value, 32);\n      }\n\n      return convert.arrayify(value);\n\n    case 'string':\n      return utf8.toUtf8Bytes(value);\n\n    case 'bytes':\n      return convert.arrayify(value);\n\n    case 'bool':\n      value = value ? '0x01' : '0x00';\n\n      if (isArray) {\n        return convert.padZeros(value, 32);\n      }\n\n      return convert.arrayify(value);\n  }\n\n  var match = type.match(regexNumber);\n\n  if (match) {\n    var signed = match[1] === 'int';\n    var size = parseInt(match[2] || \"256\");\n\n    if (size % 8 != 0 || size === 0 || size > 256) {\n      throw new Error('invalid number type - ' + type);\n    }\n\n    if (isArray) {\n      size = 256;\n    }\n\n    value = bigNumberify(value).toTwos(size);\n    return convert.padZeros(value, size / 8);\n  }\n\n  match = type.match(regexBytes);\n\n  if (match) {\n    var size = match[1];\n\n    if (size != parseInt(size) || size === 0 || size > 32) {\n      throw new Error('invalid number type - ' + type);\n    }\n\n    size = parseInt(size);\n\n    if (convert.arrayify(value).byteLength !== size) {\n      throw new Error('invalid value for ' + type);\n    }\n\n    if (isArray) {\n      return (value + Zeros).substring(0, 66);\n    }\n\n    return value;\n  }\n\n  match = type.match(regexArray);\n\n  if (match) {\n    var baseType = match[1];\n    var count = parseInt(match[2] || value.length);\n\n    if (count != value.length) {\n      throw new Error('invalid value for ' + type);\n    }\n\n    var result = [];\n    value.forEach(function (value) {\n      value = _pack(baseType, value, true);\n      result.push(value);\n    });\n    return convert.concat(result);\n  }\n\n  throw new Error('unknown type - ' + type);\n}\n\nfunction pack(types, values) {\n  if (types.length != values.length) {\n    throw new Error('type/value count mismatch');\n  }\n\n  var tight = [];\n  types.forEach(function (type, index) {\n    tight.push(_pack(type, values[index]));\n  });\n  return convert.hexlify(convert.concat(tight));\n}\n\nfunction keccak256(types, values) {\n  return hashKeccak256(pack(types, values));\n}\n\nfunction sha256(types, values) {\n  return hashSha256(pack(types, values));\n}\n\nmodule.exports = {\n  pack: pack,\n  keccak256: keccak256,\n  sha256: sha256\n};","map":null,"metadata":{},"sourceType":"script"}