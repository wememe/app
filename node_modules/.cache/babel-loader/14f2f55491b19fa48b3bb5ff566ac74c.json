{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveAuthenticator = exports.verifyJWT = exports.createJWT = exports.IAT_SKEW = undefined;\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _stringify = require('babel-runtime/core-js/json/stringify');\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n/**\n*  Creates a signed JWT given an address which becomes the issuer, a signer, and a payload for which the signature is over.\n*\n*  @example\n*  const signer = SimpleSigner(process.env.PRIVATE_KEY)\n*  createJWT({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {\n*      ...\n*  })\n*\n*  @param    {Object}            payload            payload object\n*  @param    {Object}            [config]           an unsigned credential object\n*  @param    {String}            config.issuer      The DID of the issuer (signer) of JWT\n*  @param    {String}            config.alg         The JWT signing algorithm to use. Supports: [ES256K, ES256K-R], Defaults to: ES256K\n*  @param    {SimpleSigner}      config.signer      a signer, reference our SimpleSigner.js\n*  @return   {Promise<Object, Error>}               a promise which resolves with a signed JSON Web Token or rejects with an error\n*/\n\n\nvar createJWT = exports.createJWT = function () {\n  var _ref2 = (0, _asyncToGenerator3.default)(\n  /*#__PURE__*/\n  _regenerator2.default.mark(function _callee(payload, _ref) {\n    var issuer = _ref.issuer,\n        signer = _ref.signer,\n        alg = _ref.alg,\n        expiresIn = _ref.expiresIn;\n    var header, timestamps, signingInput, jwtSigner, signature;\n    return _regenerator2.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (signer) {\n              _context.next = 2;\n              break;\n            }\n\n            throw new Error('No Signer functionality has been configured');\n\n          case 2:\n            if (issuer) {\n              _context.next = 4;\n              break;\n            }\n\n            throw new Error('No issuing DID has been configured');\n\n          case 4:\n            header = (0, _extends3.default)({}, JOSE_HEADER, {\n              alg: alg || defaultAlg\n            });\n            timestamps = {\n              iat: Math.floor(Date.now() / 1000)\n            };\n\n            if (!expiresIn) {\n              _context.next = 12;\n              break;\n            }\n\n            if (!(typeof expiresIn === 'number')) {\n              _context.next = 11;\n              break;\n            }\n\n            timestamps.exp = timestamps.iat + Math.floor(expiresIn);\n            _context.next = 12;\n            break;\n\n          case 11:\n            throw new Error('JWT expiresIn is not a number');\n\n          case 12:\n            signingInput = [encodeSection(header), encodeSection((0, _extends3.default)({}, timestamps, payload, {\n              iss: issuer\n            }))].join('.');\n            jwtSigner = (0, _SignerAlgorithm2.default)(header.alg);\n            _context.next = 16;\n            return jwtSigner(signingInput, signer);\n\n          case 16:\n            signature = _context.sent;\n            return _context.abrupt('return', [signingInput, signature].join('.'));\n\n          case 18:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  return function createJWT(_x, _x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n*  Verifies given JWT. If the JWT is valid, the promise returns an object including the JWT, the payload of the JWT,\n*  and the did doc of the issuer of the JWT.\n*\n*  @example\n*  verifyJWT('did:uport:eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', {audience: '5A8bRWU3F7j3REx3vkJ...', callbackUrl: 'https://...}).then(obj => {\n       const did = obj.did // DID of signer\n*      const payload = obj.payload\n*      const doc = obj.doc // DID Document of signer\n*      const jwt = obj.jwt\n*      const signerKeyId = obj.signerKeyId // ID of key in DID document that signed JWT\n*      ...\n*  })\n*\n*  @param    {String}            jwt                a JSON Web Token to verify\n*  @param    {Object}            [config]           an unsigned credential object\n*  @param    {Boolean}           config.auth        Require signer to be listed in the authentication section of the DID document (for Authentication purposes)\n*  @param    {String}            config.audience    DID of the recipient of the JWT\n*  @param    {String}            config.callbackUrl callback url in JWT\n*  @return   {Promise<Object, Error>}               a promise which resolves with a response object or rejects with an error\n*/\n\n\nvar verifyJWT = exports.verifyJWT = function () {\n  var _ref3 = (0, _asyncToGenerator3.default)(\n  /*#__PURE__*/\n  _regenerator2.default.mark(function _callee2(jwt) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var aud, _decodeJWT, payload, header, signature, data, _ref4, doc, authenticators, issuer, signer, now;\n\n    return _regenerator2.default.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            aud = options.audience ? normalizeDID(options.audience) : undefined;\n            _decodeJWT = decodeJWT(jwt), payload = _decodeJWT.payload, header = _decodeJWT.header, signature = _decodeJWT.signature, data = _decodeJWT.data;\n            _context2.next = 4;\n            return resolveAuthenticator(header.alg, payload.iss, options.auth);\n\n          case 4:\n            _ref4 = _context2.sent;\n            doc = _ref4.doc;\n            authenticators = _ref4.authenticators;\n            issuer = _ref4.issuer;\n            signer = (0, _VerifierAlgorithm2.default)(header.alg)(data, signature, authenticators);\n            now = Math.floor(Date.now() / 1000);\n\n            if (!signer) {\n              _context2.next = 30;\n              break;\n            }\n\n            if (!(payload.iat && payload.iat > now + IAT_SKEW)) {\n              _context2.next = 13;\n              break;\n            }\n\n            throw new Error('JWT not valid yet (issued in the future): iat: ' + payload.iat + ' > now: ' + now);\n\n          case 13:\n            if (!(payload.exp && payload.exp <= now - IAT_SKEW)) {\n              _context2.next = 15;\n              break;\n            }\n\n            throw new Error('JWT has expired: exp: ' + payload.exp + ' < now: ' + now);\n\n          case 15:\n            if (!payload.aud) {\n              _context2.next = 27;\n              break;\n            }\n\n            if (!isDIDOrMNID(payload.aud)) {\n              _context2.next = 23;\n              break;\n            }\n\n            if (aud) {\n              _context2.next = 19;\n              break;\n            }\n\n            throw new Error('JWT audience is required but your app address has not been configured');\n\n          case 19:\n            if (!(aud !== normalizeDID(payload.aud))) {\n              _context2.next = 21;\n              break;\n            }\n\n            throw new Error('JWT audience does not match your DID: aud: ' + payload.aud + ' !== yours: ' + aud);\n\n          case 21:\n            _context2.next = 27;\n            break;\n\n          case 23:\n            if (options.callbackUrl) {\n              _context2.next = 25;\n              break;\n            }\n\n            throw new Error('JWT audience matching your callback url is required but one wasn\\'t passed in');\n\n          case 25:\n            if (!(payload.aud !== options.callbackUrl)) {\n              _context2.next = 27;\n              break;\n            }\n\n            throw new Error('JWT audience does not match the callback url: aud: ' + payload.aud + ' !== url: ' + options.callbackUrl);\n\n          case 27:\n            return _context2.abrupt('return', {\n              payload: payload,\n              doc: doc,\n              issuer: issuer,\n              signer: signer,\n              jwt: jwt\n            });\n\n          case 30:\n          case 'end':\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this);\n  }));\n\n  return function verifyJWT(_x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n* Resolves relevant public keys or other authenticating material used to verify signature from the DID document of provided DID\n*\n*  @example\n*  resolveAuthenticator('ES256K', 'did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX').then(obj => {\n*      const payload = obj.payload\n*      const profile = obj.profile\n*      const jwt = obj.jwt\n*      ...\n*  })\n*\n*  @param    {String}            alg                a JWT algorithm\n*  @param    {String}            did                a Decentralized IDentifier (DID) to lookup\n*  @param    {Boolean}           auth               Restrict public keys to ones specifically listed in the 'authentication' section of DID document\n*  @return   {Promise<Object, Error>}               a promise which resolves with a response object containing an array of authenticators or if non exist rejects with an error\n*/\n\n\nvar resolveAuthenticator = exports.resolveAuthenticator = function () {\n  var _ref5 = (0, _asyncToGenerator3.default)(\n  /*#__PURE__*/\n  _regenerator2.default.mark(function _callee3(alg, mnidOrDid, auth) {\n    var types, issuer, doc, authenticationKeys, authenticators;\n    return _regenerator2.default.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            types = SUPPORTED_PUBLIC_KEY_TYPES[alg];\n\n            if (!(!types || types.length === 0)) {\n              _context3.next = 3;\n              break;\n            }\n\n            throw new Error('No supported signature types for algorithm ' + alg);\n\n          case 3:\n            issuer = normalizeDID(mnidOrDid);\n            _context3.next = 6;\n            return (0, _didResolver2.default)(issuer);\n\n          case 6:\n            doc = _context3.sent;\n\n            if (doc) {\n              _context3.next = 9;\n              break;\n            }\n\n            throw new Error('Unable to resolve DID document for ' + issuer);\n\n          case 9:\n            authenticationKeys = auth ? (doc.authentication || []).map(function (_ref6) {\n              var publicKey = _ref6.publicKey;\n              return publicKey;\n            }) : true;\n            authenticators = (doc.publicKey || []).filter(function (_ref7) {\n              var type = _ref7.type,\n                  id = _ref7.id;\n              return types.find(function (supported) {\n                return supported === type && (!auth || authenticationKeys.indexOf(id) >= 0);\n              });\n            });\n\n            if (!(auth && (!authenticators || authenticators.length === 0))) {\n              _context3.next = 13;\n              break;\n            }\n\n            throw new Error('DID document for ' + issuer + ' does not have public keys suitable for authenticationg user');\n\n          case 13:\n            if (!(!authenticators || authenticators.length === 0)) {\n              _context3.next = 15;\n              break;\n            }\n\n            throw new Error('DID document for ' + issuer + ' does not have public keys for ' + alg);\n\n          case 15:\n            return _context3.abrupt('return', {\n              authenticators: authenticators,\n              issuer: issuer,\n              doc: doc\n            });\n\n          case 16:\n          case 'end':\n            return _context3.stop();\n        }\n      }\n    }, _callee3, this);\n  }));\n\n  return function resolveAuthenticator(_x5, _x6, _x7) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nexports.decodeJWT = decodeJWT;\n\nvar _mnid = require('mnid');\n\nvar _VerifierAlgorithm = require('./VerifierAlgorithm');\n\nvar _VerifierAlgorithm2 = _interopRequireDefault(_VerifierAlgorithm);\n\nvar _SignerAlgorithm = require('./SignerAlgorithm');\n\nvar _SignerAlgorithm2 = _interopRequireDefault(_SignerAlgorithm);\n\nvar _base64url = require('base64url');\n\nvar _base64url2 = _interopRequireDefault(_base64url);\n\nvar _didResolver = require('did-resolver');\n\nvar _didResolver2 = _interopRequireDefault(_didResolver);\n\nvar _uportDidResolver = require('uport-did-resolver');\n\nvar _uportDidResolver2 = _interopRequireDefault(_uportDidResolver);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n(0, _uportDidResolver2.default)();\nvar SUPPORTED_PUBLIC_KEY_TYPES = {\n  ES256K: ['Secp256k1VerificationKey2018', 'Secp256k1SignatureVerificationKey2018', 'EcdsaPublicKeySecp256k1'],\n  'ES256K-R': ['Secp256k1VerificationKey2018', 'Secp256k1SignatureVerificationKey2018', 'EcdsaPublicKeySecp256k1']\n};\nvar JOSE_HEADER = {\n  typ: 'JWT'\n};\nvar defaultAlg = 'ES256K';\n\nfunction encodeSection(data) {\n  return _base64url2.default.encode((0, _stringify2.default)(data));\n}\n\nvar IAT_SKEW = exports.IAT_SKEW = 60;\n/**  @module did-jwt/JWT */\n\nfunction isDIDOrMNID(mnidOrDid) {\n  return mnidOrDid && (mnidOrDid.match(/^did:/) || (0, _mnid.isMNID)(mnidOrDid));\n}\n\nfunction normalizeDID(mnidOrDid) {\n  if (mnidOrDid.match(/^did:/)) return mnidOrDid;\n  if ((0, _mnid.isMNID)(mnidOrDid)) return 'did:uport:' + mnidOrDid;\n  throw new Error('Not a valid DID \\'' + mnidOrDid + '\\'');\n}\n\nfunction decodeJWT(jwt) {\n  if (!jwt) throw new Error('no JWT passed into decodeJWT');\n  var parts = jwt.match(/^([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)$/);\n\n  if (parts) {\n    return {\n      header: JSON.parse(_base64url2.default.decode(parts[1])),\n      payload: JSON.parse(_base64url2.default.decode(parts[2])),\n      signature: parts[3],\n      data: parts[1] + '.' + parts[2]\n    };\n  }\n\n  throw new Error('Incorrect format JWT');\n}\n\nexports.default = {\n  decodeJWT: decodeJWT,\n  createJWT: createJWT,\n  verifyJWT: verifyJWT,\n  resolveAuthenticator: resolveAuthenticator\n};","map":null,"metadata":{},"sourceType":"script"}