{"ast":null,"code":"/**\n * Copyright (c) 2016 Tim Kuijsten\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n'use strict';\n\nvar stream = require('stream');\n\nvar xtend = require('xtend');\n/**\n * Iterate over an IndexedDB object store with a readable stream.\n *\n * @param {IDBDatabase} db - IndexedDB instance\n * @param {String} storeName - name of the object store to iterate over\n * @param {Object} [opts]\n *\n * Options:\n * @param {IDBKeyRange} opts.range - a valid IndexedDB key range\n * @param {IDBCursorDirection} opts.direction - one of \"next\", \"nextunique\",\n *   \"prev\", \"prevunique\"\n * @param {Boolean} opts.snapshot=false - Iterate over a snapshot of the database\n *   by opening only one cursor. This disables any form of back pressure to prevent\n *   cursor timeout issues.\n */\n\n\nfunction idbReadableStream(db, storeName, opts) {\n  if (typeof db !== 'object') throw new TypeError('db must be an object');\n  if (typeof storeName !== 'string') throw new TypeError('storeName must be a string');\n  if (opts == null) opts = {};\n  if (typeof opts !== 'object') throw new TypeError('opts must be an object'); // use transform stream for buffering and back pressure\n\n  var transformer = new stream.Transform(xtend(opts, {\n    objectMode: true,\n    transform: function transform(obj, enc, cb) {\n      cb(null, obj);\n    }\n  }));\n  opts = xtend({\n    snapshot: false\n  }, opts);\n  var lastIteratedKey = null;\n  transformer._cursorsOpened = 0;\n\n  function startCursor() {\n    var lower, upper, lowerOpen, upperOpen;\n    var direction = opts.direction || 'next';\n    var range = opts.range || {};\n    lower = range.lower;\n    upper = range.upper;\n    lowerOpen = !!range.lowerOpen;\n    upperOpen = !!range.upperOpen; // if this is not the first iteration, use lastIteratedKey\n\n    if (lastIteratedKey) {\n      if (direction === 'next') {\n        lowerOpen = true; // exclude the last iterated key itself\n\n        lower = lastIteratedKey;\n      } else {\n        upperOpen = true; // exclude the last iterated key itself\n\n        upper = lastIteratedKey;\n      }\n    }\n\n    var keyRange;\n    if (lower && upper) keyRange = IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen);else if (lower) keyRange = IDBKeyRange.lowerBound(lower, lowerOpen);else if (upper) keyRange = IDBKeyRange.upperBound(upper, upperOpen);\n    var tx = db.transaction(storeName, 'readonly');\n    var store = tx.objectStore(storeName);\n    transformer._cursorsOpened++;\n    var req = store.openCursor(keyRange, opts.direction);\n\n    function proceed(cursor) {\n      try {\n        cursor.continue(); // throws a TransactionInactiveError if the cursor timed out\n      } catch (err) {\n        // either reopen a cursor or propagate the error\n        if (err.name === 'TransactionInactiveError' && !opts.snapshot) startCursor(); // IndexedDB timed out the cursor\n        else transformer.emit('error', err);\n      }\n    }\n\n    req.onsuccess = function () {\n      var cursor = req.result;\n\n      if (cursor) {\n        lastIteratedKey = cursor.key;\n        var go = transformer.write({\n          key: cursor.key,\n          value: cursor.value\n        });\n        if (opts.snapshot || go) proceed(cursor);else transformer.once('drain', function () {\n          proceed(cursor);\n        });\n      } else transformer.end();\n    };\n\n    tx.onabort = function () {\n      transformer.emit('error', tx.error);\n    };\n\n    tx.onerror = function () {\n      transformer.emit('error', tx.error);\n    };\n  }\n\n  startCursor();\n  return transformer;\n}\n\nmodule.exports = idbReadableStream;","map":null,"metadata":{},"sourceType":"script"}