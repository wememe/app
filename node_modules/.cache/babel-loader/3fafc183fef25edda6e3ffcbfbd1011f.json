{"ast":null,"code":"'use strict';\n\nvar setImmediate = require('async/setImmediate');\n\nvar multicodec = require('./multicodec');\n\nvar EE = require('events').EventEmitter;\n\nvar multiaddr = require('multiaddr');\n\nvar mafmt = require('mafmt');\n\nvar Stop = require('./circuit/stop');\n\nvar Hop = require('./circuit/hop');\n\nvar proto = require('./protocol');\n\nvar utilsFactory = require('./circuit/utils');\n\nvar StreamHandler = require('./circuit/stream-handler');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:circuit:listener');\nlog.err = debug('libp2p:circuit:error:listener');\n\nmodule.exports = function (swarm, options, connHandler) {\n  var listener = new EE();\n  var utils = utilsFactory(swarm);\n  listener.stopHandler = new Stop(swarm);\n  listener.hopHandler = new Hop(swarm, options.hop);\n  /**\n   * Add swarm handler and listen for incoming connections\n   *\n   * @param {Multiaddr} ma\n   * @param {Function} callback\n   * @return {void}\n   */\n\n  listener.listen = function (ma, callback) {\n    callback = callback || function () {};\n\n    swarm.handle(multicodec.relay, function (_, conn) {\n      var sh = new StreamHandler(conn);\n      sh.read(function (err, msg) {\n        if (err) {\n          log.err(err);\n          return;\n        }\n\n        var request = null;\n\n        try {\n          request = proto.CircuitRelay.decode(msg);\n        } catch (err) {\n          return utils.writeResponse(sh, proto.CircuitRelay.Status.MALFORMED_MESSAGE);\n        }\n\n        switch (request.type) {\n          case proto.CircuitRelay.Type.CAN_HOP:\n          case proto.CircuitRelay.Type.HOP:\n            {\n              return listener.hopHandler.handle(request, sh);\n            }\n\n          case proto.CircuitRelay.Type.STOP:\n            {\n              return listener.stopHandler.handle(request, sh, connHandler);\n            }\n\n          default:\n            {\n              return utils.writeResponse(sh, proto.CircuitRelay.Status.INVALID_MSG_TYPE);\n            }\n        }\n      });\n    });\n    setImmediate(function () {\n      return listener.emit('listen');\n    });\n    callback();\n  };\n  /**\n   * Remove swarm listener\n   *\n   * @param {Function} cb\n   * @return {void}\n   */\n\n\n  listener.close = function (cb) {\n    swarm.unhandle(multicodec.relay);\n    setImmediate(function () {\n      return listener.emit('close');\n    });\n    cb();\n  };\n  /**\n   * Get fixed up multiaddrs\n   *\n   * NOTE: This method will grab the peers multiaddrs and expand them such that:\n   *\n   * a) If it's an existing /p2p-circuit address for a specific relay i.e.\n   *    `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit` this method will expand the\n   *    address to `/ip4/0.0.0.0/tcp/0/ipfs/QmRelay/p2p-circuit/ipfs/QmPeer` where\n   *    `QmPeer` is this peers id\n   * b) If it's not a /p2p-circuit address, it will encapsulate the address as a /p2p-circuit\n   *    addr, such when dialing over a relay with this address, it will create the circuit using\n   *    the encapsulated transport address. This is useful when for example, a peer should only\n   *    be dialed over TCP rather than any other transport\n   *\n   * @param {Function} callback\n   * @return {void}\n   */\n\n\n  listener.getAddrs = function (callback) {\n    var addrs = swarm._peerInfo.multiaddrs.toArray(); // get all the explicit relay addrs excluding self\n\n\n    var p2pAddrs = addrs.filter(function (addr) {\n      return mafmt.Circuit.matches(addr) && !addr.toString().includes(swarm._peerInfo.id.toB58String());\n    }); // use the explicit relays instead of any relay\n\n    if (p2pAddrs.length) {\n      addrs = p2pAddrs;\n    }\n\n    var listenAddrs = [];\n    addrs.forEach(function (addr) {\n      var peerMa = \"/p2p-circuit/ipfs/\".concat(swarm._peerInfo.id.toB58String());\n\n      if (addr.toString() === peerMa) {\n        listenAddrs.push(multiaddr(peerMa));\n        return;\n      }\n\n      if (!mafmt.Circuit.matches(addr)) {\n        if (addr.getPeerId()) {\n          // by default we're reachable over any relay\n          listenAddrs.push(multiaddr(\"/p2p-circuit\").encapsulate(addr));\n        } else {\n          var ma = \"\".concat(addr, \"/ipfs/\").concat(swarm._peerInfo.id.toB58String());\n          listenAddrs.push(multiaddr(\"/p2p-circuit\").encapsulate(ma));\n        }\n      } else {\n        listenAddrs.push(addr.encapsulate(\"/ipfs/\".concat(swarm._peerInfo.id.toB58String())));\n      }\n    });\n    callback(null, listenAddrs);\n  };\n\n  return listener;\n};","map":null,"metadata":{},"sourceType":"script"}