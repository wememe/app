{"ast":null,"code":"'use strict';\n/**\n *  SigningKey\n *\n *\n */\n\nvar secp256k1 = new (require('elliptic').ec)('secp256k1');\n\nvar utils = function () {\n  var convert = require('../utils/convert');\n\n  return {\n    defineProperty: require('../utils/properties').defineProperty,\n    arrayify: convert.arrayify,\n    hexlify: convert.hexlify,\n    padZeros: convert.padZeros,\n    getAddress: require('../utils/address').getAddress,\n    keccak256: require('../utils/keccak256')\n  };\n}();\n\nvar errors = require('../utils/errors');\n\nfunction SigningKey(privateKey) {\n  errors.checkNew(this, SigningKey);\n\n  try {\n    privateKey = utils.arrayify(privateKey);\n\n    if (privateKey.length !== 32) {\n      errors.throwError('exactly 32 bytes required', errors.INVALID_ARGUMENT, {\n        value: privateKey\n      });\n    }\n  } catch (error) {\n    var params = {\n      arg: 'privateKey',\n      reason: error.reason,\n      value: '[REDACTED]'\n    };\n\n    if (error.value) {\n      if (typeof error.value.length === 'number') {\n        params.length = error.value.length;\n      }\n\n      params.type = typeof error.value;\n    }\n\n    errors.throwError('invalid private key', error.code, params);\n  }\n\n  utils.defineProperty(this, 'privateKey', utils.hexlify(privateKey));\n  var keyPair = secp256k1.keyFromPrivate(privateKey);\n  utils.defineProperty(this, 'publicKey', '0x' + keyPair.getPublic(true, 'hex'));\n  var address = SigningKey.publicKeyToAddress('0x' + keyPair.getPublic(false, 'hex'));\n  utils.defineProperty(this, 'address', address);\n  utils.defineProperty(this, 'signDigest', function (digest) {\n    var signature = keyPair.sign(utils.arrayify(digest), {\n      canonical: true\n    });\n    var r = '0x' + signature.r.toString(16);\n    var s = '0x' + signature.s.toString(16);\n    return {\n      recoveryParam: signature.recoveryParam,\n      r: utils.hexlify(utils.padZeros(r, 32)),\n      s: utils.hexlify(utils.padZeros(s, 32))\n    };\n  });\n}\n\nutils.defineProperty(SigningKey, 'recover', function (digest, r, s, recoveryParam) {\n  var signature = {\n    r: utils.arrayify(r),\n    s: utils.arrayify(s)\n  };\n  var publicKey = secp256k1.recoverPubKey(utils.arrayify(digest), signature, recoveryParam);\n  return SigningKey.publicKeyToAddress('0x' + publicKey.encode('hex', false));\n});\nutils.defineProperty(SigningKey, 'getPublicKey', function (value, compressed) {\n  value = utils.arrayify(value);\n  compressed = !!compressed;\n\n  if (value.length === 32) {\n    var keyPair = secp256k1.keyFromPrivate(value);\n    return '0x' + keyPair.getPublic(compressed, 'hex');\n  } else if (value.length === 33) {\n    var keyPair = secp256k1.keyFromPublic(value);\n    return '0x' + keyPair.getPublic(compressed, 'hex');\n  } else if (value.length === 65) {\n    var keyPair = secp256k1.keyFromPublic(value);\n    return '0x' + keyPair.getPublic(compressed, 'hex');\n  }\n\n  throw new Error('invalid value');\n});\nutils.defineProperty(SigningKey, 'publicKeyToAddress', function (publicKey) {\n  publicKey = '0x' + SigningKey.getPublicKey(publicKey, false).slice(4);\n  return utils.getAddress('0x' + utils.keccak256(publicKey).substring(26));\n});\nmodule.exports = SigningKey;","map":null,"metadata":{},"sourceType":"script"}