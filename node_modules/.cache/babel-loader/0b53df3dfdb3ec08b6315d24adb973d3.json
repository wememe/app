{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar asyncMap = require('async/map');\n/**\n * BlockService is a hybrid block datastore. It stores data in a local\n * datastore and may retrieve data from a remote Exchange.\n * It uses an internal `datastore.Datastore` instance to store values.\n */\n\n\nvar BlockService =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Create a new BlockService\n   *\n   * @param {IPFSRepo} ipfsRepo\n   */\n  function BlockService(ipfsRepo) {\n    _classCallCheck(this, BlockService);\n\n    this._repo = ipfsRepo;\n    this._bitswap = null;\n  }\n  /**\n   * Add a bitswap instance that communicates with the\n   * network to retreive blocks that are not in the local store.\n   *\n   * If the node is online all requests for blocks first\n   * check locally and afterwards ask the network for the blocks.\n   *\n   * @param {Bitswap} bitswap\n   * @returns {void}\n   */\n\n\n  _createClass(BlockService, [{\n    key: \"setExchange\",\n    value: function setExchange(bitswap) {\n      this._bitswap = bitswap;\n    }\n    /**\n     * Go offline, i.e. drop the reference to bitswap.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unsetExchange\",\n    value: function unsetExchange() {\n      this._bitswap = null;\n    }\n    /**\n     * Is the blockservice online, i.e. is bitswap present.\n     *\n     * @returns {bool}\n     */\n\n  }, {\n    key: \"hasExchange\",\n    value: function hasExchange() {\n      return this._bitswap != null;\n    }\n    /**\n     * Put a block to the underlying datastore.\n     *\n     * @param {Block} block\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(block, callback) {\n      if (this.hasExchange()) {\n        this._bitswap.put(block, callback);\n      } else {\n        this._repo.blocks.put(block, callback);\n      }\n    }\n    /**\n     * Put a multiple blocks to the underlying datastore.\n     *\n     * @param {Array<Block>} blocks\n     * @param {function(Error)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"putMany\",\n    value: function putMany(blocks, callback) {\n      if (this.hasExchange()) {\n        this._bitswap.putMany(blocks, callback);\n      } else {\n        this._repo.blocks.putMany(blocks, callback);\n      }\n    }\n    /**\n     * Get a block by cid.\n     *\n     * @param {CID} cid\n     * @param {function(Error, Block)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(cid, callback) {\n      if (this.hasExchange()) {\n        this._bitswap.get(cid, callback);\n      } else {\n        this._repo.blocks.get(cid, callback);\n      }\n    }\n    /**\n     * Get multiple blocks back from an array of cids.\n     *\n     * @param {Array<CID>} cids\n     * @param {function(Error, Block)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"getMany\",\n    value: function getMany(cids, callback) {\n      var _this = this;\n\n      if (!Array.isArray(cids)) {\n        callback(new Error('first arg must be an array of cids'));\n      } else if (this.hasExchange()) {\n        this._bitswap.getMany(cids, callback);\n      } else {\n        asyncMap(cids, function (cid, cb) {\n          return _this._repo.blocks.get(cid, cb);\n        }, callback);\n      }\n    }\n    /**\n     * Delete a block from the blockstore.\n     *\n     * @param {CID} cid\n     * @param {function(Error)} callback\n     * @return {void}\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(cid, callback) {\n      this._repo.blocks.delete(cid, callback);\n    }\n  }]);\n\n  return BlockService;\n}();\n\nmodule.exports = BlockService;","map":null,"metadata":{},"sourceType":"script"}