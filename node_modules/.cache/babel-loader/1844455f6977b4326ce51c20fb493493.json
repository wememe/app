{"ast":null,"code":"/* @flow */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar each = require('async/each');\n\nvar many = require('pull-many');\n\nvar pull = require('pull-stream');\n\nvar Key = require('interface-datastore').Key;\n\nvar Errors = require('interface-datastore').Errors;\n\nvar utils = require('interface-datastore').utils;\n\nvar asyncFilter = utils.asyncFilter;\nvar asyncSort = utils.asyncSort;\nvar replaceStartWith = utils.replaceStartWith;\n\nvar Keytransform = require('./keytransform');\n/* ::\nimport type {Datastore, Callback, Batch, Query, QueryResult} from 'interface-datastore'\n\ntype Mount<Value> = {\n  prefix: Key,\n  datastore: Datastore<Value>\n}\n*/\n\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixs.\n */\n\n\nvar MountDatastore\n/* :: <Value> */\n=\n/*#__PURE__*/\nfunction () {\n  /* :: mounts: Array<Mount<Value>> */\n  function MountDatastore(mounts\n  /* : Array<Mount<Value>> */\n  ) {\n    _classCallCheck(this, MountDatastore);\n\n    this.mounts = mounts.slice();\n  }\n\n  _createClass(MountDatastore, [{\n    key: \"open\",\n    value: function open(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      each(this.mounts, function (m, cb) {\n        m.datastore.open(cb);\n      }, callback);\n    }\n    /**\n     * Lookup the matching datastore for the given key.\n     *\n     * @private\n     * @param {Key} key\n     * @returns {{Datastore, Key, Key}}\n     */\n\n  }, {\n    key: \"_lookup\",\n    value: function _lookup(key\n    /* : Key */\n    )\n    /* : ?{datastore: Datastore<Value>, mountpoint: Key, rest: Key} */\n    {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.mounts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var mount = _step.value;\n\n          if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n            var s = replaceStartWith(key.toString(), mount.prefix.toString());\n            return {\n              datastore: mount.datastore,\n              mountpoint: mount.prefix,\n              rest: new Key(s)\n            };\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"put\",\n    value: function put(key\n    /* : Key */\n    , value\n    /* : Value */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        return callback(Errors.dbWriteFailedError(new Error('No datastore mounted for this key')));\n      }\n\n      match.datastore.put(match.rest, value, callback);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key\n    /* : Key */\n    , callback\n    /* : Callback<Value> */\n    )\n    /* : void */\n    {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        return callback(Errors.notFoundError(new Error('No datastore mounted for this key')));\n      }\n\n      match.datastore.get(match.rest, callback);\n    }\n  }, {\n    key: \"has\",\n    value: function has(key\n    /* : Key */\n    , callback\n    /* : Callback<bool> */\n    )\n    /* : void */\n    {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        callback(null, false);\n        return;\n      }\n\n      match.datastore.has(match.rest, callback);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key\n    /* : Key */\n    , callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        return callback(Errors.dbDeleteFailedError(new Error('No datastore mounted for this key')));\n      }\n\n      match.datastore.delete(match.rest, callback);\n    }\n  }, {\n    key: \"close\",\n    value: function close(callback\n    /* : Callback<void> */\n    )\n    /* : void */\n    {\n      each(this.mounts, function (m, cb) {\n        m.datastore.close(cb);\n      }, callback);\n    }\n  }, {\n    key: \"batch\",\n    value: function batch()\n    /* : Batch<Value> */\n    {\n      var _this = this;\n\n      var batchMounts = {};\n\n      var lookup = function lookup(key\n      /* : Key */\n      )\n      /* : {batch: Batch<Value>, rest: Key} */\n      {\n        var match = _this._lookup(key);\n\n        if (match == null) {\n          throw new Error('No datastore mounted for this key');\n        }\n\n        var m = match.mountpoint.toString();\n\n        if (batchMounts[m] == null) {\n          batchMounts[m] = match.datastore.batch();\n        }\n\n        return {\n          batch: batchMounts[m],\n          rest: match.rest\n        };\n      };\n\n      return {\n        put: function put(key\n        /* : Key */\n        , value\n        /* : Value */\n        )\n        /* : void */\n        {\n          var match = lookup(key);\n          match.batch.put(match.rest, value);\n        },\n        delete: function _delete(key\n        /* : Key */\n        )\n        /* : void */\n        {\n          var match = lookup(key);\n          match.batch.delete(match.rest);\n        },\n        commit: function commit(callback\n        /* : Callback<void> */\n        )\n        /* : void */\n        {\n          each(Object.keys(batchMounts), function (p, cb) {\n            batchMounts[p].commit(cb);\n          }, callback);\n        }\n      };\n    }\n  }, {\n    key: \"query\",\n    value: function query(q\n    /* : Query<Value> */\n    )\n    /* : QueryResult<Value> */\n    {\n      var qs = this.mounts.map(function (m) {\n        var ks = new Keytransform(m.datastore, {\n          convert: function convert(key\n          /* : Key */\n          )\n          /* : Key */\n          {\n            throw new Error('should never be called');\n          },\n          invert: function invert(key\n          /* : Key */\n          )\n          /* : Key */\n          {\n            return m.prefix.child(key);\n          }\n        });\n        var prefix;\n\n        if (q.prefix != null) {\n          prefix = replaceStartWith(q.prefix, m.prefix.toString());\n        }\n\n        return ks.query({\n          prefix: prefix,\n          filters: q.filters,\n          keysOnly: q.keysOnly\n        });\n      });\n      var tasks = [many(qs)];\n\n      if (q.filters != null) {\n        tasks = tasks.concat(q.filters.map(function (f) {\n          return asyncFilter(f);\n        }));\n      }\n\n      if (q.orders != null) {\n        tasks = tasks.concat(q.orders.map(function (o) {\n          return asyncSort(o);\n        }));\n      }\n\n      if (q.offset != null) {\n        var i = 0;\n        tasks.push(pull.filter(function () {\n          return i++ >= q.offset;\n        }));\n      }\n\n      if (q.limit != null) {\n        tasks.push(pull.take(q.limit));\n      }\n\n      return pull.apply(null, tasks);\n    }\n  }]);\n\n  return MountDatastore;\n}();\n\nmodule.exports = MountDatastore;","map":null,"metadata":{},"sourceType":"script"}