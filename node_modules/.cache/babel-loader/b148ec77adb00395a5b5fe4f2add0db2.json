{"ast":null,"code":"'use strict'; // See: https://github.com/ethereum/wiki/wiki/JSON-RPC\n\nvar Provider = require('./provider.js');\n\nvar utils = function () {\n  var convert = require('../utils/convert');\n\n  return {\n    defineProperty: require('../utils/properties').defineProperty,\n    hexlify: convert.hexlify,\n    isHexString: convert.isHexString,\n    hexStripZeros: convert.hexStripZeros,\n    toUtf8Bytes: require('../utils/utf8').toUtf8Bytes,\n    getAddress: require('../utils/address').getAddress\n  };\n}();\n\nvar errors = require('../utils/errors');\n\nfunction timer(timeout) {\n  return new Promise(function (resolve) {\n    setTimeout(function () {\n      resolve();\n    }, timeout);\n  });\n}\n\nfunction getResult(payload) {\n  if (payload.error) {\n    var error = new Error(payload.error.message);\n    error.code = payload.error.code;\n    error.data = payload.error.data;\n    throw error;\n  }\n\n  return payload.result;\n}\n\nfunction getTransaction(transaction) {\n  var result = {};\n\n  for (var key in transaction) {\n    result[key] = utils.hexlify(transaction[key]);\n  } // Some nodes (INFURA ropsten; INFURA mainnet is fine) don't like extra zeros.\n\n\n  ['gasLimit', 'gasPrice', 'nonce', 'value'].forEach(function (key) {\n    if (!result[key]) {\n      return;\n    }\n\n    result[key] = utils.hexStripZeros(result[key]);\n  }); // Transform \"gasLimit\" to \"gas\"\n\n  if (result.gasLimit != null && result.gas == null) {\n    result.gas = result.gasLimit;\n    delete result.gasLimit;\n  }\n\n  return result;\n}\n\nfunction getLowerCase(value) {\n  if (value) {\n    return value.toLowerCase();\n  }\n\n  return value;\n}\n\nfunction JsonRpcSigner(provider, address) {\n  errors.checkNew(this, JsonRpcSigner);\n  utils.defineProperty(this, 'provider', provider); // Statically attach to a given address\n\n  if (address) {\n    utils.defineProperty(this, 'address', address);\n    utils.defineProperty(this, '_syncAddress', true);\n  } else {\n    Object.defineProperty(this, 'address', {\n      enumerable: true,\n      get: function get() {\n        errors.throwError('no sync sync address available; use getAddress', errors.UNSUPPORTED_OPERATION, {\n          operation: 'address'\n        });\n      }\n    });\n    utils.defineProperty(this, '_syncAddress', false);\n  }\n}\n\nutils.defineProperty(JsonRpcSigner.prototype, 'getAddress', function () {\n  if (this._syncAddress) {\n    return Promise.resolve(this.address);\n  }\n\n  return this.provider.send('eth_accounts', []).then(function (accounts) {\n    if (accounts.length === 0) {\n      errors.throwError('no accounts', errors.UNSUPPORTED_OPERATION, {\n        operation: 'getAddress'\n      });\n    }\n\n    return utils.getAddress(accounts[0]);\n  });\n});\nutils.defineProperty(JsonRpcSigner.prototype, 'getBalance', function (blockTag) {\n  var provider = this.provider;\n  return this.getAddress().then(function (address) {\n    return provider.getBalance(address, blockTag);\n  });\n});\nutils.defineProperty(JsonRpcSigner.prototype, 'getTransactionCount', function (blockTag) {\n  var provider = this.provider;\n  return this.getAddress().then(function (address) {\n    return provider.getTransactionCount(address, blockTag);\n  });\n});\nutils.defineProperty(JsonRpcSigner.prototype, 'sendTransaction', function (transaction) {\n  var provider = this.provider;\n  transaction = getTransaction(transaction);\n  return this.getAddress().then(function (address) {\n    transaction.from = address.toLowerCase();\n    return provider.send('eth_sendTransaction', [transaction]).then(function (hash) {\n      return new Promise(function (resolve, reject) {\n        function check() {\n          provider.getTransaction(hash).then(function (transaction) {\n            if (!transaction) {\n              setTimeout(check, 1000);\n              return null;\n            }\n\n            transaction.wait = function () {\n              return provider.waitForTransaction(hash);\n            };\n\n            resolve(transaction);\n            return null;\n          }).catch(function (error) {\n            setTimeout(check, 1000);\n            return null;\n          });\n        }\n\n        check();\n      });\n    });\n  });\n});\nutils.defineProperty(JsonRpcSigner.prototype, 'signMessage', function (message) {\n  var provider = this.provider;\n  var data = typeof message === 'string' ? utils.toUtf8Bytes(message) : message;\n  return this.getAddress().then(function (address) {\n    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    return provider.send('eth_sign', [address.toLowerCase(), utils.hexlify(data)]);\n  });\n});\nutils.defineProperty(JsonRpcSigner.prototype, 'unlock', function (password) {\n  var provider = this.provider;\n  return this.getAddress().then(function (address) {\n    return provider.send('personal_unlockAccount', [address.toLowerCase(), password, null]);\n  });\n});\n\nfunction JsonRpcProvider(url, network) {\n  errors.checkNew(this, JsonRpcProvider);\n\n  if (arguments.length == 1) {\n    if (typeof url === 'string') {\n      try {\n        network = Provider.getNetwork(url);\n        url = null;\n      } catch (error) {}\n    } else if (url && url.url == null) {\n      network = url;\n      url = null;\n    }\n  }\n\n  Provider.call(this, network);\n\n  if (!url) {\n    url = 'http://localhost:8545';\n  }\n\n  utils.defineProperty(this, 'url', url);\n}\n\nProvider.inherits(JsonRpcProvider);\nutils.defineProperty(JsonRpcProvider.prototype, 'getSigner', function (address) {\n  return new JsonRpcSigner(this, address);\n});\nutils.defineProperty(JsonRpcProvider.prototype, 'listAccounts', function () {\n  return this.send('eth_accounts', []).then(function (accounts) {\n    accounts.forEach(function (address, index) {\n      accounts[index] = utils.getAddress(address);\n    });\n    return accounts;\n  });\n});\nutils.defineProperty(JsonRpcProvider.prototype, 'send', function (method, params) {\n  var request = {\n    method: method,\n    params: params,\n    id: 42,\n    jsonrpc: \"2.0\"\n  };\n  return Provider.fetchJSON(this.url, JSON.stringify(request), getResult);\n});\nutils.defineProperty(JsonRpcProvider.prototype, 'perform', function (method, params) {\n  switch (method) {\n    case 'getBlockNumber':\n      return this.send('eth_blockNumber', []);\n\n    case 'getGasPrice':\n      return this.send('eth_gasPrice', []);\n\n    case 'getBalance':\n      return this.send('eth_getBalance', [getLowerCase(params.address), params.blockTag]);\n\n    case 'getTransactionCount':\n      return this.send('eth_getTransactionCount', [getLowerCase(params.address), params.blockTag]);\n\n    case 'getCode':\n      return this.send('eth_getCode', [getLowerCase(params.address), params.blockTag]);\n\n    case 'getStorageAt':\n      return this.send('eth_getStorageAt', [getLowerCase(params.address), params.position, params.blockTag]);\n\n    case 'sendTransaction':\n      return this.send('eth_sendRawTransaction', [params.signedTransaction]);\n\n    case 'getBlock':\n      if (params.blockTag) {\n        return this.send('eth_getBlockByNumber', [params.blockTag, false]);\n      } else if (params.blockHash) {\n        return this.send('eth_getBlockByHash', [params.blockHash, false]);\n      }\n\n      return Promise.reject(new Error('invalid block tag or block hash'));\n\n    case 'getTransaction':\n      return this.send('eth_getTransactionByHash', [params.transactionHash]);\n\n    case 'getTransactionReceipt':\n      return this.send('eth_getTransactionReceipt', [params.transactionHash]);\n\n    case 'call':\n      return this.send('eth_call', [getTransaction(params.transaction), 'latest']);\n\n    case 'estimateGas':\n      return this.send('eth_estimateGas', [getTransaction(params.transaction)]);\n\n    case 'getLogs':\n      if (params.filter && params.filter.address != null) {\n        params.filter.address = getLowerCase(params.filter.address);\n      }\n\n      return this.send('eth_getLogs', [params.filter]);\n\n    default:\n      break;\n  }\n\n  return Promise.reject(new Error('not implemented - ' + method));\n});\nutils.defineProperty(JsonRpcProvider.prototype, '_startPending', function () {\n  if (this._pendingFilter != null) {\n    return;\n  }\n\n  var self = this;\n  var pendingFilter = this.send('eth_newPendingTransactionFilter', []);\n  this._pendingFilter = pendingFilter;\n  pendingFilter.then(function (filterId) {\n    function poll() {\n      self.send('eth_getFilterChanges', [filterId]).then(function (hashes) {\n        if (self._pendingFilter != pendingFilter) {\n          return;\n        }\n\n        var seq = Promise.resolve();\n        hashes.forEach(function (hash) {\n          self._emitted['t:' + hash.toLowerCase()] = 'pending';\n          seq = seq.then(function () {\n            return self.getTransaction(hash).then(function (tx) {\n              self.emit('pending', tx);\n              return null;\n            });\n          });\n        });\n        return seq.then(function () {\n          return timer(1000);\n        });\n      }).then(function () {\n        if (self._pendingFilter != pendingFilter) {\n          self.send('eth_uninstallFilter', [filterIf]);\n          return null;\n        }\n\n        setTimeout(function () {\n          poll();\n        }, 0);\n        return null;\n      }).catch(function (error) {});\n    }\n\n    poll();\n    return filterId;\n  }).catch(function (error) {});\n});\nutils.defineProperty(JsonRpcProvider.prototype, '_stopPending', function () {\n  this._pendingFilter = null;\n});\nutils.defineProperty(JsonRpcProvider, '_hexlifyTransaction', function (transaction) {\n  return getTransaction(transaction);\n});\nmodule.exports = JsonRpcProvider;","map":null,"metadata":{},"sourceType":"script"}