{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/kenzo/Desktop/3box-dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar EventEmitter = require('events');\n\nvar pull = require('pull-stream/pull');\n\nvar empty = require('pull-stream/sources/empty');\n\nvar asyncEach = require('async/each');\n\nvar debug = require('debug');\n\nvar Peer = require('./peer');\n\nvar setImmediate = require('async/setImmediate');\n/**\n * FloodSub (aka dumbsub is an implementation of pubsub focused on\n * delivering an API for Publish/Subscribe, but with no CastTree Forming\n * (it just floods the network).\n */\n\n\nvar BaseProtocol =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(BaseProtocol, _EventEmitter);\n\n  /**\n   * @param {String} debugName\n   * @param {String} multicodec\n   * @param {Object} libp2p\n   * @constructor\n   */\n  function BaseProtocol(debugName, multicodec, libp2p) {\n    var _this;\n\n    _classCallCheck(this, BaseProtocol);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseProtocol).call(this));\n    _this.log = debug(debugName);\n    _this.log.err = debug(\"\".concat(debugName, \":error\"));\n    _this.multicodec = multicodec;\n    _this.libp2p = libp2p;\n    _this.started = false;\n    /**\n     * Map of peers.\n     *\n     * @type {Map<string, Peer>}\n     */\n\n    _this.peers = new Map(); // Dials that are currently in progress\n\n    _this._dials = new Set();\n    _this._onConnection = _this._onConnection.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._dialPeer = _this._dialPeer.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  _createClass(BaseProtocol, [{\n    key: \"_addPeer\",\n    value: function _addPeer(peer) {\n      var _this2 = this;\n\n      var id = peer.info.id.toB58String();\n      /*\n        Always use an existing peer.\n         What is happening here is: \"If the other peer has already dialed to me, we already have\n        an establish link between the two, what might be missing is a\n        Connection specifically between me and that Peer\"\n       */\n\n      var existing = this.peers.get(id);\n\n      if (!existing) {\n        this.log('new peer', id);\n        this.peers.set(id, peer);\n        existing = peer;\n        peer.once('close', function () {\n          return _this2._removePeer(peer);\n        });\n      }\n\n      ++existing._references;\n      return existing;\n    }\n  }, {\n    key: \"_removePeer\",\n    value: function _removePeer(peer) {\n      var id = peer.info.id.toB58String();\n      this.log('remove', id, peer._references); // Only delete when no one else is referencing this peer.\n\n      if (--peer._references === 0) {\n        this.log('delete peer', id);\n        this.peers.delete(id);\n      }\n\n      return peer;\n    }\n  }, {\n    key: \"_dialPeer\",\n    value: function _dialPeer(peerInfo, callback) {\n      var _this3 = this;\n\n      callback = callback || function noop() {};\n\n      var idB58Str = peerInfo.id.toB58String(); // If already have a PubSub conn, ignore\n\n      var peer = this.peers.get(idB58Str);\n\n      if (peer && peer.isConnected) {\n        return setImmediate(function () {\n          return callback();\n        });\n      } // If already dialing this peer, ignore\n\n\n      if (this._dials.has(idB58Str)) {\n        this.log('already dialing %s, ignoring dial attempt', idB58Str);\n        return setImmediate(function () {\n          return callback();\n        });\n      }\n\n      this._dials.add(idB58Str);\n\n      this.log('dialing %s', idB58Str);\n      this.libp2p.dialProtocol(peerInfo, this.multicodec, function (err, conn) {\n        _this3.log('dial to %s complete', idB58Str); // If the dial is not in the set, it means that floodsub has been\n        // stopped\n\n\n        var floodsubStopped = !_this3._dials.has(idB58Str);\n\n        _this3._dials.delete(idB58Str);\n\n        if (err) {\n          _this3.log.err(err);\n\n          return callback();\n        } // Floodsub has been stopped, so we should just bail out\n\n\n        if (floodsubStopped) {\n          _this3.log('floodsub was stopped, not processing dial to %s', idB58Str);\n\n          return callback();\n        }\n\n        _this3._onDial(peerInfo, conn, callback);\n      });\n    }\n  }, {\n    key: \"_onDial\",\n    value: function _onDial(peerInfo, conn, callback) {\n      var idB58Str = peerInfo.id.toB58String();\n      this.log('connected', idB58Str);\n\n      var peer = this._addPeer(new Peer(peerInfo));\n\n      peer.attachConnection(conn);\n      setImmediate(function () {\n        return callback();\n      });\n    }\n  }, {\n    key: \"_onConnection\",\n    value: function _onConnection(protocol, conn) {\n      var _this4 = this;\n\n      conn.getPeerInfo(function (err, peerInfo) {\n        if (err) {\n          _this4.log.err('Failed to identify incomming conn', err);\n\n          return pull(empty(), conn);\n        }\n\n        var idB58Str = peerInfo.id.toB58String();\n\n        var peer = _this4._addPeer(new Peer(peerInfo));\n\n        _this4._processConnection(idB58Str, conn, peer);\n      });\n    }\n  }, {\n    key: \"_processConnection\",\n    value: function _processConnection(idB58Str, conn, peer) {\n      throw new Error('_processConnection must be implemented by the subclass');\n    }\n  }, {\n    key: \"_onConnectionEnd\",\n    value: function _onConnectionEnd(idB58Str, peer, err) {\n      // socket hang up, means the one side canceled\n      if (err && err.message !== 'socket hang up') {\n        this.log.err(err);\n      }\n\n      this.log('connection ended', idB58Str, err ? err.message : '');\n\n      this._removePeer(peer);\n    }\n    /**\n     * Mounts the floodsub protocol onto the libp2p node and sends our\n     * subscriptions to every peer conneceted\n     *\n     * @param {Function} callback\n     * @returns {undefined}\n     *\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(callback) {\n      var _this5 = this;\n\n      if (this.started) {\n        return setImmediate(function () {\n          return callback(new Error('already started'));\n        });\n      }\n\n      this.log('starting');\n      this.libp2p.handle(this.multicodec, this._onConnection); // Speed up any new peer that comes in my way\n\n      this.libp2p.on('peer:connect', this._dialPeer); // Dial already connected peers\n\n      var peerInfos = Object.values(this.libp2p.peerBook.getAll());\n      asyncEach(peerInfos, function (peer, cb) {\n        return _this5._dialPeer(peer, cb);\n      }, function (err) {\n        setImmediate(function () {\n          _this5.log('started');\n\n          _this5.started = true;\n          callback(err);\n        });\n      });\n    }\n    /**\n     * Unmounts the floodsub protocol and shuts down every connection\n     *\n     * @param {Function} callback\n     * @returns {undefined}\n     *\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(callback) {\n      var _this6 = this;\n\n      if (!this.started) {\n        return setImmediate(function () {\n          return callback(new Error('not started yet'));\n        });\n      }\n\n      this.libp2p.unhandle(this.multicodec);\n      this.libp2p.removeListener('peer:connect', this._dialPeer); // Prevent any dials that are in flight from being processed\n\n      this._dials = new Set();\n      this.log('stopping');\n      asyncEach(this.peers.values(), function (peer, cb) {\n        return peer.close(cb);\n      }, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this6.log('stopped');\n\n        _this6.peers = new Map();\n        _this6.started = false;\n        callback();\n      });\n    }\n  }]);\n\n  return BaseProtocol;\n}(EventEmitter);\n\nmodule.exports = BaseProtocol;","map":null,"metadata":{},"sourceType":"script"}