{"ast":null,"code":"'use strict';\n\nvar each = require('async/each');\n\nvar waterfall = require('async/waterfall');\n\nvar asyncify = require('async/asyncify');\n\nvar rlp = require('rlp');\n\nvar EthTrieNode = require('merkle-patricia-tree/trieNode');\n\nvar cidFromHash = require('./cidFromHash'); // const createBaseTrieResolver = require('./createBaseTrieResolver.js')\n\n\nvar createResolver = require('./createResolver');\n\nvar isExternalLink = require('./isExternalLink');\n\nvar createUtil = require('./createUtil');\n\nvar createIsLink = require('./createIsLink');\n\nvar cidFromEthObj = require('./cidFromEthObj');\n\nmodule.exports = createTrieResolver;\n\nfunction createTrieResolver(multicodec, leafResolver) {\n  var baseTrie = createResolver(multicodec, EthTrieNode, mapFromEthObj);\n  baseTrie.util.deserialize = asyncify(function (serialized) {\n    var rawNode = rlp.decode(serialized);\n    var trieNode = new EthTrieNode(rawNode);\n    return trieNode;\n  });\n  return baseTrie; // create map using both baseTrie and leafResolver\n\n  function mapFromEthObj(trieNode, options, callback) {\n    // expand from merkle-patricia-tree using leafResolver\n    mapFromBaseTrie(trieNode, options, function (err, basePaths) {\n      if (err) return callback(err);\n      if (!leafResolver) return callback(null, basePaths); // expand children\n\n      var paths = basePaths.slice();\n      var leafTerminatingPaths = basePaths.filter(function (child) {\n        return Buffer.isBuffer(child.value);\n      });\n      each(leafTerminatingPaths, function (child, cb) {\n        return waterfall([function (cb) {\n          return leafResolver.util.deserialize(child.value, cb);\n        }, function (ethObj, cb) {\n          return leafResolver.resolver._mapFromEthObject(ethObj, options, cb);\n        }], function (err, grandChildren) {\n          if (err) return cb(err); // add prefix to grandchildren\n\n          grandChildren.forEach(function (grandChild) {\n            paths.push({\n              path: child.path + '/' + grandChild.path,\n              value: grandChild.value\n            });\n          });\n          cb();\n        });\n      }, function (err) {\n        if (err) return callback(err);\n        callback(null, paths);\n      });\n    });\n  } // create map from merkle-patricia-tree nodes\n\n\n  function mapFromBaseTrie(trieNode, options, callback) {\n    var paths = [];\n\n    if (trieNode.type === 'leaf') {\n      // leaf nodes resolve to their actual value\n      paths.push({\n        path: nibbleToPath(trieNode.getKey()),\n        value: trieNode.getValue()\n      });\n    }\n\n    each(trieNode.getChildren(), function (childData, next) {\n      var key = nibbleToPath(childData[0]);\n      var value = childData[1];\n\n      if (EthTrieNode.isRawNode(value)) {\n        // inline child root\n        var childNode = new EthTrieNode(value);\n        paths.push({\n          path: key,\n          value: childNode\n        }); // inline child non-leaf subpaths\n\n        mapFromBaseTrie(childNode, options, function (err, subtree) {\n          if (err) return next(err);\n          subtree.forEach(function (path) {\n            path.path = key + '/' + path.path;\n          });\n          paths = paths.concat(subtree);\n          next();\n        });\n      } else {\n        // other nodes link by hash\n        var link = {\n          '/': cidFromHash(multicodec, value).toBaseEncodedString()\n        };\n        paths.push({\n          path: key,\n          value: link\n        });\n        next();\n      }\n    }, function (err) {\n      if (err) return callback(err);\n      callback(null, paths);\n    });\n  }\n}\n\nfunction nibbleToPath(data) {\n  return data.map(function (num) {\n    return num.toString(16);\n  }).join('/');\n}","map":null,"metadata":{},"sourceType":"script"}